// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameServer.proto

#ifndef PROTOBUF_GameServer_2eproto__INCLUDED
#define PROTOBUF_GameServer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "CommomDef.pb.h"
#include "Stage.pb.h"
#include "Fuben.pb.h"
#include "MapLogic.pb.h"
#include "Item.pb.h"
#include "Character.pb.h"
#include "Quest.pb.h"
#include "Mail.pb.h"
#include "Market.pb.h"
#include "Altar.pb.h"
#include "Dungeon.pb.h"
#include "BaoQi.pb.h"
#include "Smithy.pb.h"
#include "Buff.pb.h"
#include "Technology.pb.h"
#include "Module.pb.h"
#include "Activity.pb.h"
#include "Palace.pb.h"
#include "World.pb.h"
#include "TeachMap.pb.h"
#include "Rank.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GameServer_2eproto();
void protobuf_AssignDesc_GameServer_2eproto();
void protobuf_ShutdownFile_GameServer_2eproto();

class OtherInfo;
class PlayerAllData;
class CreatePlayerData;
class RegistCrossPlayerData;
class PlayerAppendData;
class SyncPlayerCacheData;
class CQuickLogin;
class SQuickLogin;
class GS2C_ItemOperateError;
class GS2C_Player_Online_State;
class C2GS_Is_Player_Exist;
class GS2C_Is_Player_Exist;
class FeedbackInfo;
class FeedbackRet;
class NUll_Ret;

enum KickErrorType {
  RELOGIN = 1
};
bool KickErrorType_IsValid(int value);
const KickErrorType KickErrorType_MIN = RELOGIN;
const KickErrorType KickErrorType_MAX = RELOGIN;
const int KickErrorType_ARRAYSIZE = KickErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* KickErrorType_descriptor();
inline const ::std::string& KickErrorType_Name(KickErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    KickErrorType_descriptor(), value);
}
inline bool KickErrorType_Parse(
    const ::std::string& name, KickErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KickErrorType>(
    KickErrorType_descriptor(), name, value);
}
enum QuickLoginResult {
  QUICK_LOGIN_SUCCESS = 0,
  QUICK_LOGIN_SUCCESS_NO_PLAYER = 1,
  QUICK_LOGIN_KEY_ERROR = 2,
  QUICK_LOGIN_KEY_PAST_DUE = 3,
  QUICK_LOGIN_KEY_UNAVAILABLE_SERVER = 4,
  QUICK_LOGIN_CAN_NOT_FIND_KEY_INFO = 5,
  QUICK_LOGIN_NEED_RELOGIN_AGAIN = 6
};
bool QuickLoginResult_IsValid(int value);
const QuickLoginResult QuickLoginResult_MIN = QUICK_LOGIN_SUCCESS;
const QuickLoginResult QuickLoginResult_MAX = QUICK_LOGIN_NEED_RELOGIN_AGAIN;
const int QuickLoginResult_ARRAYSIZE = QuickLoginResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* QuickLoginResult_descriptor();
inline const ::std::string& QuickLoginResult_Name(QuickLoginResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    QuickLoginResult_descriptor(), value);
}
inline bool QuickLoginResult_Parse(
    const ::std::string& name, QuickLoginResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QuickLoginResult>(
    QuickLoginResult_descriptor(), name, value);
}
// ===================================================================

class OtherInfo : public ::google::protobuf::Message {
 public:
  OtherInfo();
  virtual ~OtherInfo();

  OtherInfo(const OtherInfo& from);

  inline OtherInfo& operator=(const OtherInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OtherInfo& default_instance();

  void Swap(OtherInfo* other);

  // implements Message ----------------------------------------------

  OtherInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OtherInfo& from);
  void MergeFrom(const OtherInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional uint32 platform_id = 2;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 2;
  inline ::google::protobuf::uint32 platform_id() const;
  inline void set_platform_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.OtherInfo)
 private:
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 platform_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static OtherInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerAllData : public ::google::protobuf::Message {
 public:
  PlayerAllData();
  virtual ~PlayerAllData();

  PlayerAllData(const PlayerAllData& from);

  inline PlayerAllData& operator=(const PlayerAllData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerAllData& default_instance();

  void Swap(PlayerAllData* other);

  // implements Message ----------------------------------------------

  PlayerAllData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerAllData& from);
  void MergeFrom(const PlayerAllData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ObjectFullValue full_value = 1;
  inline bool has_full_value() const;
  inline void clear_full_value();
  static const int kFullValueFieldNumber = 1;
  inline const ::pb::ObjectFullValue& full_value() const;
  inline ::pb::ObjectFullValue* mutable_full_value();
  inline ::pb::ObjectFullValue* release_full_value();
  inline void set_allocated_full_value(::pb::ObjectFullValue* full_value);

  // optional .pb.GS2C_Bag bag_info = 2;
  inline bool has_bag_info() const;
  inline void clear_bag_info();
  static const int kBagInfoFieldNumber = 2;
  inline const ::pb::GS2C_Bag& bag_info() const;
  inline ::pb::GS2C_Bag* mutable_bag_info();
  inline ::pb::GS2C_Bag* release_bag_info();
  inline void set_allocated_bag_info(::pb::GS2C_Bag* bag_info);

  // optional .pb.GS2C_CharacterStorage character_info = 3;
  inline bool has_character_info() const;
  inline void clear_character_info();
  static const int kCharacterInfoFieldNumber = 3;
  inline const ::pb::GS2C_CharacterStorage& character_info() const;
  inline ::pb::GS2C_CharacterStorage* mutable_character_info();
  inline ::pb::GS2C_CharacterStorage* release_character_info();
  inline void set_allocated_character_info(::pb::GS2C_CharacterStorage* character_info);

  // optional .pb.GS2C_Mail_MailList mails = 4;
  inline bool has_mails() const;
  inline void clear_mails();
  static const int kMailsFieldNumber = 4;
  inline const ::pb::GS2C_Mail_MailList& mails() const;
  inline ::pb::GS2C_Mail_MailList* mutable_mails();
  inline ::pb::GS2C_Mail_MailList* release_mails();
  inline void set_allocated_mails(::pb::GS2C_Mail_MailList* mails);

  // optional .pb.GS2C_QuestList quest_log = 5;
  inline bool has_quest_log() const;
  inline void clear_quest_log();
  static const int kQuestLogFieldNumber = 5;
  inline const ::pb::GS2C_QuestList& quest_log() const;
  inline ::pb::GS2C_QuestList* mutable_quest_log();
  inline ::pb::GS2C_QuestList* release_quest_log();
  inline void set_allocated_quest_log(::pb::GS2C_QuestList* quest_log);

  // optional .pb.GxDB_BehaviorList behavior_count = 6;
  inline bool has_behavior_count() const;
  inline void clear_behavior_count();
  static const int kBehaviorCountFieldNumber = 6;
  inline const ::pb::GxDB_BehaviorList& behavior_count() const;
  inline ::pb::GxDB_BehaviorList* mutable_behavior_count();
  inline ::pb::GxDB_BehaviorList* release_behavior_count();
  inline void set_allocated_behavior_count(::pb::GxDB_BehaviorList* behavior_count);

  // optional .pb.OtherInfo other_info = 7;
  inline bool has_other_info() const;
  inline void clear_other_info();
  static const int kOtherInfoFieldNumber = 7;
  inline const ::pb::OtherInfo& other_info() const;
  inline ::pb::OtherInfo* mutable_other_info();
  inline ::pb::OtherInfo* release_other_info();
  inline void set_allocated_other_info(::pb::OtherInfo* other_info);

  // optional .pb.GS2C_PlayerStringGroup string_data = 8;
  inline bool has_string_data() const;
  inline void clear_string_data();
  static const int kStringDataFieldNumber = 8;
  inline const ::pb::GS2C_PlayerStringGroup& string_data() const;
  inline ::pb::GS2C_PlayerStringGroup* mutable_string_data();
  inline ::pb::GS2C_PlayerStringGroup* release_string_data();
  inline void set_allocated_string_data(::pb::GS2C_PlayerStringGroup* string_data);

  // optional .pb.GS2C_Fuben_All_Info fuben_info = 9;
  inline bool has_fuben_info() const;
  inline void clear_fuben_info();
  static const int kFubenInfoFieldNumber = 9;
  inline const ::pb::GS2C_Fuben_All_Info& fuben_info() const;
  inline ::pb::GS2C_Fuben_All_Info* mutable_fuben_info();
  inline ::pb::GS2C_Fuben_All_Info* release_fuben_info();
  inline void set_allocated_fuben_info(::pb::GS2C_Fuben_All_Info* fuben_info);

  // optional .pb.GS2C_MapLogic_Init world_map_logic = 10;
  inline bool has_world_map_logic() const;
  inline void clear_world_map_logic();
  static const int kWorldMapLogicFieldNumber = 10;
  inline const ::pb::GS2C_MapLogic_Init& world_map_logic() const;
  inline ::pb::GS2C_MapLogic_Init* mutable_world_map_logic();
  inline ::pb::GS2C_MapLogic_Init* release_world_map_logic();
  inline void set_allocated_world_map_logic(::pb::GS2C_MapLogic_Init* world_map_logic);

  // optional .pb.GS2C_Market_All_Info market_info = 11;
  inline bool has_market_info() const;
  inline void clear_market_info();
  static const int kMarketInfoFieldNumber = 11;
  inline const ::pb::GS2C_Market_All_Info& market_info() const;
  inline ::pb::GS2C_Market_All_Info* mutable_market_info();
  inline ::pb::GS2C_Market_All_Info* release_market_info();
  inline void set_allocated_market_info(::pb::GS2C_Market_All_Info* market_info);

  // optional .pb.GS2C_Altar_All_Info altar_info = 12;
  inline bool has_altar_info() const;
  inline void clear_altar_info();
  static const int kAltarInfoFieldNumber = 12;
  inline const ::pb::GS2C_Altar_All_Info& altar_info() const;
  inline ::pb::GS2C_Altar_All_Info* mutable_altar_info();
  inline ::pb::GS2C_Altar_All_Info* release_altar_info();
  inline void set_allocated_altar_info(::pb::GS2C_Altar_All_Info* altar_info);

  // optional .pb.GS2C_Dungeon_All_Info dungeon_info = 13;
  inline bool has_dungeon_info() const;
  inline void clear_dungeon_info();
  static const int kDungeonInfoFieldNumber = 13;
  inline const ::pb::GS2C_Dungeon_All_Info& dungeon_info() const;
  inline ::pb::GS2C_Dungeon_All_Info* mutable_dungeon_info();
  inline ::pb::GS2C_Dungeon_All_Info* release_dungeon_info();
  inline void set_allocated_dungeon_info(::pb::GS2C_Dungeon_All_Info* dungeon_info);

  // optional .pb.GS2C_BaoQi_All_Info bao_qi_info = 14;
  inline bool has_bao_qi_info() const;
  inline void clear_bao_qi_info();
  static const int kBaoQiInfoFieldNumber = 14;
  inline const ::pb::GS2C_BaoQi_All_Info& bao_qi_info() const;
  inline ::pb::GS2C_BaoQi_All_Info* mutable_bao_qi_info();
  inline ::pb::GS2C_BaoQi_All_Info* release_bao_qi_info();
  inline void set_allocated_bao_qi_info(::pb::GS2C_BaoQi_All_Info* bao_qi_info);

  // optional .pb.GS2C_Smithy_All_Info smithy_info = 15;
  inline bool has_smithy_info() const;
  inline void clear_smithy_info();
  static const int kSmithyInfoFieldNumber = 15;
  inline const ::pb::GS2C_Smithy_All_Info& smithy_info() const;
  inline ::pb::GS2C_Smithy_All_Info* mutable_smithy_info();
  inline ::pb::GS2C_Smithy_All_Info* release_smithy_info();
  inline void set_allocated_smithy_info(::pb::GS2C_Smithy_All_Info* smithy_info);

  // optional .pb.GS2C_Buff_All_Info buff_info = 16;
  inline bool has_buff_info() const;
  inline void clear_buff_info();
  static const int kBuffInfoFieldNumber = 16;
  inline const ::pb::GS2C_Buff_All_Info& buff_info() const;
  inline ::pb::GS2C_Buff_All_Info* mutable_buff_info();
  inline ::pb::GS2C_Buff_All_Info* release_buff_info();
  inline void set_allocated_buff_info(::pb::GS2C_Buff_All_Info* buff_info);

  // optional .pb.GxDB_Technology_All_Info technology_info = 17;
  inline bool has_technology_info() const;
  inline void clear_technology_info();
  static const int kTechnologyInfoFieldNumber = 17;
  inline const ::pb::GxDB_Technology_All_Info& technology_info() const;
  inline ::pb::GxDB_Technology_All_Info* mutable_technology_info();
  inline ::pb::GxDB_Technology_All_Info* release_technology_info();
  inline void set_allocated_technology_info(::pb::GxDB_Technology_All_Info* technology_info);

  // optional .pb.GxDB_Daily_Quest dailyquest_info = 18;
  inline bool has_dailyquest_info() const;
  inline void clear_dailyquest_info();
  static const int kDailyquestInfoFieldNumber = 18;
  inline const ::pb::GxDB_Daily_Quest& dailyquest_info() const;
  inline ::pb::GxDB_Daily_Quest* mutable_dailyquest_info();
  inline ::pb::GxDB_Daily_Quest* release_dailyquest_info();
  inline void set_allocated_dailyquest_info(::pb::GxDB_Daily_Quest* dailyquest_info);

  // optional .pb.GxDB_Grow_Up_Quest growupquest_info = 19;
  inline bool has_growupquest_info() const;
  inline void clear_growupquest_info();
  static const int kGrowupquestInfoFieldNumber = 19;
  inline const ::pb::GxDB_Grow_Up_Quest& growupquest_info() const;
  inline ::pb::GxDB_Grow_Up_Quest* mutable_growupquest_info();
  inline ::pb::GxDB_Grow_Up_Quest* release_growupquest_info();
  inline void set_allocated_growupquest_info(::pb::GxDB_Grow_Up_Quest* growupquest_info);

  // optional .pb.GxDB_Grow_Up_Quest_Group growupquestgroup_info = 20;
  inline bool has_growupquestgroup_info() const;
  inline void clear_growupquestgroup_info();
  static const int kGrowupquestgroupInfoFieldNumber = 20;
  inline const ::pb::GxDB_Grow_Up_Quest_Group& growupquestgroup_info() const;
  inline ::pb::GxDB_Grow_Up_Quest_Group* mutable_growupquestgroup_info();
  inline ::pb::GxDB_Grow_Up_Quest_Group* release_growupquestgroup_info();
  inline void set_allocated_growupquestgroup_info(::pb::GxDB_Grow_Up_Quest_Group* growupquestgroup_info);

  // optional .pb.GxDB_Sign_Up sign_up_info = 21;
  inline bool has_sign_up_info() const;
  inline void clear_sign_up_info();
  static const int kSignUpInfoFieldNumber = 21;
  inline const ::pb::GxDB_Sign_Up& sign_up_info() const;
  inline ::pb::GxDB_Sign_Up* mutable_sign_up_info();
  inline ::pb::GxDB_Sign_Up* release_sign_up_info();
  inline void set_allocated_sign_up_info(::pb::GxDB_Sign_Up* sign_up_info);

  // optional .pb.GxDB_Pass_Stage_Reward pass_stage_reward_info = 22;
  inline bool has_pass_stage_reward_info() const;
  inline void clear_pass_stage_reward_info();
  static const int kPassStageRewardInfoFieldNumber = 22;
  inline const ::pb::GxDB_Pass_Stage_Reward& pass_stage_reward_info() const;
  inline ::pb::GxDB_Pass_Stage_Reward* mutable_pass_stage_reward_info();
  inline ::pb::GxDB_Pass_Stage_Reward* release_pass_stage_reward_info();
  inline void set_allocated_pass_stage_reward_info(::pb::GxDB_Pass_Stage_Reward* pass_stage_reward_info);

  // optional .pb.GxDB_ActivityStarBox activity_star_box_info = 23;
  inline bool has_activity_star_box_info() const;
  inline void clear_activity_star_box_info();
  static const int kActivityStarBoxInfoFieldNumber = 23;
  inline const ::pb::GxDB_ActivityStarBox& activity_star_box_info() const;
  inline ::pb::GxDB_ActivityStarBox* mutable_activity_star_box_info();
  inline ::pb::GxDB_ActivityStarBox* release_activity_star_box_info();
  inline void set_allocated_activity_star_box_info(::pb::GxDB_ActivityStarBox* activity_star_box_info);

  // optional .pb.GxDB_PalaceAchievement achievement_info = 24;
  inline bool has_achievement_info() const;
  inline void clear_achievement_info();
  static const int kAchievementInfoFieldNumber = 24;
  inline const ::pb::GxDB_PalaceAchievement& achievement_info() const;
  inline ::pb::GxDB_PalaceAchievement* mutable_achievement_info();
  inline ::pb::GxDB_PalaceAchievement* release_achievement_info();
  inline void set_allocated_achievement_info(::pb::GxDB_PalaceAchievement* achievement_info);

  // optional .pb.GxDB_GovAffairsInfo gov_affairs_info = 25;
  inline bool has_gov_affairs_info() const;
  inline void clear_gov_affairs_info();
  static const int kGovAffairsInfoFieldNumber = 25;
  inline const ::pb::GxDB_GovAffairsInfo& gov_affairs_info() const;
  inline ::pb::GxDB_GovAffairsInfo* mutable_gov_affairs_info();
  inline ::pb::GxDB_GovAffairsInfo* release_gov_affairs_info();
  inline void set_allocated_gov_affairs_info(::pb::GxDB_GovAffairsInfo* gov_affairs_info);

  // optional .pb.GxDB_Hero_Reward hero_reward = 26;
  inline bool has_hero_reward() const;
  inline void clear_hero_reward();
  static const int kHeroRewardFieldNumber = 26;
  inline const ::pb::GxDB_Hero_Reward& hero_reward() const;
  inline ::pb::GxDB_Hero_Reward* mutable_hero_reward();
  inline ::pb::GxDB_Hero_Reward* release_hero_reward();
  inline void set_allocated_hero_reward(::pb::GxDB_Hero_Reward* hero_reward);

  // optional .pb.GxDB_World_Achievement world_fight_achieve_info = 27;
  inline bool has_world_fight_achieve_info() const;
  inline void clear_world_fight_achieve_info();
  static const int kWorldFightAchieveInfoFieldNumber = 27;
  inline const ::pb::GxDB_World_Achievement& world_fight_achieve_info() const;
  inline ::pb::GxDB_World_Achievement* mutable_world_fight_achieve_info();
  inline ::pb::GxDB_World_Achievement* release_world_fight_achieve_info();
  inline void set_allocated_world_fight_achieve_info(::pb::GxDB_World_Achievement* world_fight_achieve_info);

  // optional .pb.GxDB_Seige_Force_Info_Pack seige_force_info = 28;
  inline bool has_seige_force_info() const;
  inline void clear_seige_force_info();
  static const int kSeigeForceInfoFieldNumber = 28;
  inline const ::pb::GxDB_Seige_Force_Info_Pack& seige_force_info() const;
  inline ::pb::GxDB_Seige_Force_Info_Pack* mutable_seige_force_info();
  inline ::pb::GxDB_Seige_Force_Info_Pack* release_seige_force_info();
  inline void set_allocated_seige_force_info(::pb::GxDB_Seige_Force_Info_Pack* seige_force_info);

  // optional .pb.GxDB_ContinueOccupyCityInfo continue_info = 29;
  inline bool has_continue_info() const;
  inline void clear_continue_info();
  static const int kContinueInfoFieldNumber = 29;
  inline const ::pb::GxDB_ContinueOccupyCityInfo& continue_info() const;
  inline ::pb::GxDB_ContinueOccupyCityInfo* mutable_continue_info();
  inline ::pb::GxDB_ContinueOccupyCityInfo* release_continue_info();
  inline void set_allocated_continue_info(::pb::GxDB_ContinueOccupyCityInfo* continue_info);

  // optional .pb.GS2C_Get_Teach_Rec teach_rec = 30;
  inline bool has_teach_rec() const;
  inline void clear_teach_rec();
  static const int kTeachRecFieldNumber = 30;
  inline const ::pb::GS2C_Get_Teach_Rec& teach_rec() const;
  inline ::pb::GS2C_Get_Teach_Rec* mutable_teach_rec();
  inline ::pb::GS2C_Get_Teach_Rec* release_teach_rec();
  inline void set_allocated_teach_rec(::pb::GS2C_Get_Teach_Rec* teach_rec);

  // optional .pb.GxDB_CongratulateRewardLog congratulate_info = 31;
  inline bool has_congratulate_info() const;
  inline void clear_congratulate_info();
  static const int kCongratulateInfoFieldNumber = 31;
  inline const ::pb::GxDB_CongratulateRewardLog& congratulate_info() const;
  inline ::pb::GxDB_CongratulateRewardLog* mutable_congratulate_info();
  inline ::pb::GxDB_CongratulateRewardLog* release_congratulate_info();
  inline void set_allocated_congratulate_info(::pb::GxDB_CongratulateRewardLog* congratulate_info);

  // optional .pb.GxDB_CongratulateBeenCongratualted con_been_congratulated = 32;
  inline bool has_con_been_congratulated() const;
  inline void clear_con_been_congratulated();
  static const int kConBeenCongratulatedFieldNumber = 32;
  inline const ::pb::GxDB_CongratulateBeenCongratualted& con_been_congratulated() const;
  inline ::pb::GxDB_CongratulateBeenCongratualted* mutable_con_been_congratulated();
  inline ::pb::GxDB_CongratulateBeenCongratualted* release_con_been_congratulated();
  inline void set_allocated_con_been_congratulated(::pb::GxDB_CongratulateBeenCongratualted* con_been_congratulated);

  // optional .pb.GxDB_WannaBeStrongerInfoAllInfo wanna_be_info = 33;
  inline bool has_wanna_be_info() const;
  inline void clear_wanna_be_info();
  static const int kWannaBeInfoFieldNumber = 33;
  inline const ::pb::GxDB_WannaBeStrongerInfoAllInfo& wanna_be_info() const;
  inline ::pb::GxDB_WannaBeStrongerInfoAllInfo* mutable_wanna_be_info();
  inline ::pb::GxDB_WannaBeStrongerInfoAllInfo* release_wanna_be_info();
  inline void set_allocated_wanna_be_info(::pb::GxDB_WannaBeStrongerInfoAllInfo* wanna_be_info);

  // @@protoc_insertion_point(class_scope:pb.PlayerAllData)
 private:
  inline void set_has_full_value();
  inline void clear_has_full_value();
  inline void set_has_bag_info();
  inline void clear_has_bag_info();
  inline void set_has_character_info();
  inline void clear_has_character_info();
  inline void set_has_mails();
  inline void clear_has_mails();
  inline void set_has_quest_log();
  inline void clear_has_quest_log();
  inline void set_has_behavior_count();
  inline void clear_has_behavior_count();
  inline void set_has_other_info();
  inline void clear_has_other_info();
  inline void set_has_string_data();
  inline void clear_has_string_data();
  inline void set_has_fuben_info();
  inline void clear_has_fuben_info();
  inline void set_has_world_map_logic();
  inline void clear_has_world_map_logic();
  inline void set_has_market_info();
  inline void clear_has_market_info();
  inline void set_has_altar_info();
  inline void clear_has_altar_info();
  inline void set_has_dungeon_info();
  inline void clear_has_dungeon_info();
  inline void set_has_bao_qi_info();
  inline void clear_has_bao_qi_info();
  inline void set_has_smithy_info();
  inline void clear_has_smithy_info();
  inline void set_has_buff_info();
  inline void clear_has_buff_info();
  inline void set_has_technology_info();
  inline void clear_has_technology_info();
  inline void set_has_dailyquest_info();
  inline void clear_has_dailyquest_info();
  inline void set_has_growupquest_info();
  inline void clear_has_growupquest_info();
  inline void set_has_growupquestgroup_info();
  inline void clear_has_growupquestgroup_info();
  inline void set_has_sign_up_info();
  inline void clear_has_sign_up_info();
  inline void set_has_pass_stage_reward_info();
  inline void clear_has_pass_stage_reward_info();
  inline void set_has_activity_star_box_info();
  inline void clear_has_activity_star_box_info();
  inline void set_has_achievement_info();
  inline void clear_has_achievement_info();
  inline void set_has_gov_affairs_info();
  inline void clear_has_gov_affairs_info();
  inline void set_has_hero_reward();
  inline void clear_has_hero_reward();
  inline void set_has_world_fight_achieve_info();
  inline void clear_has_world_fight_achieve_info();
  inline void set_has_seige_force_info();
  inline void clear_has_seige_force_info();
  inline void set_has_continue_info();
  inline void clear_has_continue_info();
  inline void set_has_teach_rec();
  inline void clear_has_teach_rec();
  inline void set_has_congratulate_info();
  inline void clear_has_congratulate_info();
  inline void set_has_con_been_congratulated();
  inline void clear_has_con_been_congratulated();
  inline void set_has_wanna_be_info();
  inline void clear_has_wanna_be_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::ObjectFullValue* full_value_;
  ::pb::GS2C_Bag* bag_info_;
  ::pb::GS2C_CharacterStorage* character_info_;
  ::pb::GS2C_Mail_MailList* mails_;
  ::pb::GS2C_QuestList* quest_log_;
  ::pb::GxDB_BehaviorList* behavior_count_;
  ::pb::OtherInfo* other_info_;
  ::pb::GS2C_PlayerStringGroup* string_data_;
  ::pb::GS2C_Fuben_All_Info* fuben_info_;
  ::pb::GS2C_MapLogic_Init* world_map_logic_;
  ::pb::GS2C_Market_All_Info* market_info_;
  ::pb::GS2C_Altar_All_Info* altar_info_;
  ::pb::GS2C_Dungeon_All_Info* dungeon_info_;
  ::pb::GS2C_BaoQi_All_Info* bao_qi_info_;
  ::pb::GS2C_Smithy_All_Info* smithy_info_;
  ::pb::GS2C_Buff_All_Info* buff_info_;
  ::pb::GxDB_Technology_All_Info* technology_info_;
  ::pb::GxDB_Daily_Quest* dailyquest_info_;
  ::pb::GxDB_Grow_Up_Quest* growupquest_info_;
  ::pb::GxDB_Grow_Up_Quest_Group* growupquestgroup_info_;
  ::pb::GxDB_Sign_Up* sign_up_info_;
  ::pb::GxDB_Pass_Stage_Reward* pass_stage_reward_info_;
  ::pb::GxDB_ActivityStarBox* activity_star_box_info_;
  ::pb::GxDB_PalaceAchievement* achievement_info_;
  ::pb::GxDB_GovAffairsInfo* gov_affairs_info_;
  ::pb::GxDB_Hero_Reward* hero_reward_;
  ::pb::GxDB_World_Achievement* world_fight_achieve_info_;
  ::pb::GxDB_Seige_Force_Info_Pack* seige_force_info_;
  ::pb::GxDB_ContinueOccupyCityInfo* continue_info_;
  ::pb::GS2C_Get_Teach_Rec* teach_rec_;
  ::pb::GxDB_CongratulateRewardLog* congratulate_info_;
  ::pb::GxDB_CongratulateBeenCongratualted* con_been_congratulated_;
  ::pb::GxDB_WannaBeStrongerInfoAllInfo* wanna_be_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(33 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static PlayerAllData* default_instance_;
};
// -------------------------------------------------------------------

class CreatePlayerData : public ::google::protobuf::Message {
 public:
  CreatePlayerData();
  virtual ~CreatePlayerData();

  CreatePlayerData(const CreatePlayerData& from);

  inline CreatePlayerData& operator=(const CreatePlayerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePlayerData& default_instance();

  void Swap(CreatePlayerData* other);

  // implements Message ----------------------------------------------

  CreatePlayerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreatePlayerData& from);
  void MergeFrom(const CreatePlayerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint64 account_id() const;
  inline void set_account_id(::google::protobuf::uint64 value);

  // required .pb.PlayerAllData all_data = 2;
  inline bool has_all_data() const;
  inline void clear_all_data();
  static const int kAllDataFieldNumber = 2;
  inline const ::pb::PlayerAllData& all_data() const;
  inline ::pb::PlayerAllData* mutable_all_data();
  inline ::pb::PlayerAllData* release_all_data();
  inline void set_allocated_all_data(::pb::PlayerAllData* all_data);

  // @@protoc_insertion_point(class_scope:pb.CreatePlayerData)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_all_data();
  inline void clear_has_all_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 account_id_;
  ::pb::PlayerAllData* all_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static CreatePlayerData* default_instance_;
};
// -------------------------------------------------------------------

class RegistCrossPlayerData : public ::google::protobuf::Message {
 public:
  RegistCrossPlayerData();
  virtual ~RegistCrossPlayerData();

  RegistCrossPlayerData(const RegistCrossPlayerData& from);

  inline RegistCrossPlayerData& operator=(const RegistCrossPlayerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegistCrossPlayerData& default_instance();

  void Swap(RegistCrossPlayerData* other);

  // implements Message ----------------------------------------------

  RegistCrossPlayerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegistCrossPlayerData& from);
  void MergeFrom(const RegistCrossPlayerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.PlayerAllData player_data = 1;
  inline bool has_player_data() const;
  inline void clear_player_data();
  static const int kPlayerDataFieldNumber = 1;
  inline const ::pb::PlayerAllData& player_data() const;
  inline ::pb::PlayerAllData* mutable_player_data();
  inline ::pb::PlayerAllData* release_player_data();
  inline void set_allocated_player_data(::pb::PlayerAllData* player_data);

  // optional .pb.PlayerAppendData append = 2;
  inline bool has_append() const;
  inline void clear_append();
  static const int kAppendFieldNumber = 2;
  inline const ::pb::PlayerAppendData& append() const;
  inline ::pb::PlayerAppendData* mutable_append();
  inline ::pb::PlayerAppendData* release_append();
  inline void set_allocated_append(::pb::PlayerAppendData* append);

  // optional uint32 country_id = 3;
  inline bool has_country_id() const;
  inline void clear_country_id();
  static const int kCountryIdFieldNumber = 3;
  inline ::google::protobuf::uint32 country_id() const;
  inline void set_country_id(::google::protobuf::uint32 value);

  // optional uint64 account_id = 4;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 4;
  inline ::google::protobuf::uint64 account_id() const;
  inline void set_account_id(::google::protobuf::uint64 value);

  // optional uint32 cross_Unique_id = 5;
  inline bool has_cross_unique_id() const;
  inline void clear_cross_unique_id();
  static const int kCrossUniqueIdFieldNumber = 5;
  inline ::google::protobuf::uint32 cross_unique_id() const;
  inline void set_cross_unique_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.RegistCrossPlayerData)
 private:
  inline void set_has_player_data();
  inline void clear_has_player_data();
  inline void set_has_append();
  inline void clear_has_append();
  inline void set_has_country_id();
  inline void clear_has_country_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_cross_unique_id();
  inline void clear_has_cross_unique_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::PlayerAllData* player_data_;
  ::pb::PlayerAppendData* append_;
  ::google::protobuf::uint64 account_id_;
  ::google::protobuf::uint32 country_id_;
  ::google::protobuf::uint32 cross_unique_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static RegistCrossPlayerData* default_instance_;
};
// -------------------------------------------------------------------

class PlayerAppendData : public ::google::protobuf::Message {
 public:
  PlayerAppendData();
  virtual ~PlayerAppendData();

  PlayerAppendData(const PlayerAppendData& from);

  inline PlayerAppendData& operator=(const PlayerAppendData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerAppendData& default_instance();

  void Swap(PlayerAppendData* other);

  // implements Message ----------------------------------------------

  PlayerAppendData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerAppendData& from);
  void MergeFrom(const PlayerAppendData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.GxDB_Modules_Info module = 1;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 1;
  inline const ::pb::GxDB_Modules_Info& module() const;
  inline ::pb::GxDB_Modules_Info* mutable_module();
  inline ::pb::GxDB_Modules_Info* release_module();
  inline void set_allocated_module(::pb::GxDB_Modules_Info* module);

  // optional .pb.GxDB_Buildings_Info building = 2;
  inline bool has_building() const;
  inline void clear_building();
  static const int kBuildingFieldNumber = 2;
  inline const ::pb::GxDB_Buildings_Info& building() const;
  inline ::pb::GxDB_Buildings_Info* mutable_building();
  inline ::pb::GxDB_Buildings_Info* release_building();
  inline void set_allocated_building(::pb::GxDB_Buildings_Info* building);

  // @@protoc_insertion_point(class_scope:pb.PlayerAppendData)
 private:
  inline void set_has_module();
  inline void clear_has_module();
  inline void set_has_building();
  inline void clear_has_building();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::GxDB_Modules_Info* module_;
  ::pb::GxDB_Buildings_Info* building_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static PlayerAppendData* default_instance_;
};
// -------------------------------------------------------------------

class SyncPlayerCacheData : public ::google::protobuf::Message {
 public:
  SyncPlayerCacheData();
  virtual ~SyncPlayerCacheData();

  SyncPlayerCacheData(const SyncPlayerCacheData& from);

  inline SyncPlayerCacheData& operator=(const SyncPlayerCacheData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncPlayerCacheData& default_instance();

  void Swap(SyncPlayerCacheData* other);

  // implements Message ----------------------------------------------

  SyncPlayerCacheData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncPlayerCacheData& from);
  void MergeFrom(const SyncPlayerCacheData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint64 account_id() const;
  inline void set_account_id(::google::protobuf::uint64 value);

  // required .pb.PlayerAllData all_data = 2;
  inline bool has_all_data() const;
  inline void clear_all_data();
  static const int kAllDataFieldNumber = 2;
  inline const ::pb::PlayerAllData& all_data() const;
  inline ::pb::PlayerAllData* mutable_all_data();
  inline ::pb::PlayerAllData* release_all_data();
  inline void set_allocated_all_data(::pb::PlayerAllData* all_data);

  // optional .pb.PlayerAppendData append = 3;
  inline bool has_append() const;
  inline void clear_append();
  static const int kAppendFieldNumber = 3;
  inline const ::pb::PlayerAppendData& append() const;
  inline ::pb::PlayerAppendData* mutable_append();
  inline ::pb::PlayerAppendData* release_append();
  inline void set_allocated_append(::pb::PlayerAppendData* append);

  // @@protoc_insertion_point(class_scope:pb.SyncPlayerCacheData)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_all_data();
  inline void clear_has_all_data();
  inline void set_has_append();
  inline void clear_has_append();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 account_id_;
  ::pb::PlayerAllData* all_data_;
  ::pb::PlayerAppendData* append_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static SyncPlayerCacheData* default_instance_;
};
// -------------------------------------------------------------------

class CQuickLogin : public ::google::protobuf::Message {
 public:
  CQuickLogin();
  virtual ~CQuickLogin();

  CQuickLogin(const CQuickLogin& from);

  inline CQuickLogin& operator=(const CQuickLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CQuickLogin& default_instance();

  void Swap(CQuickLogin* other);

  // implements Message ----------------------------------------------

  CQuickLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CQuickLogin& from);
  void MergeFrom(const CQuickLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint64 account_id() const;
  inline void set_account_id(::google::protobuf::uint64 value);

  // optional uint64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint64 player_id() const;
  inline void set_player_id(::google::protobuf::uint64 value);

  // optional string session_key = 3;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 3;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const char* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // optional uint32 platform_id = 4;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 4;
  inline ::google::protobuf::uint32 platform_id() const;
  inline void set_platform_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.CQuickLogin)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 account_id_;
  ::google::protobuf::uint64 player_id_;
  ::std::string* session_key_;
  ::google::protobuf::uint32 platform_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static CQuickLogin* default_instance_;
};
// -------------------------------------------------------------------

class SQuickLogin : public ::google::protobuf::Message {
 public:
  SQuickLogin();
  virtual ~SQuickLogin();

  SQuickLogin(const SQuickLogin& from);

  inline SQuickLogin& operator=(const SQuickLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SQuickLogin& default_instance();

  void Swap(SQuickLogin* other);

  // implements Message ----------------------------------------------

  SQuickLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SQuickLogin& from);
  void MergeFrom(const SQuickLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.QuickLoginResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::pb::QuickLoginResult result() const;
  inline void set_result(::pb::QuickLoginResult value);

  // @@protoc_insertion_point(class_scope:pb.SQuickLogin)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static SQuickLogin* default_instance_;
};
// -------------------------------------------------------------------

class GS2C_ItemOperateError : public ::google::protobuf::Message {
 public:
  GS2C_ItemOperateError();
  virtual ~GS2C_ItemOperateError();

  GS2C_ItemOperateError(const GS2C_ItemOperateError& from);

  inline GS2C_ItemOperateError& operator=(const GS2C_ItemOperateError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GS2C_ItemOperateError& default_instance();

  void Swap(GS2C_ItemOperateError* other);

  // implements Message ----------------------------------------------

  GS2C_ItemOperateError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GS2C_ItemOperateError& from);
  void MergeFrom(const GS2C_ItemOperateError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 error_type = 1;
  inline bool has_error_type() const;
  inline void clear_error_type();
  static const int kErrorTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_type() const;
  inline void set_error_type(::google::protobuf::uint32 value);

  // optional uint32 property = 2;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 2;
  inline ::google::protobuf::uint32 property() const;
  inline void set_property(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.GS2C_ItemOperateError)
 private:
  inline void set_has_error_type();
  inline void clear_has_error_type();
  inline void set_has_property();
  inline void clear_has_property();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 error_type_;
  ::google::protobuf::uint32 property_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GS2C_ItemOperateError* default_instance_;
};
// -------------------------------------------------------------------

class GS2C_Player_Online_State : public ::google::protobuf::Message {
 public:
  GS2C_Player_Online_State();
  virtual ~GS2C_Player_Online_State();

  GS2C_Player_Online_State(const GS2C_Player_Online_State& from);

  inline GS2C_Player_Online_State& operator=(const GS2C_Player_Online_State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GS2C_Player_Online_State& default_instance();

  void Swap(GS2C_Player_Online_State* other);

  // implements Message ----------------------------------------------

  GS2C_Player_Online_State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GS2C_Player_Online_State& from);
  void MergeFrom(const GS2C_Player_Online_State& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 player_guid = 1;
  inline bool has_player_guid() const;
  inline void clear_player_guid();
  static const int kPlayerGuidFieldNumber = 1;
  inline ::google::protobuf::uint64 player_guid() const;
  inline void set_player_guid(::google::protobuf::uint64 value);

  // optional string player_name = 2;
  inline bool has_player_name() const;
  inline void clear_player_name();
  static const int kPlayerNameFieldNumber = 2;
  inline const ::std::string& player_name() const;
  inline void set_player_name(const ::std::string& value);
  inline void set_player_name(const char* value);
  inline void set_player_name(const char* value, size_t size);
  inline ::std::string* mutable_player_name();
  inline ::std::string* release_player_name();
  inline void set_allocated_player_name(::std::string* player_name);

  // optional bool isonline = 3;
  inline bool has_isonline() const;
  inline void clear_isonline();
  static const int kIsonlineFieldNumber = 3;
  inline bool isonline() const;
  inline void set_isonline(bool value);

  // @@protoc_insertion_point(class_scope:pb.GS2C_Player_Online_State)
 private:
  inline void set_has_player_guid();
  inline void clear_has_player_guid();
  inline void set_has_player_name();
  inline void clear_has_player_name();
  inline void set_has_isonline();
  inline void clear_has_isonline();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 player_guid_;
  ::std::string* player_name_;
  bool isonline_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GS2C_Player_Online_State* default_instance_;
};
// -------------------------------------------------------------------

class C2GS_Is_Player_Exist : public ::google::protobuf::Message {
 public:
  C2GS_Is_Player_Exist();
  virtual ~C2GS_Is_Player_Exist();

  C2GS_Is_Player_Exist(const C2GS_Is_Player_Exist& from);

  inline C2GS_Is_Player_Exist& operator=(const C2GS_Is_Player_Exist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const C2GS_Is_Player_Exist& default_instance();

  void Swap(C2GS_Is_Player_Exist* other);

  // implements Message ----------------------------------------------

  C2GS_Is_Player_Exist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2GS_Is_Player_Exist& from);
  void MergeFrom(const C2GS_Is_Player_Exist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string player_name = 1;
  inline bool has_player_name() const;
  inline void clear_player_name();
  static const int kPlayerNameFieldNumber = 1;
  inline const ::std::string& player_name() const;
  inline void set_player_name(const ::std::string& value);
  inline void set_player_name(const char* value);
  inline void set_player_name(const char* value, size_t size);
  inline ::std::string* mutable_player_name();
  inline ::std::string* release_player_name();
  inline void set_allocated_player_name(::std::string* player_name);

  // required uint64 your_guid = 2;
  inline bool has_your_guid() const;
  inline void clear_your_guid();
  static const int kYourGuidFieldNumber = 2;
  inline ::google::protobuf::uint64 your_guid() const;
  inline void set_your_guid(::google::protobuf::uint64 value);

  // optional uint32 send_from = 3;
  inline bool has_send_from() const;
  inline void clear_send_from();
  static const int kSendFromFieldNumber = 3;
  inline ::google::protobuf::uint32 send_from() const;
  inline void set_send_from(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.C2GS_Is_Player_Exist)
 private:
  inline void set_has_player_name();
  inline void clear_has_player_name();
  inline void set_has_your_guid();
  inline void clear_has_your_guid();
  inline void set_has_send_from();
  inline void clear_has_send_from();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* player_name_;
  ::google::protobuf::uint64 your_guid_;
  ::google::protobuf::uint32 send_from_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static C2GS_Is_Player_Exist* default_instance_;
};
// -------------------------------------------------------------------

class GS2C_Is_Player_Exist : public ::google::protobuf::Message {
 public:
  GS2C_Is_Player_Exist();
  virtual ~GS2C_Is_Player_Exist();

  GS2C_Is_Player_Exist(const GS2C_Is_Player_Exist& from);

  inline GS2C_Is_Player_Exist& operator=(const GS2C_Is_Player_Exist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GS2C_Is_Player_Exist& default_instance();

  void Swap(GS2C_Is_Player_Exist* other);

  // implements Message ----------------------------------------------

  GS2C_Is_Player_Exist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GS2C_Is_Player_Exist& from);
  void MergeFrom(const GS2C_Is_Player_Exist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_exist = 1;
  inline bool has_is_exist() const;
  inline void clear_is_exist();
  static const int kIsExistFieldNumber = 1;
  inline bool is_exist() const;
  inline void set_is_exist(bool value);

  // optional string player_name = 2;
  inline bool has_player_name() const;
  inline void clear_player_name();
  static const int kPlayerNameFieldNumber = 2;
  inline const ::std::string& player_name() const;
  inline void set_player_name(const ::std::string& value);
  inline void set_player_name(const char* value);
  inline void set_player_name(const char* value, size_t size);
  inline ::std::string* mutable_player_name();
  inline ::std::string* release_player_name();
  inline void set_allocated_player_name(::std::string* player_name);

  // optional bool is_online = 3;
  inline bool has_is_online() const;
  inline void clear_is_online();
  static const int kIsOnlineFieldNumber = 3;
  inline bool is_online() const;
  inline void set_is_online(bool value);

  // required uint64 your_guid = 4;
  inline bool has_your_guid() const;
  inline void clear_your_guid();
  static const int kYourGuidFieldNumber = 4;
  inline ::google::protobuf::uint64 your_guid() const;
  inline void set_your_guid(::google::protobuf::uint64 value);

  // optional uint32 send_from = 5;
  inline bool has_send_from() const;
  inline void clear_send_from();
  static const int kSendFromFieldNumber = 5;
  inline ::google::protobuf::uint32 send_from() const;
  inline void set_send_from(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.GS2C_Is_Player_Exist)
 private:
  inline void set_has_is_exist();
  inline void clear_has_is_exist();
  inline void set_has_player_name();
  inline void clear_has_player_name();
  inline void set_has_is_online();
  inline void clear_has_is_online();
  inline void set_has_your_guid();
  inline void clear_has_your_guid();
  inline void set_has_send_from();
  inline void clear_has_send_from();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* player_name_;
  bool is_exist_;
  bool is_online_;
  ::google::protobuf::uint32 send_from_;
  ::google::protobuf::uint64 your_guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GS2C_Is_Player_Exist* default_instance_;
};
// -------------------------------------------------------------------

class FeedbackInfo : public ::google::protobuf::Message {
 public:
  FeedbackInfo();
  virtual ~FeedbackInfo();

  FeedbackInfo(const FeedbackInfo& from);

  inline FeedbackInfo& operator=(const FeedbackInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeedbackInfo& default_instance();

  void Swap(FeedbackInfo* other);

  // implements Message ----------------------------------------------

  FeedbackInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeedbackInfo& from);
  void MergeFrom(const FeedbackInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string feedback = 1;
  inline bool has_feedback() const;
  inline void clear_feedback();
  static const int kFeedbackFieldNumber = 1;
  inline const ::std::string& feedback() const;
  inline void set_feedback(const ::std::string& value);
  inline void set_feedback(const char* value);
  inline void set_feedback(const char* value, size_t size);
  inline ::std::string* mutable_feedback();
  inline ::std::string* release_feedback();
  inline void set_allocated_feedback(::std::string* feedback);

  // @@protoc_insertion_point(class_scope:pb.FeedbackInfo)
 private:
  inline void set_has_feedback();
  inline void clear_has_feedback();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* feedback_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static FeedbackInfo* default_instance_;
};
// -------------------------------------------------------------------

class FeedbackRet : public ::google::protobuf::Message {
 public:
  FeedbackRet();
  virtual ~FeedbackRet();

  FeedbackRet(const FeedbackRet& from);

  inline FeedbackRet& operator=(const FeedbackRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeedbackRet& default_instance();

  void Swap(FeedbackRet* other);

  // implements Message ----------------------------------------------

  FeedbackRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeedbackRet& from);
  void MergeFrom(const FeedbackRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_success = 1;
  inline bool has_is_success() const;
  inline void clear_is_success();
  static const int kIsSuccessFieldNumber = 1;
  inline bool is_success() const;
  inline void set_is_success(bool value);

  // optional int32 error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.FeedbackRet)
 private:
  inline void set_has_is_success();
  inline void clear_has_is_success();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_success_;
  ::google::protobuf::int32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static FeedbackRet* default_instance_;
};
// -------------------------------------------------------------------

class NUll_Ret : public ::google::protobuf::Message {
 public:
  NUll_Ret();
  virtual ~NUll_Ret();

  NUll_Ret(const NUll_Ret& from);

  inline NUll_Ret& operator=(const NUll_Ret& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NUll_Ret& default_instance();

  void Swap(NUll_Ret* other);

  // implements Message ----------------------------------------------

  NUll_Ret* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NUll_Ret& from);
  void MergeFrom(const NUll_Ret& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.NUll_Ret)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_GameServer_2eproto();
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static NUll_Ret* default_instance_;
};
// ===================================================================


// ===================================================================

// OtherInfo

// optional uint32 channel_id = 1;
inline bool OtherInfo::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtherInfo::set_has_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtherInfo::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtherInfo::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 OtherInfo::channel_id() const {
  return channel_id_;
}
inline void OtherInfo::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// optional uint32 platform_id = 2;
inline bool OtherInfo::has_platform_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OtherInfo::set_has_platform_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OtherInfo::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OtherInfo::clear_platform_id() {
  platform_id_ = 0u;
  clear_has_platform_id();
}
inline ::google::protobuf::uint32 OtherInfo::platform_id() const {
  return platform_id_;
}
inline void OtherInfo::set_platform_id(::google::protobuf::uint32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// -------------------------------------------------------------------

// PlayerAllData

// optional .pb.ObjectFullValue full_value = 1;
inline bool PlayerAllData::has_full_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerAllData::set_has_full_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerAllData::clear_has_full_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerAllData::clear_full_value() {
  if (full_value_ != NULL) full_value_->::pb::ObjectFullValue::Clear();
  clear_has_full_value();
}
inline const ::pb::ObjectFullValue& PlayerAllData::full_value() const {
  return full_value_ != NULL ? *full_value_ : *default_instance_->full_value_;
}
inline ::pb::ObjectFullValue* PlayerAllData::mutable_full_value() {
  set_has_full_value();
  if (full_value_ == NULL) full_value_ = new ::pb::ObjectFullValue;
  return full_value_;
}
inline ::pb::ObjectFullValue* PlayerAllData::release_full_value() {
  clear_has_full_value();
  ::pb::ObjectFullValue* temp = full_value_;
  full_value_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_full_value(::pb::ObjectFullValue* full_value) {
  delete full_value_;
  full_value_ = full_value;
  if (full_value) {
    set_has_full_value();
  } else {
    clear_has_full_value();
  }
}

// optional .pb.GS2C_Bag bag_info = 2;
inline bool PlayerAllData::has_bag_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerAllData::set_has_bag_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerAllData::clear_has_bag_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerAllData::clear_bag_info() {
  if (bag_info_ != NULL) bag_info_->::pb::GS2C_Bag::Clear();
  clear_has_bag_info();
}
inline const ::pb::GS2C_Bag& PlayerAllData::bag_info() const {
  return bag_info_ != NULL ? *bag_info_ : *default_instance_->bag_info_;
}
inline ::pb::GS2C_Bag* PlayerAllData::mutable_bag_info() {
  set_has_bag_info();
  if (bag_info_ == NULL) bag_info_ = new ::pb::GS2C_Bag;
  return bag_info_;
}
inline ::pb::GS2C_Bag* PlayerAllData::release_bag_info() {
  clear_has_bag_info();
  ::pb::GS2C_Bag* temp = bag_info_;
  bag_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_bag_info(::pb::GS2C_Bag* bag_info) {
  delete bag_info_;
  bag_info_ = bag_info;
  if (bag_info) {
    set_has_bag_info();
  } else {
    clear_has_bag_info();
  }
}

// optional .pb.GS2C_CharacterStorage character_info = 3;
inline bool PlayerAllData::has_character_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerAllData::set_has_character_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerAllData::clear_has_character_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerAllData::clear_character_info() {
  if (character_info_ != NULL) character_info_->::pb::GS2C_CharacterStorage::Clear();
  clear_has_character_info();
}
inline const ::pb::GS2C_CharacterStorage& PlayerAllData::character_info() const {
  return character_info_ != NULL ? *character_info_ : *default_instance_->character_info_;
}
inline ::pb::GS2C_CharacterStorage* PlayerAllData::mutable_character_info() {
  set_has_character_info();
  if (character_info_ == NULL) character_info_ = new ::pb::GS2C_CharacterStorage;
  return character_info_;
}
inline ::pb::GS2C_CharacterStorage* PlayerAllData::release_character_info() {
  clear_has_character_info();
  ::pb::GS2C_CharacterStorage* temp = character_info_;
  character_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_character_info(::pb::GS2C_CharacterStorage* character_info) {
  delete character_info_;
  character_info_ = character_info;
  if (character_info) {
    set_has_character_info();
  } else {
    clear_has_character_info();
  }
}

// optional .pb.GS2C_Mail_MailList mails = 4;
inline bool PlayerAllData::has_mails() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerAllData::set_has_mails() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerAllData::clear_has_mails() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerAllData::clear_mails() {
  if (mails_ != NULL) mails_->::pb::GS2C_Mail_MailList::Clear();
  clear_has_mails();
}
inline const ::pb::GS2C_Mail_MailList& PlayerAllData::mails() const {
  return mails_ != NULL ? *mails_ : *default_instance_->mails_;
}
inline ::pb::GS2C_Mail_MailList* PlayerAllData::mutable_mails() {
  set_has_mails();
  if (mails_ == NULL) mails_ = new ::pb::GS2C_Mail_MailList;
  return mails_;
}
inline ::pb::GS2C_Mail_MailList* PlayerAllData::release_mails() {
  clear_has_mails();
  ::pb::GS2C_Mail_MailList* temp = mails_;
  mails_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_mails(::pb::GS2C_Mail_MailList* mails) {
  delete mails_;
  mails_ = mails;
  if (mails) {
    set_has_mails();
  } else {
    clear_has_mails();
  }
}

// optional .pb.GS2C_QuestList quest_log = 5;
inline bool PlayerAllData::has_quest_log() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerAllData::set_has_quest_log() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerAllData::clear_has_quest_log() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerAllData::clear_quest_log() {
  if (quest_log_ != NULL) quest_log_->::pb::GS2C_QuestList::Clear();
  clear_has_quest_log();
}
inline const ::pb::GS2C_QuestList& PlayerAllData::quest_log() const {
  return quest_log_ != NULL ? *quest_log_ : *default_instance_->quest_log_;
}
inline ::pb::GS2C_QuestList* PlayerAllData::mutable_quest_log() {
  set_has_quest_log();
  if (quest_log_ == NULL) quest_log_ = new ::pb::GS2C_QuestList;
  return quest_log_;
}
inline ::pb::GS2C_QuestList* PlayerAllData::release_quest_log() {
  clear_has_quest_log();
  ::pb::GS2C_QuestList* temp = quest_log_;
  quest_log_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_quest_log(::pb::GS2C_QuestList* quest_log) {
  delete quest_log_;
  quest_log_ = quest_log;
  if (quest_log) {
    set_has_quest_log();
  } else {
    clear_has_quest_log();
  }
}

// optional .pb.GxDB_BehaviorList behavior_count = 6;
inline bool PlayerAllData::has_behavior_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerAllData::set_has_behavior_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerAllData::clear_has_behavior_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerAllData::clear_behavior_count() {
  if (behavior_count_ != NULL) behavior_count_->::pb::GxDB_BehaviorList::Clear();
  clear_has_behavior_count();
}
inline const ::pb::GxDB_BehaviorList& PlayerAllData::behavior_count() const {
  return behavior_count_ != NULL ? *behavior_count_ : *default_instance_->behavior_count_;
}
inline ::pb::GxDB_BehaviorList* PlayerAllData::mutable_behavior_count() {
  set_has_behavior_count();
  if (behavior_count_ == NULL) behavior_count_ = new ::pb::GxDB_BehaviorList;
  return behavior_count_;
}
inline ::pb::GxDB_BehaviorList* PlayerAllData::release_behavior_count() {
  clear_has_behavior_count();
  ::pb::GxDB_BehaviorList* temp = behavior_count_;
  behavior_count_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_behavior_count(::pb::GxDB_BehaviorList* behavior_count) {
  delete behavior_count_;
  behavior_count_ = behavior_count;
  if (behavior_count) {
    set_has_behavior_count();
  } else {
    clear_has_behavior_count();
  }
}

// optional .pb.OtherInfo other_info = 7;
inline bool PlayerAllData::has_other_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerAllData::set_has_other_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerAllData::clear_has_other_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerAllData::clear_other_info() {
  if (other_info_ != NULL) other_info_->::pb::OtherInfo::Clear();
  clear_has_other_info();
}
inline const ::pb::OtherInfo& PlayerAllData::other_info() const {
  return other_info_ != NULL ? *other_info_ : *default_instance_->other_info_;
}
inline ::pb::OtherInfo* PlayerAllData::mutable_other_info() {
  set_has_other_info();
  if (other_info_ == NULL) other_info_ = new ::pb::OtherInfo;
  return other_info_;
}
inline ::pb::OtherInfo* PlayerAllData::release_other_info() {
  clear_has_other_info();
  ::pb::OtherInfo* temp = other_info_;
  other_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_other_info(::pb::OtherInfo* other_info) {
  delete other_info_;
  other_info_ = other_info;
  if (other_info) {
    set_has_other_info();
  } else {
    clear_has_other_info();
  }
}

// optional .pb.GS2C_PlayerStringGroup string_data = 8;
inline bool PlayerAllData::has_string_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerAllData::set_has_string_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerAllData::clear_has_string_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerAllData::clear_string_data() {
  if (string_data_ != NULL) string_data_->::pb::GS2C_PlayerStringGroup::Clear();
  clear_has_string_data();
}
inline const ::pb::GS2C_PlayerStringGroup& PlayerAllData::string_data() const {
  return string_data_ != NULL ? *string_data_ : *default_instance_->string_data_;
}
inline ::pb::GS2C_PlayerStringGroup* PlayerAllData::mutable_string_data() {
  set_has_string_data();
  if (string_data_ == NULL) string_data_ = new ::pb::GS2C_PlayerStringGroup;
  return string_data_;
}
inline ::pb::GS2C_PlayerStringGroup* PlayerAllData::release_string_data() {
  clear_has_string_data();
  ::pb::GS2C_PlayerStringGroup* temp = string_data_;
  string_data_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_string_data(::pb::GS2C_PlayerStringGroup* string_data) {
  delete string_data_;
  string_data_ = string_data;
  if (string_data) {
    set_has_string_data();
  } else {
    clear_has_string_data();
  }
}

// optional .pb.GS2C_Fuben_All_Info fuben_info = 9;
inline bool PlayerAllData::has_fuben_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerAllData::set_has_fuben_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerAllData::clear_has_fuben_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerAllData::clear_fuben_info() {
  if (fuben_info_ != NULL) fuben_info_->::pb::GS2C_Fuben_All_Info::Clear();
  clear_has_fuben_info();
}
inline const ::pb::GS2C_Fuben_All_Info& PlayerAllData::fuben_info() const {
  return fuben_info_ != NULL ? *fuben_info_ : *default_instance_->fuben_info_;
}
inline ::pb::GS2C_Fuben_All_Info* PlayerAllData::mutable_fuben_info() {
  set_has_fuben_info();
  if (fuben_info_ == NULL) fuben_info_ = new ::pb::GS2C_Fuben_All_Info;
  return fuben_info_;
}
inline ::pb::GS2C_Fuben_All_Info* PlayerAllData::release_fuben_info() {
  clear_has_fuben_info();
  ::pb::GS2C_Fuben_All_Info* temp = fuben_info_;
  fuben_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_fuben_info(::pb::GS2C_Fuben_All_Info* fuben_info) {
  delete fuben_info_;
  fuben_info_ = fuben_info;
  if (fuben_info) {
    set_has_fuben_info();
  } else {
    clear_has_fuben_info();
  }
}

// optional .pb.GS2C_MapLogic_Init world_map_logic = 10;
inline bool PlayerAllData::has_world_map_logic() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerAllData::set_has_world_map_logic() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerAllData::clear_has_world_map_logic() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerAllData::clear_world_map_logic() {
  if (world_map_logic_ != NULL) world_map_logic_->::pb::GS2C_MapLogic_Init::Clear();
  clear_has_world_map_logic();
}
inline const ::pb::GS2C_MapLogic_Init& PlayerAllData::world_map_logic() const {
  return world_map_logic_ != NULL ? *world_map_logic_ : *default_instance_->world_map_logic_;
}
inline ::pb::GS2C_MapLogic_Init* PlayerAllData::mutable_world_map_logic() {
  set_has_world_map_logic();
  if (world_map_logic_ == NULL) world_map_logic_ = new ::pb::GS2C_MapLogic_Init;
  return world_map_logic_;
}
inline ::pb::GS2C_MapLogic_Init* PlayerAllData::release_world_map_logic() {
  clear_has_world_map_logic();
  ::pb::GS2C_MapLogic_Init* temp = world_map_logic_;
  world_map_logic_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_world_map_logic(::pb::GS2C_MapLogic_Init* world_map_logic) {
  delete world_map_logic_;
  world_map_logic_ = world_map_logic;
  if (world_map_logic) {
    set_has_world_map_logic();
  } else {
    clear_has_world_map_logic();
  }
}

// optional .pb.GS2C_Market_All_Info market_info = 11;
inline bool PlayerAllData::has_market_info() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlayerAllData::set_has_market_info() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlayerAllData::clear_has_market_info() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlayerAllData::clear_market_info() {
  if (market_info_ != NULL) market_info_->::pb::GS2C_Market_All_Info::Clear();
  clear_has_market_info();
}
inline const ::pb::GS2C_Market_All_Info& PlayerAllData::market_info() const {
  return market_info_ != NULL ? *market_info_ : *default_instance_->market_info_;
}
inline ::pb::GS2C_Market_All_Info* PlayerAllData::mutable_market_info() {
  set_has_market_info();
  if (market_info_ == NULL) market_info_ = new ::pb::GS2C_Market_All_Info;
  return market_info_;
}
inline ::pb::GS2C_Market_All_Info* PlayerAllData::release_market_info() {
  clear_has_market_info();
  ::pb::GS2C_Market_All_Info* temp = market_info_;
  market_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_market_info(::pb::GS2C_Market_All_Info* market_info) {
  delete market_info_;
  market_info_ = market_info;
  if (market_info) {
    set_has_market_info();
  } else {
    clear_has_market_info();
  }
}

// optional .pb.GS2C_Altar_All_Info altar_info = 12;
inline bool PlayerAllData::has_altar_info() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PlayerAllData::set_has_altar_info() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PlayerAllData::clear_has_altar_info() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PlayerAllData::clear_altar_info() {
  if (altar_info_ != NULL) altar_info_->::pb::GS2C_Altar_All_Info::Clear();
  clear_has_altar_info();
}
inline const ::pb::GS2C_Altar_All_Info& PlayerAllData::altar_info() const {
  return altar_info_ != NULL ? *altar_info_ : *default_instance_->altar_info_;
}
inline ::pb::GS2C_Altar_All_Info* PlayerAllData::mutable_altar_info() {
  set_has_altar_info();
  if (altar_info_ == NULL) altar_info_ = new ::pb::GS2C_Altar_All_Info;
  return altar_info_;
}
inline ::pb::GS2C_Altar_All_Info* PlayerAllData::release_altar_info() {
  clear_has_altar_info();
  ::pb::GS2C_Altar_All_Info* temp = altar_info_;
  altar_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_altar_info(::pb::GS2C_Altar_All_Info* altar_info) {
  delete altar_info_;
  altar_info_ = altar_info;
  if (altar_info) {
    set_has_altar_info();
  } else {
    clear_has_altar_info();
  }
}

// optional .pb.GS2C_Dungeon_All_Info dungeon_info = 13;
inline bool PlayerAllData::has_dungeon_info() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PlayerAllData::set_has_dungeon_info() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PlayerAllData::clear_has_dungeon_info() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PlayerAllData::clear_dungeon_info() {
  if (dungeon_info_ != NULL) dungeon_info_->::pb::GS2C_Dungeon_All_Info::Clear();
  clear_has_dungeon_info();
}
inline const ::pb::GS2C_Dungeon_All_Info& PlayerAllData::dungeon_info() const {
  return dungeon_info_ != NULL ? *dungeon_info_ : *default_instance_->dungeon_info_;
}
inline ::pb::GS2C_Dungeon_All_Info* PlayerAllData::mutable_dungeon_info() {
  set_has_dungeon_info();
  if (dungeon_info_ == NULL) dungeon_info_ = new ::pb::GS2C_Dungeon_All_Info;
  return dungeon_info_;
}
inline ::pb::GS2C_Dungeon_All_Info* PlayerAllData::release_dungeon_info() {
  clear_has_dungeon_info();
  ::pb::GS2C_Dungeon_All_Info* temp = dungeon_info_;
  dungeon_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_dungeon_info(::pb::GS2C_Dungeon_All_Info* dungeon_info) {
  delete dungeon_info_;
  dungeon_info_ = dungeon_info;
  if (dungeon_info) {
    set_has_dungeon_info();
  } else {
    clear_has_dungeon_info();
  }
}

// optional .pb.GS2C_BaoQi_All_Info bao_qi_info = 14;
inline bool PlayerAllData::has_bao_qi_info() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PlayerAllData::set_has_bao_qi_info() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PlayerAllData::clear_has_bao_qi_info() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PlayerAllData::clear_bao_qi_info() {
  if (bao_qi_info_ != NULL) bao_qi_info_->::pb::GS2C_BaoQi_All_Info::Clear();
  clear_has_bao_qi_info();
}
inline const ::pb::GS2C_BaoQi_All_Info& PlayerAllData::bao_qi_info() const {
  return bao_qi_info_ != NULL ? *bao_qi_info_ : *default_instance_->bao_qi_info_;
}
inline ::pb::GS2C_BaoQi_All_Info* PlayerAllData::mutable_bao_qi_info() {
  set_has_bao_qi_info();
  if (bao_qi_info_ == NULL) bao_qi_info_ = new ::pb::GS2C_BaoQi_All_Info;
  return bao_qi_info_;
}
inline ::pb::GS2C_BaoQi_All_Info* PlayerAllData::release_bao_qi_info() {
  clear_has_bao_qi_info();
  ::pb::GS2C_BaoQi_All_Info* temp = bao_qi_info_;
  bao_qi_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_bao_qi_info(::pb::GS2C_BaoQi_All_Info* bao_qi_info) {
  delete bao_qi_info_;
  bao_qi_info_ = bao_qi_info;
  if (bao_qi_info) {
    set_has_bao_qi_info();
  } else {
    clear_has_bao_qi_info();
  }
}

// optional .pb.GS2C_Smithy_All_Info smithy_info = 15;
inline bool PlayerAllData::has_smithy_info() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PlayerAllData::set_has_smithy_info() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PlayerAllData::clear_has_smithy_info() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PlayerAllData::clear_smithy_info() {
  if (smithy_info_ != NULL) smithy_info_->::pb::GS2C_Smithy_All_Info::Clear();
  clear_has_smithy_info();
}
inline const ::pb::GS2C_Smithy_All_Info& PlayerAllData::smithy_info() const {
  return smithy_info_ != NULL ? *smithy_info_ : *default_instance_->smithy_info_;
}
inline ::pb::GS2C_Smithy_All_Info* PlayerAllData::mutable_smithy_info() {
  set_has_smithy_info();
  if (smithy_info_ == NULL) smithy_info_ = new ::pb::GS2C_Smithy_All_Info;
  return smithy_info_;
}
inline ::pb::GS2C_Smithy_All_Info* PlayerAllData::release_smithy_info() {
  clear_has_smithy_info();
  ::pb::GS2C_Smithy_All_Info* temp = smithy_info_;
  smithy_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_smithy_info(::pb::GS2C_Smithy_All_Info* smithy_info) {
  delete smithy_info_;
  smithy_info_ = smithy_info;
  if (smithy_info) {
    set_has_smithy_info();
  } else {
    clear_has_smithy_info();
  }
}

// optional .pb.GS2C_Buff_All_Info buff_info = 16;
inline bool PlayerAllData::has_buff_info() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PlayerAllData::set_has_buff_info() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PlayerAllData::clear_has_buff_info() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PlayerAllData::clear_buff_info() {
  if (buff_info_ != NULL) buff_info_->::pb::GS2C_Buff_All_Info::Clear();
  clear_has_buff_info();
}
inline const ::pb::GS2C_Buff_All_Info& PlayerAllData::buff_info() const {
  return buff_info_ != NULL ? *buff_info_ : *default_instance_->buff_info_;
}
inline ::pb::GS2C_Buff_All_Info* PlayerAllData::mutable_buff_info() {
  set_has_buff_info();
  if (buff_info_ == NULL) buff_info_ = new ::pb::GS2C_Buff_All_Info;
  return buff_info_;
}
inline ::pb::GS2C_Buff_All_Info* PlayerAllData::release_buff_info() {
  clear_has_buff_info();
  ::pb::GS2C_Buff_All_Info* temp = buff_info_;
  buff_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_buff_info(::pb::GS2C_Buff_All_Info* buff_info) {
  delete buff_info_;
  buff_info_ = buff_info;
  if (buff_info) {
    set_has_buff_info();
  } else {
    clear_has_buff_info();
  }
}

// optional .pb.GxDB_Technology_All_Info technology_info = 17;
inline bool PlayerAllData::has_technology_info() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PlayerAllData::set_has_technology_info() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PlayerAllData::clear_has_technology_info() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PlayerAllData::clear_technology_info() {
  if (technology_info_ != NULL) technology_info_->::pb::GxDB_Technology_All_Info::Clear();
  clear_has_technology_info();
}
inline const ::pb::GxDB_Technology_All_Info& PlayerAllData::technology_info() const {
  return technology_info_ != NULL ? *technology_info_ : *default_instance_->technology_info_;
}
inline ::pb::GxDB_Technology_All_Info* PlayerAllData::mutable_technology_info() {
  set_has_technology_info();
  if (technology_info_ == NULL) technology_info_ = new ::pb::GxDB_Technology_All_Info;
  return technology_info_;
}
inline ::pb::GxDB_Technology_All_Info* PlayerAllData::release_technology_info() {
  clear_has_technology_info();
  ::pb::GxDB_Technology_All_Info* temp = technology_info_;
  technology_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_technology_info(::pb::GxDB_Technology_All_Info* technology_info) {
  delete technology_info_;
  technology_info_ = technology_info;
  if (technology_info) {
    set_has_technology_info();
  } else {
    clear_has_technology_info();
  }
}

// optional .pb.GxDB_Daily_Quest dailyquest_info = 18;
inline bool PlayerAllData::has_dailyquest_info() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PlayerAllData::set_has_dailyquest_info() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PlayerAllData::clear_has_dailyquest_info() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PlayerAllData::clear_dailyquest_info() {
  if (dailyquest_info_ != NULL) dailyquest_info_->::pb::GxDB_Daily_Quest::Clear();
  clear_has_dailyquest_info();
}
inline const ::pb::GxDB_Daily_Quest& PlayerAllData::dailyquest_info() const {
  return dailyquest_info_ != NULL ? *dailyquest_info_ : *default_instance_->dailyquest_info_;
}
inline ::pb::GxDB_Daily_Quest* PlayerAllData::mutable_dailyquest_info() {
  set_has_dailyquest_info();
  if (dailyquest_info_ == NULL) dailyquest_info_ = new ::pb::GxDB_Daily_Quest;
  return dailyquest_info_;
}
inline ::pb::GxDB_Daily_Quest* PlayerAllData::release_dailyquest_info() {
  clear_has_dailyquest_info();
  ::pb::GxDB_Daily_Quest* temp = dailyquest_info_;
  dailyquest_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_dailyquest_info(::pb::GxDB_Daily_Quest* dailyquest_info) {
  delete dailyquest_info_;
  dailyquest_info_ = dailyquest_info;
  if (dailyquest_info) {
    set_has_dailyquest_info();
  } else {
    clear_has_dailyquest_info();
  }
}

// optional .pb.GxDB_Grow_Up_Quest growupquest_info = 19;
inline bool PlayerAllData::has_growupquest_info() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PlayerAllData::set_has_growupquest_info() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PlayerAllData::clear_has_growupquest_info() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PlayerAllData::clear_growupquest_info() {
  if (growupquest_info_ != NULL) growupquest_info_->::pb::GxDB_Grow_Up_Quest::Clear();
  clear_has_growupquest_info();
}
inline const ::pb::GxDB_Grow_Up_Quest& PlayerAllData::growupquest_info() const {
  return growupquest_info_ != NULL ? *growupquest_info_ : *default_instance_->growupquest_info_;
}
inline ::pb::GxDB_Grow_Up_Quest* PlayerAllData::mutable_growupquest_info() {
  set_has_growupquest_info();
  if (growupquest_info_ == NULL) growupquest_info_ = new ::pb::GxDB_Grow_Up_Quest;
  return growupquest_info_;
}
inline ::pb::GxDB_Grow_Up_Quest* PlayerAllData::release_growupquest_info() {
  clear_has_growupquest_info();
  ::pb::GxDB_Grow_Up_Quest* temp = growupquest_info_;
  growupquest_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_growupquest_info(::pb::GxDB_Grow_Up_Quest* growupquest_info) {
  delete growupquest_info_;
  growupquest_info_ = growupquest_info;
  if (growupquest_info) {
    set_has_growupquest_info();
  } else {
    clear_has_growupquest_info();
  }
}

// optional .pb.GxDB_Grow_Up_Quest_Group growupquestgroup_info = 20;
inline bool PlayerAllData::has_growupquestgroup_info() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PlayerAllData::set_has_growupquestgroup_info() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PlayerAllData::clear_has_growupquestgroup_info() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PlayerAllData::clear_growupquestgroup_info() {
  if (growupquestgroup_info_ != NULL) growupquestgroup_info_->::pb::GxDB_Grow_Up_Quest_Group::Clear();
  clear_has_growupquestgroup_info();
}
inline const ::pb::GxDB_Grow_Up_Quest_Group& PlayerAllData::growupquestgroup_info() const {
  return growupquestgroup_info_ != NULL ? *growupquestgroup_info_ : *default_instance_->growupquestgroup_info_;
}
inline ::pb::GxDB_Grow_Up_Quest_Group* PlayerAllData::mutable_growupquestgroup_info() {
  set_has_growupquestgroup_info();
  if (growupquestgroup_info_ == NULL) growupquestgroup_info_ = new ::pb::GxDB_Grow_Up_Quest_Group;
  return growupquestgroup_info_;
}
inline ::pb::GxDB_Grow_Up_Quest_Group* PlayerAllData::release_growupquestgroup_info() {
  clear_has_growupquestgroup_info();
  ::pb::GxDB_Grow_Up_Quest_Group* temp = growupquestgroup_info_;
  growupquestgroup_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_growupquestgroup_info(::pb::GxDB_Grow_Up_Quest_Group* growupquestgroup_info) {
  delete growupquestgroup_info_;
  growupquestgroup_info_ = growupquestgroup_info;
  if (growupquestgroup_info) {
    set_has_growupquestgroup_info();
  } else {
    clear_has_growupquestgroup_info();
  }
}

// optional .pb.GxDB_Sign_Up sign_up_info = 21;
inline bool PlayerAllData::has_sign_up_info() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PlayerAllData::set_has_sign_up_info() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PlayerAllData::clear_has_sign_up_info() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PlayerAllData::clear_sign_up_info() {
  if (sign_up_info_ != NULL) sign_up_info_->::pb::GxDB_Sign_Up::Clear();
  clear_has_sign_up_info();
}
inline const ::pb::GxDB_Sign_Up& PlayerAllData::sign_up_info() const {
  return sign_up_info_ != NULL ? *sign_up_info_ : *default_instance_->sign_up_info_;
}
inline ::pb::GxDB_Sign_Up* PlayerAllData::mutable_sign_up_info() {
  set_has_sign_up_info();
  if (sign_up_info_ == NULL) sign_up_info_ = new ::pb::GxDB_Sign_Up;
  return sign_up_info_;
}
inline ::pb::GxDB_Sign_Up* PlayerAllData::release_sign_up_info() {
  clear_has_sign_up_info();
  ::pb::GxDB_Sign_Up* temp = sign_up_info_;
  sign_up_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_sign_up_info(::pb::GxDB_Sign_Up* sign_up_info) {
  delete sign_up_info_;
  sign_up_info_ = sign_up_info;
  if (sign_up_info) {
    set_has_sign_up_info();
  } else {
    clear_has_sign_up_info();
  }
}

// optional .pb.GxDB_Pass_Stage_Reward pass_stage_reward_info = 22;
inline bool PlayerAllData::has_pass_stage_reward_info() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PlayerAllData::set_has_pass_stage_reward_info() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PlayerAllData::clear_has_pass_stage_reward_info() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PlayerAllData::clear_pass_stage_reward_info() {
  if (pass_stage_reward_info_ != NULL) pass_stage_reward_info_->::pb::GxDB_Pass_Stage_Reward::Clear();
  clear_has_pass_stage_reward_info();
}
inline const ::pb::GxDB_Pass_Stage_Reward& PlayerAllData::pass_stage_reward_info() const {
  return pass_stage_reward_info_ != NULL ? *pass_stage_reward_info_ : *default_instance_->pass_stage_reward_info_;
}
inline ::pb::GxDB_Pass_Stage_Reward* PlayerAllData::mutable_pass_stage_reward_info() {
  set_has_pass_stage_reward_info();
  if (pass_stage_reward_info_ == NULL) pass_stage_reward_info_ = new ::pb::GxDB_Pass_Stage_Reward;
  return pass_stage_reward_info_;
}
inline ::pb::GxDB_Pass_Stage_Reward* PlayerAllData::release_pass_stage_reward_info() {
  clear_has_pass_stage_reward_info();
  ::pb::GxDB_Pass_Stage_Reward* temp = pass_stage_reward_info_;
  pass_stage_reward_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_pass_stage_reward_info(::pb::GxDB_Pass_Stage_Reward* pass_stage_reward_info) {
  delete pass_stage_reward_info_;
  pass_stage_reward_info_ = pass_stage_reward_info;
  if (pass_stage_reward_info) {
    set_has_pass_stage_reward_info();
  } else {
    clear_has_pass_stage_reward_info();
  }
}

// optional .pb.GxDB_ActivityStarBox activity_star_box_info = 23;
inline bool PlayerAllData::has_activity_star_box_info() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PlayerAllData::set_has_activity_star_box_info() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PlayerAllData::clear_has_activity_star_box_info() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PlayerAllData::clear_activity_star_box_info() {
  if (activity_star_box_info_ != NULL) activity_star_box_info_->::pb::GxDB_ActivityStarBox::Clear();
  clear_has_activity_star_box_info();
}
inline const ::pb::GxDB_ActivityStarBox& PlayerAllData::activity_star_box_info() const {
  return activity_star_box_info_ != NULL ? *activity_star_box_info_ : *default_instance_->activity_star_box_info_;
}
inline ::pb::GxDB_ActivityStarBox* PlayerAllData::mutable_activity_star_box_info() {
  set_has_activity_star_box_info();
  if (activity_star_box_info_ == NULL) activity_star_box_info_ = new ::pb::GxDB_ActivityStarBox;
  return activity_star_box_info_;
}
inline ::pb::GxDB_ActivityStarBox* PlayerAllData::release_activity_star_box_info() {
  clear_has_activity_star_box_info();
  ::pb::GxDB_ActivityStarBox* temp = activity_star_box_info_;
  activity_star_box_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_activity_star_box_info(::pb::GxDB_ActivityStarBox* activity_star_box_info) {
  delete activity_star_box_info_;
  activity_star_box_info_ = activity_star_box_info;
  if (activity_star_box_info) {
    set_has_activity_star_box_info();
  } else {
    clear_has_activity_star_box_info();
  }
}

// optional .pb.GxDB_PalaceAchievement achievement_info = 24;
inline bool PlayerAllData::has_achievement_info() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PlayerAllData::set_has_achievement_info() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PlayerAllData::clear_has_achievement_info() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PlayerAllData::clear_achievement_info() {
  if (achievement_info_ != NULL) achievement_info_->::pb::GxDB_PalaceAchievement::Clear();
  clear_has_achievement_info();
}
inline const ::pb::GxDB_PalaceAchievement& PlayerAllData::achievement_info() const {
  return achievement_info_ != NULL ? *achievement_info_ : *default_instance_->achievement_info_;
}
inline ::pb::GxDB_PalaceAchievement* PlayerAllData::mutable_achievement_info() {
  set_has_achievement_info();
  if (achievement_info_ == NULL) achievement_info_ = new ::pb::GxDB_PalaceAchievement;
  return achievement_info_;
}
inline ::pb::GxDB_PalaceAchievement* PlayerAllData::release_achievement_info() {
  clear_has_achievement_info();
  ::pb::GxDB_PalaceAchievement* temp = achievement_info_;
  achievement_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_achievement_info(::pb::GxDB_PalaceAchievement* achievement_info) {
  delete achievement_info_;
  achievement_info_ = achievement_info;
  if (achievement_info) {
    set_has_achievement_info();
  } else {
    clear_has_achievement_info();
  }
}

// optional .pb.GxDB_GovAffairsInfo gov_affairs_info = 25;
inline bool PlayerAllData::has_gov_affairs_info() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PlayerAllData::set_has_gov_affairs_info() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PlayerAllData::clear_has_gov_affairs_info() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PlayerAllData::clear_gov_affairs_info() {
  if (gov_affairs_info_ != NULL) gov_affairs_info_->::pb::GxDB_GovAffairsInfo::Clear();
  clear_has_gov_affairs_info();
}
inline const ::pb::GxDB_GovAffairsInfo& PlayerAllData::gov_affairs_info() const {
  return gov_affairs_info_ != NULL ? *gov_affairs_info_ : *default_instance_->gov_affairs_info_;
}
inline ::pb::GxDB_GovAffairsInfo* PlayerAllData::mutable_gov_affairs_info() {
  set_has_gov_affairs_info();
  if (gov_affairs_info_ == NULL) gov_affairs_info_ = new ::pb::GxDB_GovAffairsInfo;
  return gov_affairs_info_;
}
inline ::pb::GxDB_GovAffairsInfo* PlayerAllData::release_gov_affairs_info() {
  clear_has_gov_affairs_info();
  ::pb::GxDB_GovAffairsInfo* temp = gov_affairs_info_;
  gov_affairs_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_gov_affairs_info(::pb::GxDB_GovAffairsInfo* gov_affairs_info) {
  delete gov_affairs_info_;
  gov_affairs_info_ = gov_affairs_info;
  if (gov_affairs_info) {
    set_has_gov_affairs_info();
  } else {
    clear_has_gov_affairs_info();
  }
}

// optional .pb.GxDB_Hero_Reward hero_reward = 26;
inline bool PlayerAllData::has_hero_reward() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PlayerAllData::set_has_hero_reward() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PlayerAllData::clear_has_hero_reward() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PlayerAllData::clear_hero_reward() {
  if (hero_reward_ != NULL) hero_reward_->::pb::GxDB_Hero_Reward::Clear();
  clear_has_hero_reward();
}
inline const ::pb::GxDB_Hero_Reward& PlayerAllData::hero_reward() const {
  return hero_reward_ != NULL ? *hero_reward_ : *default_instance_->hero_reward_;
}
inline ::pb::GxDB_Hero_Reward* PlayerAllData::mutable_hero_reward() {
  set_has_hero_reward();
  if (hero_reward_ == NULL) hero_reward_ = new ::pb::GxDB_Hero_Reward;
  return hero_reward_;
}
inline ::pb::GxDB_Hero_Reward* PlayerAllData::release_hero_reward() {
  clear_has_hero_reward();
  ::pb::GxDB_Hero_Reward* temp = hero_reward_;
  hero_reward_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_hero_reward(::pb::GxDB_Hero_Reward* hero_reward) {
  delete hero_reward_;
  hero_reward_ = hero_reward;
  if (hero_reward) {
    set_has_hero_reward();
  } else {
    clear_has_hero_reward();
  }
}

// optional .pb.GxDB_World_Achievement world_fight_achieve_info = 27;
inline bool PlayerAllData::has_world_fight_achieve_info() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PlayerAllData::set_has_world_fight_achieve_info() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PlayerAllData::clear_has_world_fight_achieve_info() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PlayerAllData::clear_world_fight_achieve_info() {
  if (world_fight_achieve_info_ != NULL) world_fight_achieve_info_->::pb::GxDB_World_Achievement::Clear();
  clear_has_world_fight_achieve_info();
}
inline const ::pb::GxDB_World_Achievement& PlayerAllData::world_fight_achieve_info() const {
  return world_fight_achieve_info_ != NULL ? *world_fight_achieve_info_ : *default_instance_->world_fight_achieve_info_;
}
inline ::pb::GxDB_World_Achievement* PlayerAllData::mutable_world_fight_achieve_info() {
  set_has_world_fight_achieve_info();
  if (world_fight_achieve_info_ == NULL) world_fight_achieve_info_ = new ::pb::GxDB_World_Achievement;
  return world_fight_achieve_info_;
}
inline ::pb::GxDB_World_Achievement* PlayerAllData::release_world_fight_achieve_info() {
  clear_has_world_fight_achieve_info();
  ::pb::GxDB_World_Achievement* temp = world_fight_achieve_info_;
  world_fight_achieve_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_world_fight_achieve_info(::pb::GxDB_World_Achievement* world_fight_achieve_info) {
  delete world_fight_achieve_info_;
  world_fight_achieve_info_ = world_fight_achieve_info;
  if (world_fight_achieve_info) {
    set_has_world_fight_achieve_info();
  } else {
    clear_has_world_fight_achieve_info();
  }
}

// optional .pb.GxDB_Seige_Force_Info_Pack seige_force_info = 28;
inline bool PlayerAllData::has_seige_force_info() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PlayerAllData::set_has_seige_force_info() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PlayerAllData::clear_has_seige_force_info() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PlayerAllData::clear_seige_force_info() {
  if (seige_force_info_ != NULL) seige_force_info_->::pb::GxDB_Seige_Force_Info_Pack::Clear();
  clear_has_seige_force_info();
}
inline const ::pb::GxDB_Seige_Force_Info_Pack& PlayerAllData::seige_force_info() const {
  return seige_force_info_ != NULL ? *seige_force_info_ : *default_instance_->seige_force_info_;
}
inline ::pb::GxDB_Seige_Force_Info_Pack* PlayerAllData::mutable_seige_force_info() {
  set_has_seige_force_info();
  if (seige_force_info_ == NULL) seige_force_info_ = new ::pb::GxDB_Seige_Force_Info_Pack;
  return seige_force_info_;
}
inline ::pb::GxDB_Seige_Force_Info_Pack* PlayerAllData::release_seige_force_info() {
  clear_has_seige_force_info();
  ::pb::GxDB_Seige_Force_Info_Pack* temp = seige_force_info_;
  seige_force_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_seige_force_info(::pb::GxDB_Seige_Force_Info_Pack* seige_force_info) {
  delete seige_force_info_;
  seige_force_info_ = seige_force_info;
  if (seige_force_info) {
    set_has_seige_force_info();
  } else {
    clear_has_seige_force_info();
  }
}

// optional .pb.GxDB_ContinueOccupyCityInfo continue_info = 29;
inline bool PlayerAllData::has_continue_info() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PlayerAllData::set_has_continue_info() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PlayerAllData::clear_has_continue_info() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PlayerAllData::clear_continue_info() {
  if (continue_info_ != NULL) continue_info_->::pb::GxDB_ContinueOccupyCityInfo::Clear();
  clear_has_continue_info();
}
inline const ::pb::GxDB_ContinueOccupyCityInfo& PlayerAllData::continue_info() const {
  return continue_info_ != NULL ? *continue_info_ : *default_instance_->continue_info_;
}
inline ::pb::GxDB_ContinueOccupyCityInfo* PlayerAllData::mutable_continue_info() {
  set_has_continue_info();
  if (continue_info_ == NULL) continue_info_ = new ::pb::GxDB_ContinueOccupyCityInfo;
  return continue_info_;
}
inline ::pb::GxDB_ContinueOccupyCityInfo* PlayerAllData::release_continue_info() {
  clear_has_continue_info();
  ::pb::GxDB_ContinueOccupyCityInfo* temp = continue_info_;
  continue_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_continue_info(::pb::GxDB_ContinueOccupyCityInfo* continue_info) {
  delete continue_info_;
  continue_info_ = continue_info;
  if (continue_info) {
    set_has_continue_info();
  } else {
    clear_has_continue_info();
  }
}

// optional .pb.GS2C_Get_Teach_Rec teach_rec = 30;
inline bool PlayerAllData::has_teach_rec() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PlayerAllData::set_has_teach_rec() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PlayerAllData::clear_has_teach_rec() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PlayerAllData::clear_teach_rec() {
  if (teach_rec_ != NULL) teach_rec_->::pb::GS2C_Get_Teach_Rec::Clear();
  clear_has_teach_rec();
}
inline const ::pb::GS2C_Get_Teach_Rec& PlayerAllData::teach_rec() const {
  return teach_rec_ != NULL ? *teach_rec_ : *default_instance_->teach_rec_;
}
inline ::pb::GS2C_Get_Teach_Rec* PlayerAllData::mutable_teach_rec() {
  set_has_teach_rec();
  if (teach_rec_ == NULL) teach_rec_ = new ::pb::GS2C_Get_Teach_Rec;
  return teach_rec_;
}
inline ::pb::GS2C_Get_Teach_Rec* PlayerAllData::release_teach_rec() {
  clear_has_teach_rec();
  ::pb::GS2C_Get_Teach_Rec* temp = teach_rec_;
  teach_rec_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_teach_rec(::pb::GS2C_Get_Teach_Rec* teach_rec) {
  delete teach_rec_;
  teach_rec_ = teach_rec;
  if (teach_rec) {
    set_has_teach_rec();
  } else {
    clear_has_teach_rec();
  }
}

// optional .pb.GxDB_CongratulateRewardLog congratulate_info = 31;
inline bool PlayerAllData::has_congratulate_info() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PlayerAllData::set_has_congratulate_info() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PlayerAllData::clear_has_congratulate_info() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PlayerAllData::clear_congratulate_info() {
  if (congratulate_info_ != NULL) congratulate_info_->::pb::GxDB_CongratulateRewardLog::Clear();
  clear_has_congratulate_info();
}
inline const ::pb::GxDB_CongratulateRewardLog& PlayerAllData::congratulate_info() const {
  return congratulate_info_ != NULL ? *congratulate_info_ : *default_instance_->congratulate_info_;
}
inline ::pb::GxDB_CongratulateRewardLog* PlayerAllData::mutable_congratulate_info() {
  set_has_congratulate_info();
  if (congratulate_info_ == NULL) congratulate_info_ = new ::pb::GxDB_CongratulateRewardLog;
  return congratulate_info_;
}
inline ::pb::GxDB_CongratulateRewardLog* PlayerAllData::release_congratulate_info() {
  clear_has_congratulate_info();
  ::pb::GxDB_CongratulateRewardLog* temp = congratulate_info_;
  congratulate_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_congratulate_info(::pb::GxDB_CongratulateRewardLog* congratulate_info) {
  delete congratulate_info_;
  congratulate_info_ = congratulate_info;
  if (congratulate_info) {
    set_has_congratulate_info();
  } else {
    clear_has_congratulate_info();
  }
}

// optional .pb.GxDB_CongratulateBeenCongratualted con_been_congratulated = 32;
inline bool PlayerAllData::has_con_been_congratulated() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PlayerAllData::set_has_con_been_congratulated() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PlayerAllData::clear_has_con_been_congratulated() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PlayerAllData::clear_con_been_congratulated() {
  if (con_been_congratulated_ != NULL) con_been_congratulated_->::pb::GxDB_CongratulateBeenCongratualted::Clear();
  clear_has_con_been_congratulated();
}
inline const ::pb::GxDB_CongratulateBeenCongratualted& PlayerAllData::con_been_congratulated() const {
  return con_been_congratulated_ != NULL ? *con_been_congratulated_ : *default_instance_->con_been_congratulated_;
}
inline ::pb::GxDB_CongratulateBeenCongratualted* PlayerAllData::mutable_con_been_congratulated() {
  set_has_con_been_congratulated();
  if (con_been_congratulated_ == NULL) con_been_congratulated_ = new ::pb::GxDB_CongratulateBeenCongratualted;
  return con_been_congratulated_;
}
inline ::pb::GxDB_CongratulateBeenCongratualted* PlayerAllData::release_con_been_congratulated() {
  clear_has_con_been_congratulated();
  ::pb::GxDB_CongratulateBeenCongratualted* temp = con_been_congratulated_;
  con_been_congratulated_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_con_been_congratulated(::pb::GxDB_CongratulateBeenCongratualted* con_been_congratulated) {
  delete con_been_congratulated_;
  con_been_congratulated_ = con_been_congratulated;
  if (con_been_congratulated) {
    set_has_con_been_congratulated();
  } else {
    clear_has_con_been_congratulated();
  }
}

// optional .pb.GxDB_WannaBeStrongerInfoAllInfo wanna_be_info = 33;
inline bool PlayerAllData::has_wanna_be_info() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PlayerAllData::set_has_wanna_be_info() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PlayerAllData::clear_has_wanna_be_info() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PlayerAllData::clear_wanna_be_info() {
  if (wanna_be_info_ != NULL) wanna_be_info_->::pb::GxDB_WannaBeStrongerInfoAllInfo::Clear();
  clear_has_wanna_be_info();
}
inline const ::pb::GxDB_WannaBeStrongerInfoAllInfo& PlayerAllData::wanna_be_info() const {
  return wanna_be_info_ != NULL ? *wanna_be_info_ : *default_instance_->wanna_be_info_;
}
inline ::pb::GxDB_WannaBeStrongerInfoAllInfo* PlayerAllData::mutable_wanna_be_info() {
  set_has_wanna_be_info();
  if (wanna_be_info_ == NULL) wanna_be_info_ = new ::pb::GxDB_WannaBeStrongerInfoAllInfo;
  return wanna_be_info_;
}
inline ::pb::GxDB_WannaBeStrongerInfoAllInfo* PlayerAllData::release_wanna_be_info() {
  clear_has_wanna_be_info();
  ::pb::GxDB_WannaBeStrongerInfoAllInfo* temp = wanna_be_info_;
  wanna_be_info_ = NULL;
  return temp;
}
inline void PlayerAllData::set_allocated_wanna_be_info(::pb::GxDB_WannaBeStrongerInfoAllInfo* wanna_be_info) {
  delete wanna_be_info_;
  wanna_be_info_ = wanna_be_info;
  if (wanna_be_info) {
    set_has_wanna_be_info();
  } else {
    clear_has_wanna_be_info();
  }
}

// -------------------------------------------------------------------

// CreatePlayerData

// required uint64 account_id = 1;
inline bool CreatePlayerData::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePlayerData::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePlayerData::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePlayerData::clear_account_id() {
  account_id_ = GOOGLE_ULONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::uint64 CreatePlayerData::account_id() const {
  return account_id_;
}
inline void CreatePlayerData::set_account_id(::google::protobuf::uint64 value) {
  set_has_account_id();
  account_id_ = value;
}

// required .pb.PlayerAllData all_data = 2;
inline bool CreatePlayerData::has_all_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreatePlayerData::set_has_all_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreatePlayerData::clear_has_all_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreatePlayerData::clear_all_data() {
  if (all_data_ != NULL) all_data_->::pb::PlayerAllData::Clear();
  clear_has_all_data();
}
inline const ::pb::PlayerAllData& CreatePlayerData::all_data() const {
  return all_data_ != NULL ? *all_data_ : *default_instance_->all_data_;
}
inline ::pb::PlayerAllData* CreatePlayerData::mutable_all_data() {
  set_has_all_data();
  if (all_data_ == NULL) all_data_ = new ::pb::PlayerAllData;
  return all_data_;
}
inline ::pb::PlayerAllData* CreatePlayerData::release_all_data() {
  clear_has_all_data();
  ::pb::PlayerAllData* temp = all_data_;
  all_data_ = NULL;
  return temp;
}
inline void CreatePlayerData::set_allocated_all_data(::pb::PlayerAllData* all_data) {
  delete all_data_;
  all_data_ = all_data;
  if (all_data) {
    set_has_all_data();
  } else {
    clear_has_all_data();
  }
}

// -------------------------------------------------------------------

// RegistCrossPlayerData

// required .pb.PlayerAllData player_data = 1;
inline bool RegistCrossPlayerData::has_player_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistCrossPlayerData::set_has_player_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistCrossPlayerData::clear_has_player_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistCrossPlayerData::clear_player_data() {
  if (player_data_ != NULL) player_data_->::pb::PlayerAllData::Clear();
  clear_has_player_data();
}
inline const ::pb::PlayerAllData& RegistCrossPlayerData::player_data() const {
  return player_data_ != NULL ? *player_data_ : *default_instance_->player_data_;
}
inline ::pb::PlayerAllData* RegistCrossPlayerData::mutable_player_data() {
  set_has_player_data();
  if (player_data_ == NULL) player_data_ = new ::pb::PlayerAllData;
  return player_data_;
}
inline ::pb::PlayerAllData* RegistCrossPlayerData::release_player_data() {
  clear_has_player_data();
  ::pb::PlayerAllData* temp = player_data_;
  player_data_ = NULL;
  return temp;
}
inline void RegistCrossPlayerData::set_allocated_player_data(::pb::PlayerAllData* player_data) {
  delete player_data_;
  player_data_ = player_data;
  if (player_data) {
    set_has_player_data();
  } else {
    clear_has_player_data();
  }
}

// optional .pb.PlayerAppendData append = 2;
inline bool RegistCrossPlayerData::has_append() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistCrossPlayerData::set_has_append() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistCrossPlayerData::clear_has_append() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistCrossPlayerData::clear_append() {
  if (append_ != NULL) append_->::pb::PlayerAppendData::Clear();
  clear_has_append();
}
inline const ::pb::PlayerAppendData& RegistCrossPlayerData::append() const {
  return append_ != NULL ? *append_ : *default_instance_->append_;
}
inline ::pb::PlayerAppendData* RegistCrossPlayerData::mutable_append() {
  set_has_append();
  if (append_ == NULL) append_ = new ::pb::PlayerAppendData;
  return append_;
}
inline ::pb::PlayerAppendData* RegistCrossPlayerData::release_append() {
  clear_has_append();
  ::pb::PlayerAppendData* temp = append_;
  append_ = NULL;
  return temp;
}
inline void RegistCrossPlayerData::set_allocated_append(::pb::PlayerAppendData* append) {
  delete append_;
  append_ = append;
  if (append) {
    set_has_append();
  } else {
    clear_has_append();
  }
}

// optional uint32 country_id = 3;
inline bool RegistCrossPlayerData::has_country_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegistCrossPlayerData::set_has_country_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegistCrossPlayerData::clear_has_country_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegistCrossPlayerData::clear_country_id() {
  country_id_ = 0u;
  clear_has_country_id();
}
inline ::google::protobuf::uint32 RegistCrossPlayerData::country_id() const {
  return country_id_;
}
inline void RegistCrossPlayerData::set_country_id(::google::protobuf::uint32 value) {
  set_has_country_id();
  country_id_ = value;
}

// optional uint64 account_id = 4;
inline bool RegistCrossPlayerData::has_account_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegistCrossPlayerData::set_has_account_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegistCrossPlayerData::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegistCrossPlayerData::clear_account_id() {
  account_id_ = GOOGLE_ULONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::uint64 RegistCrossPlayerData::account_id() const {
  return account_id_;
}
inline void RegistCrossPlayerData::set_account_id(::google::protobuf::uint64 value) {
  set_has_account_id();
  account_id_ = value;
}

// optional uint32 cross_Unique_id = 5;
inline bool RegistCrossPlayerData::has_cross_unique_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegistCrossPlayerData::set_has_cross_unique_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegistCrossPlayerData::clear_has_cross_unique_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegistCrossPlayerData::clear_cross_unique_id() {
  cross_unique_id_ = 0u;
  clear_has_cross_unique_id();
}
inline ::google::protobuf::uint32 RegistCrossPlayerData::cross_unique_id() const {
  return cross_unique_id_;
}
inline void RegistCrossPlayerData::set_cross_unique_id(::google::protobuf::uint32 value) {
  set_has_cross_unique_id();
  cross_unique_id_ = value;
}

// -------------------------------------------------------------------

// PlayerAppendData

// optional .pb.GxDB_Modules_Info module = 1;
inline bool PlayerAppendData::has_module() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerAppendData::set_has_module() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerAppendData::clear_has_module() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerAppendData::clear_module() {
  if (module_ != NULL) module_->::pb::GxDB_Modules_Info::Clear();
  clear_has_module();
}
inline const ::pb::GxDB_Modules_Info& PlayerAppendData::module() const {
  return module_ != NULL ? *module_ : *default_instance_->module_;
}
inline ::pb::GxDB_Modules_Info* PlayerAppendData::mutable_module() {
  set_has_module();
  if (module_ == NULL) module_ = new ::pb::GxDB_Modules_Info;
  return module_;
}
inline ::pb::GxDB_Modules_Info* PlayerAppendData::release_module() {
  clear_has_module();
  ::pb::GxDB_Modules_Info* temp = module_;
  module_ = NULL;
  return temp;
}
inline void PlayerAppendData::set_allocated_module(::pb::GxDB_Modules_Info* module) {
  delete module_;
  module_ = module;
  if (module) {
    set_has_module();
  } else {
    clear_has_module();
  }
}

// optional .pb.GxDB_Buildings_Info building = 2;
inline bool PlayerAppendData::has_building() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerAppendData::set_has_building() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerAppendData::clear_has_building() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerAppendData::clear_building() {
  if (building_ != NULL) building_->::pb::GxDB_Buildings_Info::Clear();
  clear_has_building();
}
inline const ::pb::GxDB_Buildings_Info& PlayerAppendData::building() const {
  return building_ != NULL ? *building_ : *default_instance_->building_;
}
inline ::pb::GxDB_Buildings_Info* PlayerAppendData::mutable_building() {
  set_has_building();
  if (building_ == NULL) building_ = new ::pb::GxDB_Buildings_Info;
  return building_;
}
inline ::pb::GxDB_Buildings_Info* PlayerAppendData::release_building() {
  clear_has_building();
  ::pb::GxDB_Buildings_Info* temp = building_;
  building_ = NULL;
  return temp;
}
inline void PlayerAppendData::set_allocated_building(::pb::GxDB_Buildings_Info* building) {
  delete building_;
  building_ = building;
  if (building) {
    set_has_building();
  } else {
    clear_has_building();
  }
}

// -------------------------------------------------------------------

// SyncPlayerCacheData

// required uint64 account_id = 1;
inline bool SyncPlayerCacheData::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncPlayerCacheData::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncPlayerCacheData::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncPlayerCacheData::clear_account_id() {
  account_id_ = GOOGLE_ULONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::uint64 SyncPlayerCacheData::account_id() const {
  return account_id_;
}
inline void SyncPlayerCacheData::set_account_id(::google::protobuf::uint64 value) {
  set_has_account_id();
  account_id_ = value;
}

// required .pb.PlayerAllData all_data = 2;
inline bool SyncPlayerCacheData::has_all_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncPlayerCacheData::set_has_all_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncPlayerCacheData::clear_has_all_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncPlayerCacheData::clear_all_data() {
  if (all_data_ != NULL) all_data_->::pb::PlayerAllData::Clear();
  clear_has_all_data();
}
inline const ::pb::PlayerAllData& SyncPlayerCacheData::all_data() const {
  return all_data_ != NULL ? *all_data_ : *default_instance_->all_data_;
}
inline ::pb::PlayerAllData* SyncPlayerCacheData::mutable_all_data() {
  set_has_all_data();
  if (all_data_ == NULL) all_data_ = new ::pb::PlayerAllData;
  return all_data_;
}
inline ::pb::PlayerAllData* SyncPlayerCacheData::release_all_data() {
  clear_has_all_data();
  ::pb::PlayerAllData* temp = all_data_;
  all_data_ = NULL;
  return temp;
}
inline void SyncPlayerCacheData::set_allocated_all_data(::pb::PlayerAllData* all_data) {
  delete all_data_;
  all_data_ = all_data;
  if (all_data) {
    set_has_all_data();
  } else {
    clear_has_all_data();
  }
}

// optional .pb.PlayerAppendData append = 3;
inline bool SyncPlayerCacheData::has_append() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncPlayerCacheData::set_has_append() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncPlayerCacheData::clear_has_append() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncPlayerCacheData::clear_append() {
  if (append_ != NULL) append_->::pb::PlayerAppendData::Clear();
  clear_has_append();
}
inline const ::pb::PlayerAppendData& SyncPlayerCacheData::append() const {
  return append_ != NULL ? *append_ : *default_instance_->append_;
}
inline ::pb::PlayerAppendData* SyncPlayerCacheData::mutable_append() {
  set_has_append();
  if (append_ == NULL) append_ = new ::pb::PlayerAppendData;
  return append_;
}
inline ::pb::PlayerAppendData* SyncPlayerCacheData::release_append() {
  clear_has_append();
  ::pb::PlayerAppendData* temp = append_;
  append_ = NULL;
  return temp;
}
inline void SyncPlayerCacheData::set_allocated_append(::pb::PlayerAppendData* append) {
  delete append_;
  append_ = append;
  if (append) {
    set_has_append();
  } else {
    clear_has_append();
  }
}

// -------------------------------------------------------------------

// CQuickLogin

// optional uint64 account_id = 1;
inline bool CQuickLogin::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CQuickLogin::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CQuickLogin::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CQuickLogin::clear_account_id() {
  account_id_ = GOOGLE_ULONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::uint64 CQuickLogin::account_id() const {
  return account_id_;
}
inline void CQuickLogin::set_account_id(::google::protobuf::uint64 value) {
  set_has_account_id();
  account_id_ = value;
}

// optional uint64 player_id = 2;
inline bool CQuickLogin::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CQuickLogin::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CQuickLogin::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CQuickLogin::clear_player_id() {
  player_id_ = GOOGLE_ULONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::uint64 CQuickLogin::player_id() const {
  return player_id_;
}
inline void CQuickLogin::set_player_id(::google::protobuf::uint64 value) {
  set_has_player_id();
  player_id_ = value;
}

// optional string session_key = 3;
inline bool CQuickLogin::has_session_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CQuickLogin::set_has_session_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CQuickLogin::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CQuickLogin::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& CQuickLogin::session_key() const {
  return *session_key_;
}
inline void CQuickLogin::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void CQuickLogin::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void CQuickLogin::set_session_key(const char* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CQuickLogin::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  return session_key_;
}
inline ::std::string* CQuickLogin::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CQuickLogin::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 platform_id = 4;
inline bool CQuickLogin::has_platform_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CQuickLogin::set_has_platform_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CQuickLogin::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CQuickLogin::clear_platform_id() {
  platform_id_ = 0u;
  clear_has_platform_id();
}
inline ::google::protobuf::uint32 CQuickLogin::platform_id() const {
  return platform_id_;
}
inline void CQuickLogin::set_platform_id(::google::protobuf::uint32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// -------------------------------------------------------------------

// SQuickLogin

// required .pb.QuickLoginResult result = 1;
inline bool SQuickLogin::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SQuickLogin::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SQuickLogin::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SQuickLogin::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::pb::QuickLoginResult SQuickLogin::result() const {
  return static_cast< ::pb::QuickLoginResult >(result_);
}
inline void SQuickLogin::set_result(::pb::QuickLoginResult value) {
  assert(::pb::QuickLoginResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// GS2C_ItemOperateError

// required uint32 error_type = 1;
inline bool GS2C_ItemOperateError::has_error_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GS2C_ItemOperateError::set_has_error_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GS2C_ItemOperateError::clear_has_error_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GS2C_ItemOperateError::clear_error_type() {
  error_type_ = 0u;
  clear_has_error_type();
}
inline ::google::protobuf::uint32 GS2C_ItemOperateError::error_type() const {
  return error_type_;
}
inline void GS2C_ItemOperateError::set_error_type(::google::protobuf::uint32 value) {
  set_has_error_type();
  error_type_ = value;
}

// optional uint32 property = 2;
inline bool GS2C_ItemOperateError::has_property() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GS2C_ItemOperateError::set_has_property() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GS2C_ItemOperateError::clear_has_property() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GS2C_ItemOperateError::clear_property() {
  property_ = 0u;
  clear_has_property();
}
inline ::google::protobuf::uint32 GS2C_ItemOperateError::property() const {
  return property_;
}
inline void GS2C_ItemOperateError::set_property(::google::protobuf::uint32 value) {
  set_has_property();
  property_ = value;
}

// -------------------------------------------------------------------

// GS2C_Player_Online_State

// optional uint64 player_guid = 1;
inline bool GS2C_Player_Online_State::has_player_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GS2C_Player_Online_State::set_has_player_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GS2C_Player_Online_State::clear_has_player_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GS2C_Player_Online_State::clear_player_guid() {
  player_guid_ = GOOGLE_ULONGLONG(0);
  clear_has_player_guid();
}
inline ::google::protobuf::uint64 GS2C_Player_Online_State::player_guid() const {
  return player_guid_;
}
inline void GS2C_Player_Online_State::set_player_guid(::google::protobuf::uint64 value) {
  set_has_player_guid();
  player_guid_ = value;
}

// optional string player_name = 2;
inline bool GS2C_Player_Online_State::has_player_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GS2C_Player_Online_State::set_has_player_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GS2C_Player_Online_State::clear_has_player_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GS2C_Player_Online_State::clear_player_name() {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    player_name_->clear();
  }
  clear_has_player_name();
}
inline const ::std::string& GS2C_Player_Online_State::player_name() const {
  return *player_name_;
}
inline void GS2C_Player_Online_State::set_player_name(const ::std::string& value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void GS2C_Player_Online_State::set_player_name(const char* value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void GS2C_Player_Online_State::set_player_name(const char* value, size_t size) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GS2C_Player_Online_State::mutable_player_name() {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  return player_name_;
}
inline ::std::string* GS2C_Player_Online_State::release_player_name() {
  clear_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = player_name_;
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GS2C_Player_Online_State::set_allocated_player_name(::std::string* player_name) {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    delete player_name_;
  }
  if (player_name) {
    set_has_player_name();
    player_name_ = player_name;
  } else {
    clear_has_player_name();
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isonline = 3;
inline bool GS2C_Player_Online_State::has_isonline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GS2C_Player_Online_State::set_has_isonline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GS2C_Player_Online_State::clear_has_isonline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GS2C_Player_Online_State::clear_isonline() {
  isonline_ = false;
  clear_has_isonline();
}
inline bool GS2C_Player_Online_State::isonline() const {
  return isonline_;
}
inline void GS2C_Player_Online_State::set_isonline(bool value) {
  set_has_isonline();
  isonline_ = value;
}

// -------------------------------------------------------------------

// C2GS_Is_Player_Exist

// required string player_name = 1;
inline bool C2GS_Is_Player_Exist::has_player_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2GS_Is_Player_Exist::set_has_player_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2GS_Is_Player_Exist::clear_has_player_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2GS_Is_Player_Exist::clear_player_name() {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    player_name_->clear();
  }
  clear_has_player_name();
}
inline const ::std::string& C2GS_Is_Player_Exist::player_name() const {
  return *player_name_;
}
inline void C2GS_Is_Player_Exist::set_player_name(const ::std::string& value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void C2GS_Is_Player_Exist::set_player_name(const char* value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void C2GS_Is_Player_Exist::set_player_name(const char* value, size_t size) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2GS_Is_Player_Exist::mutable_player_name() {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  return player_name_;
}
inline ::std::string* C2GS_Is_Player_Exist::release_player_name() {
  clear_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = player_name_;
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void C2GS_Is_Player_Exist::set_allocated_player_name(::std::string* player_name) {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    delete player_name_;
  }
  if (player_name) {
    set_has_player_name();
    player_name_ = player_name;
  } else {
    clear_has_player_name();
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 your_guid = 2;
inline bool C2GS_Is_Player_Exist::has_your_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2GS_Is_Player_Exist::set_has_your_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2GS_Is_Player_Exist::clear_has_your_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2GS_Is_Player_Exist::clear_your_guid() {
  your_guid_ = GOOGLE_ULONGLONG(0);
  clear_has_your_guid();
}
inline ::google::protobuf::uint64 C2GS_Is_Player_Exist::your_guid() const {
  return your_guid_;
}
inline void C2GS_Is_Player_Exist::set_your_guid(::google::protobuf::uint64 value) {
  set_has_your_guid();
  your_guid_ = value;
}

// optional uint32 send_from = 3;
inline bool C2GS_Is_Player_Exist::has_send_from() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2GS_Is_Player_Exist::set_has_send_from() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2GS_Is_Player_Exist::clear_has_send_from() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2GS_Is_Player_Exist::clear_send_from() {
  send_from_ = 0u;
  clear_has_send_from();
}
inline ::google::protobuf::uint32 C2GS_Is_Player_Exist::send_from() const {
  return send_from_;
}
inline void C2GS_Is_Player_Exist::set_send_from(::google::protobuf::uint32 value) {
  set_has_send_from();
  send_from_ = value;
}

// -------------------------------------------------------------------

// GS2C_Is_Player_Exist

// required bool is_exist = 1;
inline bool GS2C_Is_Player_Exist::has_is_exist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GS2C_Is_Player_Exist::set_has_is_exist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GS2C_Is_Player_Exist::clear_has_is_exist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GS2C_Is_Player_Exist::clear_is_exist() {
  is_exist_ = false;
  clear_has_is_exist();
}
inline bool GS2C_Is_Player_Exist::is_exist() const {
  return is_exist_;
}
inline void GS2C_Is_Player_Exist::set_is_exist(bool value) {
  set_has_is_exist();
  is_exist_ = value;
}

// optional string player_name = 2;
inline bool GS2C_Is_Player_Exist::has_player_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GS2C_Is_Player_Exist::set_has_player_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GS2C_Is_Player_Exist::clear_has_player_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GS2C_Is_Player_Exist::clear_player_name() {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    player_name_->clear();
  }
  clear_has_player_name();
}
inline const ::std::string& GS2C_Is_Player_Exist::player_name() const {
  return *player_name_;
}
inline void GS2C_Is_Player_Exist::set_player_name(const ::std::string& value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void GS2C_Is_Player_Exist::set_player_name(const char* value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
}
inline void GS2C_Is_Player_Exist::set_player_name(const char* value, size_t size) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GS2C_Is_Player_Exist::mutable_player_name() {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    player_name_ = new ::std::string;
  }
  return player_name_;
}
inline ::std::string* GS2C_Is_Player_Exist::release_player_name() {
  clear_has_player_name();
  if (player_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = player_name_;
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GS2C_Is_Player_Exist::set_allocated_player_name(::std::string* player_name) {
  if (player_name_ != &::google::protobuf::internal::kEmptyString) {
    delete player_name_;
  }
  if (player_name) {
    set_has_player_name();
    player_name_ = player_name;
  } else {
    clear_has_player_name();
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_online = 3;
inline bool GS2C_Is_Player_Exist::has_is_online() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GS2C_Is_Player_Exist::set_has_is_online() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GS2C_Is_Player_Exist::clear_has_is_online() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GS2C_Is_Player_Exist::clear_is_online() {
  is_online_ = false;
  clear_has_is_online();
}
inline bool GS2C_Is_Player_Exist::is_online() const {
  return is_online_;
}
inline void GS2C_Is_Player_Exist::set_is_online(bool value) {
  set_has_is_online();
  is_online_ = value;
}

// required uint64 your_guid = 4;
inline bool GS2C_Is_Player_Exist::has_your_guid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GS2C_Is_Player_Exist::set_has_your_guid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GS2C_Is_Player_Exist::clear_has_your_guid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GS2C_Is_Player_Exist::clear_your_guid() {
  your_guid_ = GOOGLE_ULONGLONG(0);
  clear_has_your_guid();
}
inline ::google::protobuf::uint64 GS2C_Is_Player_Exist::your_guid() const {
  return your_guid_;
}
inline void GS2C_Is_Player_Exist::set_your_guid(::google::protobuf::uint64 value) {
  set_has_your_guid();
  your_guid_ = value;
}

// optional uint32 send_from = 5;
inline bool GS2C_Is_Player_Exist::has_send_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GS2C_Is_Player_Exist::set_has_send_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GS2C_Is_Player_Exist::clear_has_send_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GS2C_Is_Player_Exist::clear_send_from() {
  send_from_ = 0u;
  clear_has_send_from();
}
inline ::google::protobuf::uint32 GS2C_Is_Player_Exist::send_from() const {
  return send_from_;
}
inline void GS2C_Is_Player_Exist::set_send_from(::google::protobuf::uint32 value) {
  set_has_send_from();
  send_from_ = value;
}

// -------------------------------------------------------------------

// FeedbackInfo

// optional string feedback = 1;
inline bool FeedbackInfo::has_feedback() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeedbackInfo::set_has_feedback() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeedbackInfo::clear_has_feedback() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeedbackInfo::clear_feedback() {
  if (feedback_ != &::google::protobuf::internal::kEmptyString) {
    feedback_->clear();
  }
  clear_has_feedback();
}
inline const ::std::string& FeedbackInfo::feedback() const {
  return *feedback_;
}
inline void FeedbackInfo::set_feedback(const ::std::string& value) {
  set_has_feedback();
  if (feedback_ == &::google::protobuf::internal::kEmptyString) {
    feedback_ = new ::std::string;
  }
  feedback_->assign(value);
}
inline void FeedbackInfo::set_feedback(const char* value) {
  set_has_feedback();
  if (feedback_ == &::google::protobuf::internal::kEmptyString) {
    feedback_ = new ::std::string;
  }
  feedback_->assign(value);
}
inline void FeedbackInfo::set_feedback(const char* value, size_t size) {
  set_has_feedback();
  if (feedback_ == &::google::protobuf::internal::kEmptyString) {
    feedback_ = new ::std::string;
  }
  feedback_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeedbackInfo::mutable_feedback() {
  set_has_feedback();
  if (feedback_ == &::google::protobuf::internal::kEmptyString) {
    feedback_ = new ::std::string;
  }
  return feedback_;
}
inline ::std::string* FeedbackInfo::release_feedback() {
  clear_has_feedback();
  if (feedback_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = feedback_;
    feedback_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeedbackInfo::set_allocated_feedback(::std::string* feedback) {
  if (feedback_ != &::google::protobuf::internal::kEmptyString) {
    delete feedback_;
  }
  if (feedback) {
    set_has_feedback();
    feedback_ = feedback;
  } else {
    clear_has_feedback();
    feedback_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FeedbackRet

// required bool is_success = 1;
inline bool FeedbackRet::has_is_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeedbackRet::set_has_is_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeedbackRet::clear_has_is_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeedbackRet::clear_is_success() {
  is_success_ = false;
  clear_has_is_success();
}
inline bool FeedbackRet::is_success() const {
  return is_success_;
}
inline void FeedbackRet::set_is_success(bool value) {
  set_has_is_success();
  is_success_ = value;
}

// optional int32 error_code = 2;
inline bool FeedbackRet::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeedbackRet::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeedbackRet::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeedbackRet::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 FeedbackRet::error_code() const {
  return error_code_;
}
inline void FeedbackRet::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// NUll_Ret


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::KickErrorType>() {
  return ::pb::KickErrorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::QuickLoginResult>() {
  return ::pb::QuickLoginResult_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GameServer_2eproto__INCLUDED
