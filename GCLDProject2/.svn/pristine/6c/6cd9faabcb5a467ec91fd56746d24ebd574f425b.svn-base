// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Login.proto

#ifndef PROTOBUF_Login_2eproto__INCLUDED
#define PROTOBUF_Login_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "GameServer.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Login_2eproto();
void protobuf_AssignDesc_Login_2eproto();
void protobuf_ShutdownFile_Login_2eproto();

class CVersionCheck;
class SVersionCheck;
class CVstarGameAccountCheck;
class SVstarGameAccountCheck;
class CAccountCheck;
class SAccountCheck;
class CRegisterAccount;
class SRegisterAccount;
class CChangeAccountAndPassord;
class SChangeAccountAndPassord;
class CGetServerList;
class ServerInfo;
class SGetServerList;
class CSelectServerId;
class SSelectServerId;
class CGetPlayerList;
class PlayerListInfo;
class SGetPlayerList;
class CCreateChar;
class MSG_ChangeName;
class MSG_SetNameAndHeadId;
class SCreateChar;
class SCreateCharRes;
class CSlectPlayer;
class SSlectPlayer;
class SGuideProcess;

enum VERSION_CHECK_RESULT {
  VERSION_CHECK_NEWEST_VERION_SUCCESS = 0,
  VERSION_CHECK_INVALID_VERSION = 1,
  VERSION_CHECK_INVALID_RESOURCE_VESION = 2,
  VERSION_CHECK_CAN_NOT_FIND_PLATFORM = 3,
  VERSION_CHECK_RESOURCE_NOT_SET = 4
};
bool VERSION_CHECK_RESULT_IsValid(int value);
const VERSION_CHECK_RESULT VERSION_CHECK_RESULT_MIN = VERSION_CHECK_NEWEST_VERION_SUCCESS;
const VERSION_CHECK_RESULT VERSION_CHECK_RESULT_MAX = VERSION_CHECK_RESOURCE_NOT_SET;
const int VERSION_CHECK_RESULT_ARRAYSIZE = VERSION_CHECK_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* VERSION_CHECK_RESULT_descriptor();
inline const ::std::string& VERSION_CHECK_RESULT_Name(VERSION_CHECK_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    VERSION_CHECK_RESULT_descriptor(), value);
}
inline bool VERSION_CHECK_RESULT_Parse(
    const ::std::string& name, VERSION_CHECK_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VERSION_CHECK_RESULT>(
    VERSION_CHECK_RESULT_descriptor(), name, value);
}
enum ACCOUNT_CHECK_METHOD {
  ACCOUNT_CHECK_ACCOUNT = 1
};
bool ACCOUNT_CHECK_METHOD_IsValid(int value);
const ACCOUNT_CHECK_METHOD ACCOUNT_CHECK_METHOD_MIN = ACCOUNT_CHECK_ACCOUNT;
const ACCOUNT_CHECK_METHOD ACCOUNT_CHECK_METHOD_MAX = ACCOUNT_CHECK_ACCOUNT;
const int ACCOUNT_CHECK_METHOD_ARRAYSIZE = ACCOUNT_CHECK_METHOD_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACCOUNT_CHECK_METHOD_descriptor();
inline const ::std::string& ACCOUNT_CHECK_METHOD_Name(ACCOUNT_CHECK_METHOD value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACCOUNT_CHECK_METHOD_descriptor(), value);
}
inline bool ACCOUNT_CHECK_METHOD_Parse(
    const ::std::string& name, ACCOUNT_CHECK_METHOD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACCOUNT_CHECK_METHOD>(
    ACCOUNT_CHECK_METHOD_descriptor(), name, value);
}
enum ACCOUNT_CHECK_RESULT {
  ACCOUNT_CHECK_SUCCESS = 0,
  ACCOUNT_CHECK_NAME_ERROR = 1,
  ACCOUNT_CHECK_PWD_ERROR = 2,
  ACCOUNT_CHECK_METHOD_UNKNOW = 3,
  ACCOUNT_CHECK_FORBIDEN = 4
};
bool ACCOUNT_CHECK_RESULT_IsValid(int value);
const ACCOUNT_CHECK_RESULT ACCOUNT_CHECK_RESULT_MIN = ACCOUNT_CHECK_SUCCESS;
const ACCOUNT_CHECK_RESULT ACCOUNT_CHECK_RESULT_MAX = ACCOUNT_CHECK_FORBIDEN;
const int ACCOUNT_CHECK_RESULT_ARRAYSIZE = ACCOUNT_CHECK_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACCOUNT_CHECK_RESULT_descriptor();
inline const ::std::string& ACCOUNT_CHECK_RESULT_Name(ACCOUNT_CHECK_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACCOUNT_CHECK_RESULT_descriptor(), value);
}
inline bool ACCOUNT_CHECK_RESULT_Parse(
    const ::std::string& name, ACCOUNT_CHECK_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACCOUNT_CHECK_RESULT>(
    ACCOUNT_CHECK_RESULT_descriptor(), name, value);
}
enum ACCOUNT_TYPE {
  ACCOUNT_TYPE_GUEST = 0,
  ACCOUNT_TYPE_NORMAL = 1
};
bool ACCOUNT_TYPE_IsValid(int value);
const ACCOUNT_TYPE ACCOUNT_TYPE_MIN = ACCOUNT_TYPE_GUEST;
const ACCOUNT_TYPE ACCOUNT_TYPE_MAX = ACCOUNT_TYPE_NORMAL;
const int ACCOUNT_TYPE_ARRAYSIZE = ACCOUNT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACCOUNT_TYPE_descriptor();
inline const ::std::string& ACCOUNT_TYPE_Name(ACCOUNT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACCOUNT_TYPE_descriptor(), value);
}
inline bool ACCOUNT_TYPE_Parse(
    const ::std::string& name, ACCOUNT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACCOUNT_TYPE>(
    ACCOUNT_TYPE_descriptor(), name, value);
}
enum REGISTER_ACCOUNT_TYPE {
  REGISTER_ACCOUNT_ACCOUNT = 0,
  REGISTER_ACCOUNT_GUEST = 1
};
bool REGISTER_ACCOUNT_TYPE_IsValid(int value);
const REGISTER_ACCOUNT_TYPE REGISTER_ACCOUNT_TYPE_MIN = REGISTER_ACCOUNT_ACCOUNT;
const REGISTER_ACCOUNT_TYPE REGISTER_ACCOUNT_TYPE_MAX = REGISTER_ACCOUNT_GUEST;
const int REGISTER_ACCOUNT_TYPE_ARRAYSIZE = REGISTER_ACCOUNT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* REGISTER_ACCOUNT_TYPE_descriptor();
inline const ::std::string& REGISTER_ACCOUNT_TYPE_Name(REGISTER_ACCOUNT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    REGISTER_ACCOUNT_TYPE_descriptor(), value);
}
inline bool REGISTER_ACCOUNT_TYPE_Parse(
    const ::std::string& name, REGISTER_ACCOUNT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<REGISTER_ACCOUNT_TYPE>(
    REGISTER_ACCOUNT_TYPE_descriptor(), name, value);
}
enum REGISTER_ACCOUNT_RESULT {
  REGISTER_ACCOUNT_SUCCESS = 0,
  REGISTER_ACCOUNT_NAME_ERROR = 1,
  REGISTER_ACCOUNT_NAME_EXIST = 2,
  REGISTER_ACCOUTN_PWD_ERROR = 3
};
bool REGISTER_ACCOUNT_RESULT_IsValid(int value);
const REGISTER_ACCOUNT_RESULT REGISTER_ACCOUNT_RESULT_MIN = REGISTER_ACCOUNT_SUCCESS;
const REGISTER_ACCOUNT_RESULT REGISTER_ACCOUNT_RESULT_MAX = REGISTER_ACCOUTN_PWD_ERROR;
const int REGISTER_ACCOUNT_RESULT_ARRAYSIZE = REGISTER_ACCOUNT_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* REGISTER_ACCOUNT_RESULT_descriptor();
inline const ::std::string& REGISTER_ACCOUNT_RESULT_Name(REGISTER_ACCOUNT_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    REGISTER_ACCOUNT_RESULT_descriptor(), value);
}
inline bool REGISTER_ACCOUNT_RESULT_Parse(
    const ::std::string& name, REGISTER_ACCOUNT_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<REGISTER_ACCOUNT_RESULT>(
    REGISTER_ACCOUNT_RESULT_descriptor(), name, value);
}
enum CHANGE_ACCOUNT_PASSWORD_RESULT {
  CHANGE_ACCOUNT_PWD_ACCOUNT_SUCCESS = 0,
  CHANGE_ACCOUNT_PWD_ACCOUNT_ERROR = 1,
  CHANGE_ACCOUNT_PWD_PASSWORD_ERROR = 2
};
bool CHANGE_ACCOUNT_PASSWORD_RESULT_IsValid(int value);
const CHANGE_ACCOUNT_PASSWORD_RESULT CHANGE_ACCOUNT_PASSWORD_RESULT_MIN = CHANGE_ACCOUNT_PWD_ACCOUNT_SUCCESS;
const CHANGE_ACCOUNT_PASSWORD_RESULT CHANGE_ACCOUNT_PASSWORD_RESULT_MAX = CHANGE_ACCOUNT_PWD_PASSWORD_ERROR;
const int CHANGE_ACCOUNT_PASSWORD_RESULT_ARRAYSIZE = CHANGE_ACCOUNT_PASSWORD_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* CHANGE_ACCOUNT_PASSWORD_RESULT_descriptor();
inline const ::std::string& CHANGE_ACCOUNT_PASSWORD_RESULT_Name(CHANGE_ACCOUNT_PASSWORD_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    CHANGE_ACCOUNT_PASSWORD_RESULT_descriptor(), value);
}
inline bool CHANGE_ACCOUNT_PASSWORD_RESULT_Parse(
    const ::std::string& name, CHANGE_ACCOUNT_PASSWORD_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CHANGE_ACCOUNT_PASSWORD_RESULT>(
    CHANGE_ACCOUNT_PASSWORD_RESULT_descriptor(), name, value);
}
enum ServerState {
  SERVER_STATE_GOOD = 0,
  SERVER_STATE_BUSY = 1,
  SERVER_STATE_LIMIT = 2,
  SERVER_STATE_MAINTAIN = 3
};
bool ServerState_IsValid(int value);
const ServerState ServerState_MIN = SERVER_STATE_GOOD;
const ServerState ServerState_MAX = SERVER_STATE_MAINTAIN;
const int ServerState_ARRAYSIZE = ServerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerState_descriptor();
inline const ::std::string& ServerState_Name(ServerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerState_descriptor(), value);
}
inline bool ServerState_Parse(
    const ::std::string& name, ServerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerState>(
    ServerState_descriptor(), name, value);
}
enum ASK_SELECTSERVERID_RESULT {
  ASK_SELECTSERVERID_SUCCESS = 0,
  ASK_SELECTSERVERID_INVALID_SERVER = 1,
  ASK_SELECTSERVERID_RECH_SERVER_LIMIT = 2,
  ASK_SELECTSERVERID_IN_MAINTAIN = 3
};
bool ASK_SELECTSERVERID_RESULT_IsValid(int value);
const ASK_SELECTSERVERID_RESULT ASK_SELECTSERVERID_RESULT_MIN = ASK_SELECTSERVERID_SUCCESS;
const ASK_SELECTSERVERID_RESULT ASK_SELECTSERVERID_RESULT_MAX = ASK_SELECTSERVERID_IN_MAINTAIN;
const int ASK_SELECTSERVERID_RESULT_ARRAYSIZE = ASK_SELECTSERVERID_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASK_SELECTSERVERID_RESULT_descriptor();
inline const ::std::string& ASK_SELECTSERVERID_RESULT_Name(ASK_SELECTSERVERID_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASK_SELECTSERVERID_RESULT_descriptor(), value);
}
inline bool ASK_SELECTSERVERID_RESULT_Parse(
    const ::std::string& name, ASK_SELECTSERVERID_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASK_SELECTSERVERID_RESULT>(
    ASK_SELECTSERVERID_RESULT_descriptor(), name, value);
}
enum GET_PLAYER_LIST_RESULT {
  GET_PALYER_LIST_SUCCESS = 0,
  GET_PLAYER_LIST_KEY_ERROR = 1,
  GET_PLAYER_LIST_KEY_VALUE_INVALID = 2,
  GET_PLAYER_LIST_DB_ERROR = 3
};
bool GET_PLAYER_LIST_RESULT_IsValid(int value);
const GET_PLAYER_LIST_RESULT GET_PLAYER_LIST_RESULT_MIN = GET_PALYER_LIST_SUCCESS;
const GET_PLAYER_LIST_RESULT GET_PLAYER_LIST_RESULT_MAX = GET_PLAYER_LIST_DB_ERROR;
const int GET_PLAYER_LIST_RESULT_ARRAYSIZE = GET_PLAYER_LIST_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* GET_PLAYER_LIST_RESULT_descriptor();
inline const ::std::string& GET_PLAYER_LIST_RESULT_Name(GET_PLAYER_LIST_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    GET_PLAYER_LIST_RESULT_descriptor(), value);
}
inline bool GET_PLAYER_LIST_RESULT_Parse(
    const ::std::string& name, GET_PLAYER_LIST_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GET_PLAYER_LIST_RESULT>(
    GET_PLAYER_LIST_RESULT_descriptor(), name, value);
}
enum CREATE_PLAYER_RESULT {
  CREATE_PLAYER_SUCCESS = 0,
  CREATE_PLAYER_SAME_NAME = 1,
  CREATE_PLAYER_UNAVAILABLE_SERVER = 2,
  CREATE_PLAYER_FULL = 3,
  CREATE_PLAYER_INVALID_NAME = 4,
  CREATE_PLAYER_CREATE_INFO_ERROR = 5,
  CREATE_PLAYER_DATABASE_INSERT_FAIL = 6
};
bool CREATE_PLAYER_RESULT_IsValid(int value);
const CREATE_PLAYER_RESULT CREATE_PLAYER_RESULT_MIN = CREATE_PLAYER_SUCCESS;
const CREATE_PLAYER_RESULT CREATE_PLAYER_RESULT_MAX = CREATE_PLAYER_DATABASE_INSERT_FAIL;
const int CREATE_PLAYER_RESULT_ARRAYSIZE = CREATE_PLAYER_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* CREATE_PLAYER_RESULT_descriptor();
inline const ::std::string& CREATE_PLAYER_RESULT_Name(CREATE_PLAYER_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    CREATE_PLAYER_RESULT_descriptor(), value);
}
inline bool CREATE_PLAYER_RESULT_Parse(
    const ::std::string& name, CREATE_PLAYER_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CREATE_PLAYER_RESULT>(
    CREATE_PLAYER_RESULT_descriptor(), name, value);
}
enum SELECT_PLAYER_RESULT {
  SELECT_PLAYER_SUCCESS = 0,
  SELECT_PLAYER_UNAVAILABLE_SERVER = 1,
  SELECT_PLAYER_PLAYER_ID_ERROR = 2,
  SELECT_PLAYER_PLAYER_ID_LOCKED = 3
};
bool SELECT_PLAYER_RESULT_IsValid(int value);
const SELECT_PLAYER_RESULT SELECT_PLAYER_RESULT_MIN = SELECT_PLAYER_SUCCESS;
const SELECT_PLAYER_RESULT SELECT_PLAYER_RESULT_MAX = SELECT_PLAYER_PLAYER_ID_LOCKED;
const int SELECT_PLAYER_RESULT_ARRAYSIZE = SELECT_PLAYER_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* SELECT_PLAYER_RESULT_descriptor();
inline const ::std::string& SELECT_PLAYER_RESULT_Name(SELECT_PLAYER_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    SELECT_PLAYER_RESULT_descriptor(), value);
}
inline bool SELECT_PLAYER_RESULT_Parse(
    const ::std::string& name, SELECT_PLAYER_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SELECT_PLAYER_RESULT>(
    SELECT_PLAYER_RESULT_descriptor(), name, value);
}
// ===================================================================

class CVersionCheck : public ::google::protobuf::Message {
 public:
  CVersionCheck();
  virtual ~CVersionCheck();

  CVersionCheck(const CVersionCheck& from);

  inline CVersionCheck& operator=(const CVersionCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CVersionCheck& default_instance();

  void Swap(CVersionCheck* other);

  // implements Message ----------------------------------------------

  CVersionCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CVersionCheck& from);
  void MergeFrom(const CVersionCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // required uint32 platform_id = 2;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 2;
  inline ::google::protobuf::uint32 platform_id() const;
  inline void set_platform_id(::google::protobuf::uint32 value);

  // required uint32 version_id = 3;
  inline bool has_version_id() const;
  inline void clear_version_id();
  static const int kVersionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 version_id() const;
  inline void set_version_id(::google::protobuf::uint32 value);

  // required uint32 resource_id = 4;
  inline bool has_resource_id() const;
  inline void clear_resource_id();
  static const int kResourceIdFieldNumber = 4;
  inline ::google::protobuf::uint32 resource_id() const;
  inline void set_resource_id(::google::protobuf::uint32 value);

  // optional string device_id = 5;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 5;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:pb.CVersionCheck)
 private:
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();
  inline void set_has_version_id();
  inline void clear_has_version_id();
  inline void set_has_resource_id();
  inline void clear_has_resource_id();
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 platform_id_;
  ::google::protobuf::uint32 version_id_;
  ::google::protobuf::uint32 resource_id_;
  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static CVersionCheck* default_instance_;
};
// -------------------------------------------------------------------

class SVersionCheck : public ::google::protobuf::Message {
 public:
  SVersionCheck();
  virtual ~SVersionCheck();

  SVersionCheck(const SVersionCheck& from);

  inline SVersionCheck& operator=(const SVersionCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SVersionCheck& default_instance();

  void Swap(SVersionCheck* other);

  // implements Message ----------------------------------------------

  SVersionCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SVersionCheck& from);
  void MergeFrom(const SVersionCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.VERSION_CHECK_RESULT result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::pb::VERSION_CHECK_RESULT result() const;
  inline void set_result(::pb::VERSION_CHECK_RESULT value);

  // optional uint32 resource_id = 2;
  inline bool has_resource_id() const;
  inline void clear_resource_id();
  static const int kResourceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 resource_id() const;
  inline void set_resource_id(::google::protobuf::uint32 value);

  // optional string notice_address = 3;
  inline bool has_notice_address() const;
  inline void clear_notice_address();
  static const int kNoticeAddressFieldNumber = 3;
  inline const ::std::string& notice_address() const;
  inline void set_notice_address(const ::std::string& value);
  inline void set_notice_address(const char* value);
  inline void set_notice_address(const char* value, size_t size);
  inline ::std::string* mutable_notice_address();
  inline ::std::string* release_notice_address();
  inline void set_allocated_notice_address(::std::string* notice_address);

  // optional string resource_address = 4;
  inline bool has_resource_address() const;
  inline void clear_resource_address();
  static const int kResourceAddressFieldNumber = 4;
  inline const ::std::string& resource_address() const;
  inline void set_resource_address(const ::std::string& value);
  inline void set_resource_address(const char* value);
  inline void set_resource_address(const char* value, size_t size);
  inline ::std::string* mutable_resource_address();
  inline ::std::string* release_resource_address();
  inline void set_allocated_resource_address(::std::string* resource_address);

  // optional uint32 is_hot_update = 5;
  inline bool has_is_hot_update() const;
  inline void clear_is_hot_update();
  static const int kIsHotUpdateFieldNumber = 5;
  inline ::google::protobuf::uint32 is_hot_update() const;
  inline void set_is_hot_update(::google::protobuf::uint32 value);

  // optional string newest_version_address = 6;
  inline bool has_newest_version_address() const;
  inline void clear_newest_version_address();
  static const int kNewestVersionAddressFieldNumber = 6;
  inline const ::std::string& newest_version_address() const;
  inline void set_newest_version_address(const ::std::string& value);
  inline void set_newest_version_address(const char* value);
  inline void set_newest_version_address(const char* value, size_t size);
  inline ::std::string* mutable_newest_version_address();
  inline ::std::string* release_newest_version_address();
  inline void set_allocated_newest_version_address(::std::string* newest_version_address);

  // optional float apk_size = 7;
  inline bool has_apk_size() const;
  inline void clear_apk_size();
  static const int kApkSizeFieldNumber = 7;
  inline float apk_size() const;
  inline void set_apk_size(float value);

  // @@protoc_insertion_point(class_scope:pb.SVersionCheck)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_resource_id();
  inline void clear_has_resource_id();
  inline void set_has_notice_address();
  inline void clear_has_notice_address();
  inline void set_has_resource_address();
  inline void clear_has_resource_address();
  inline void set_has_is_hot_update();
  inline void clear_has_is_hot_update();
  inline void set_has_newest_version_address();
  inline void clear_has_newest_version_address();
  inline void set_has_apk_size();
  inline void clear_has_apk_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int result_;
  ::google::protobuf::uint32 resource_id_;
  ::std::string* notice_address_;
  ::std::string* resource_address_;
  ::std::string* newest_version_address_;
  ::google::protobuf::uint32 is_hot_update_;
  float apk_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SVersionCheck* default_instance_;
};
// -------------------------------------------------------------------

class CVstarGameAccountCheck : public ::google::protobuf::Message {
 public:
  CVstarGameAccountCheck();
  virtual ~CVstarGameAccountCheck();

  CVstarGameAccountCheck(const CVstarGameAccountCheck& from);

  inline CVstarGameAccountCheck& operator=(const CVstarGameAccountCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CVstarGameAccountCheck& default_instance();

  void Swap(CVstarGameAccountCheck* other);

  // implements Message ----------------------------------------------

  CVstarGameAccountCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CVstarGameAccountCheck& from);
  void MergeFrom(const CVstarGameAccountCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const char* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // optional string sdk_user_id = 2;
  inline bool has_sdk_user_id() const;
  inline void clear_sdk_user_id();
  static const int kSdkUserIdFieldNumber = 2;
  inline const ::std::string& sdk_user_id() const;
  inline void set_sdk_user_id(const ::std::string& value);
  inline void set_sdk_user_id(const char* value);
  inline void set_sdk_user_id(const char* value, size_t size);
  inline ::std::string* mutable_sdk_user_id();
  inline ::std::string* release_sdk_user_id();
  inline void set_allocated_sdk_user_id(::std::string* sdk_user_id);

  // optional string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional .pb.CRegisterAccount register_info = 4;
  inline bool has_register_info() const;
  inline void clear_register_info();
  static const int kRegisterInfoFieldNumber = 4;
  inline const ::pb::CRegisterAccount& register_info() const;
  inline ::pb::CRegisterAccount* mutable_register_info();
  inline ::pb::CRegisterAccount* release_register_info();
  inline void set_allocated_register_info(::pb::CRegisterAccount* register_info);

  // @@protoc_insertion_point(class_scope:pb.CVstarGameAccountCheck)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_sdk_user_id();
  inline void clear_has_sdk_user_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_register_info();
  inline void clear_has_register_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* client_id_;
  ::std::string* sdk_user_id_;
  ::std::string* token_;
  ::pb::CRegisterAccount* register_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static CVstarGameAccountCheck* default_instance_;
};
// -------------------------------------------------------------------

class SVstarGameAccountCheck : public ::google::protobuf::Message {
 public:
  SVstarGameAccountCheck();
  virtual ~SVstarGameAccountCheck();

  SVstarGameAccountCheck(const SVstarGameAccountCheck& from);

  inline SVstarGameAccountCheck& operator=(const SVstarGameAccountCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SVstarGameAccountCheck& default_instance();

  void Swap(SVstarGameAccountCheck* other);

  // implements Message ----------------------------------------------

  SVstarGameAccountCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SVstarGameAccountCheck& from);
  void MergeFrom(const SVstarGameAccountCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline bool status() const;
  inline void set_status(bool value);

  // optional string sdk_user_id = 2;
  inline bool has_sdk_user_id() const;
  inline void clear_sdk_user_id();
  static const int kSdkUserIdFieldNumber = 2;
  inline const ::std::string& sdk_user_id() const;
  inline void set_sdk_user_id(const ::std::string& value);
  inline void set_sdk_user_id(const char* value);
  inline void set_sdk_user_id(const char* value, size_t size);
  inline ::std::string* mutable_sdk_user_id();
  inline ::std::string* release_sdk_user_id();
  inline void set_allocated_sdk_user_id(::std::string* sdk_user_id);

  // optional uint32 error_code = 3;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // optional string error_msg = 4;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 4;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  inline void set_allocated_error_msg(::std::string* error_msg);

  // optional uint64 account_id = 5;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 5;
  inline ::google::protobuf::uint64 account_id() const;
  inline void set_account_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.SVstarGameAccountCheck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_sdk_user_id();
  inline void clear_has_sdk_user_id();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sdk_user_id_;
  bool status_;
  ::google::protobuf::uint32 error_code_;
  ::std::string* error_msg_;
  ::google::protobuf::uint64 account_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SVstarGameAccountCheck* default_instance_;
};
// -------------------------------------------------------------------

class CAccountCheck : public ::google::protobuf::Message {
 public:
  CAccountCheck();
  virtual ~CAccountCheck();

  CAccountCheck(const CAccountCheck& from);

  inline CAccountCheck& operator=(const CAccountCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CAccountCheck& default_instance();

  void Swap(CAccountCheck* other);

  // implements Message ----------------------------------------------

  CAccountCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CAccountCheck& from);
  void MergeFrom(const CAccountCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.ACCOUNT_CHECK_METHOD method = 1;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 1;
  inline ::pb::ACCOUNT_CHECK_METHOD method() const;
  inline void set_method(::pb::ACCOUNT_CHECK_METHOD value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required uint32 channel_id = 4;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 4;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // required uint32 platform_id = 5;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 5;
  inline ::google::protobuf::uint32 platform_id() const;
  inline void set_platform_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.CAccountCheck)
 private:
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int method_;
  ::google::protobuf::uint32 channel_id_;
  ::std::string* password_;
  ::google::protobuf::uint32 platform_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static CAccountCheck* default_instance_;
};
// -------------------------------------------------------------------

class SAccountCheck : public ::google::protobuf::Message {
 public:
  SAccountCheck();
  virtual ~SAccountCheck();

  SAccountCheck(const SAccountCheck& from);

  inline SAccountCheck& operator=(const SAccountCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SAccountCheck& default_instance();

  void Swap(SAccountCheck* other);

  // implements Message ----------------------------------------------

  SAccountCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SAccountCheck& from);
  void MergeFrom(const SAccountCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.ACCOUNT_CHECK_RESULT result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::pb::ACCOUNT_CHECK_RESULT result() const;
  inline void set_result(::pb::ACCOUNT_CHECK_RESULT value);

  // optional .pb.ACCOUNT_TYPE account_type = 2;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 2;
  inline ::pb::ACCOUNT_TYPE account_type() const;
  inline void set_account_type(::pb::ACCOUNT_TYPE value);

  // optional uint64 account_id = 3;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 3;
  inline ::google::protobuf::uint64 account_id() const;
  inline void set_account_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.SAccountCheck)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_account_type();
  inline void clear_has_account_type();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int result_;
  int account_type_;
  ::google::protobuf::uint64 account_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SAccountCheck* default_instance_;
};
// -------------------------------------------------------------------

class CRegisterAccount : public ::google::protobuf::Message {
 public:
  CRegisterAccount();
  virtual ~CRegisterAccount();

  CRegisterAccount(const CRegisterAccount& from);

  inline CRegisterAccount& operator=(const CRegisterAccount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRegisterAccount& default_instance();

  void Swap(CRegisterAccount* other);

  // implements Message ----------------------------------------------

  CRegisterAccount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRegisterAccount& from);
  void MergeFrom(const CRegisterAccount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.REGISTER_ACCOUNT_TYPE type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pb::REGISTER_ACCOUNT_TYPE type() const;
  inline void set_type(::pb::REGISTER_ACCOUNT_TYPE value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string phone_number = 4;
  inline bool has_phone_number() const;
  inline void clear_phone_number();
  static const int kPhoneNumberFieldNumber = 4;
  inline const ::std::string& phone_number() const;
  inline void set_phone_number(const ::std::string& value);
  inline void set_phone_number(const char* value);
  inline void set_phone_number(const char* value, size_t size);
  inline ::std::string* mutable_phone_number();
  inline ::std::string* release_phone_number();
  inline void set_allocated_phone_number(::std::string* phone_number);

  // optional string device_id = 5;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 5;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional uint32 channel_id = 6;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 6;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional uint32 platform_id = 7;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 7;
  inline ::google::protobuf::uint32 platform_id() const;
  inline void set_platform_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.CRegisterAccount)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_phone_number();
  inline void clear_has_phone_number();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* password_;
  int type_;
  ::google::protobuf::uint32 channel_id_;
  ::std::string* phone_number_;
  ::std::string* device_id_;
  ::google::protobuf::uint32 platform_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static CRegisterAccount* default_instance_;
};
// -------------------------------------------------------------------

class SRegisterAccount : public ::google::protobuf::Message {
 public:
  SRegisterAccount();
  virtual ~SRegisterAccount();

  SRegisterAccount(const SRegisterAccount& from);

  inline SRegisterAccount& operator=(const SRegisterAccount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SRegisterAccount& default_instance();

  void Swap(SRegisterAccount* other);

  // implements Message ----------------------------------------------

  SRegisterAccount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SRegisterAccount& from);
  void MergeFrom(const SRegisterAccount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.REGISTER_ACCOUNT_RESULT result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::pb::REGISTER_ACCOUNT_RESULT result() const;
  inline void set_result(::pb::REGISTER_ACCOUNT_RESULT value);

  // optional uint64 account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline ::google::protobuf::uint64 account_id() const;
  inline void set_account_id(::google::protobuf::uint64 value);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:pb.SRegisterAccount)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 account_id_;
  ::std::string* account_;
  ::std::string* password_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SRegisterAccount* default_instance_;
};
// -------------------------------------------------------------------

class CChangeAccountAndPassord : public ::google::protobuf::Message {
 public:
  CChangeAccountAndPassord();
  virtual ~CChangeAccountAndPassord();

  CChangeAccountAndPassord(const CChangeAccountAndPassord& from);

  inline CChangeAccountAndPassord& operator=(const CChangeAccountAndPassord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CChangeAccountAndPassord& default_instance();

  void Swap(CChangeAccountAndPassord* other);

  // implements Message ----------------------------------------------

  CChangeAccountAndPassord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CChangeAccountAndPassord& from);
  void MergeFrom(const CChangeAccountAndPassord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string old_account = 1;
  inline bool has_old_account() const;
  inline void clear_old_account();
  static const int kOldAccountFieldNumber = 1;
  inline const ::std::string& old_account() const;
  inline void set_old_account(const ::std::string& value);
  inline void set_old_account(const char* value);
  inline void set_old_account(const char* value, size_t size);
  inline ::std::string* mutable_old_account();
  inline ::std::string* release_old_account();
  inline void set_allocated_old_account(::std::string* old_account);

  // optional string old_password = 2;
  inline bool has_old_password() const;
  inline void clear_old_password();
  static const int kOldPasswordFieldNumber = 2;
  inline const ::std::string& old_password() const;
  inline void set_old_password(const ::std::string& value);
  inline void set_old_password(const char* value);
  inline void set_old_password(const char* value, size_t size);
  inline ::std::string* mutable_old_password();
  inline ::std::string* release_old_password();
  inline void set_allocated_old_password(::std::string* old_password);

  // optional string new_account = 3;
  inline bool has_new_account() const;
  inline void clear_new_account();
  static const int kNewAccountFieldNumber = 3;
  inline const ::std::string& new_account() const;
  inline void set_new_account(const ::std::string& value);
  inline void set_new_account(const char* value);
  inline void set_new_account(const char* value, size_t size);
  inline ::std::string* mutable_new_account();
  inline ::std::string* release_new_account();
  inline void set_allocated_new_account(::std::string* new_account);

  // optional string new_password = 4;
  inline bool has_new_password() const;
  inline void clear_new_password();
  static const int kNewPasswordFieldNumber = 4;
  inline const ::std::string& new_password() const;
  inline void set_new_password(const ::std::string& value);
  inline void set_new_password(const char* value);
  inline void set_new_password(const char* value, size_t size);
  inline ::std::string* mutable_new_password();
  inline ::std::string* release_new_password();
  inline void set_allocated_new_password(::std::string* new_password);

  // required uint32 channel_id = 5;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 5;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // required uint32 platform_id = 6;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 6;
  inline ::google::protobuf::uint32 platform_id() const;
  inline void set_platform_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.CChangeAccountAndPassord)
 private:
  inline void set_has_old_account();
  inline void clear_has_old_account();
  inline void set_has_old_password();
  inline void clear_has_old_password();
  inline void set_has_new_account();
  inline void clear_has_new_account();
  inline void set_has_new_password();
  inline void clear_has_new_password();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* old_account_;
  ::std::string* old_password_;
  ::std::string* new_account_;
  ::std::string* new_password_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 platform_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static CChangeAccountAndPassord* default_instance_;
};
// -------------------------------------------------------------------

class SChangeAccountAndPassord : public ::google::protobuf::Message {
 public:
  SChangeAccountAndPassord();
  virtual ~SChangeAccountAndPassord();

  SChangeAccountAndPassord(const SChangeAccountAndPassord& from);

  inline SChangeAccountAndPassord& operator=(const SChangeAccountAndPassord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SChangeAccountAndPassord& default_instance();

  void Swap(SChangeAccountAndPassord* other);

  // implements Message ----------------------------------------------

  SChangeAccountAndPassord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SChangeAccountAndPassord& from);
  void MergeFrom(const SChangeAccountAndPassord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.CHANGE_ACCOUNT_PASSWORD_RESULT result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::pb::CHANGE_ACCOUNT_PASSWORD_RESULT result() const;
  inline void set_result(::pb::CHANGE_ACCOUNT_PASSWORD_RESULT value);

  // @@protoc_insertion_point(class_scope:pb.SChangeAccountAndPassord)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SChangeAccountAndPassord* default_instance_;
};
// -------------------------------------------------------------------

class CGetServerList : public ::google::protobuf::Message {
 public:
  CGetServerList();
  virtual ~CGetServerList();

  CGetServerList(const CGetServerList& from);

  inline CGetServerList& operator=(const CGetServerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGetServerList& default_instance();

  void Swap(CGetServerList* other);

  // implements Message ----------------------------------------------

  CGetServerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGetServerList& from);
  void MergeFrom(const CGetServerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint64 account_id() const;
  inline void set_account_id(::google::protobuf::uint64 value);

  // optional uint32 channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional uint32 platform_id = 3;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 3;
  inline ::google::protobuf::uint32 platform_id() const;
  inline void set_platform_id(::google::protobuf::uint32 value);

  // optional uint32 version_id = 4;
  inline bool has_version_id() const;
  inline void clear_version_id();
  static const int kVersionIdFieldNumber = 4;
  inline ::google::protobuf::uint32 version_id() const;
  inline void set_version_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.CGetServerList)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();
  inline void set_has_version_id();
  inline void clear_has_version_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 account_id_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 platform_id_;
  ::google::protobuf::uint32 version_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static CGetServerList* default_instance_;
};
// -------------------------------------------------------------------

class ServerInfo : public ::google::protobuf::Message {
 public:
  ServerInfo();
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfo& default_instance();

  void Swap(ServerInfo* other);

  // implements Message ----------------------------------------------

  ServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 region_id = 1;
  inline bool has_region_id() const;
  inline void clear_region_id();
  static const int kRegionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 region_id() const;
  inline void set_region_id(::google::protobuf::uint32 value);

  // optional uint32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // optional uint32 server_id = 3;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 3;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional .pb.ServerState server_state = 4;
  inline bool has_server_state() const;
  inline void clear_server_state();
  static const int kServerStateFieldNumber = 4;
  inline ::pb::ServerState server_state() const;
  inline void set_server_state(::pb::ServerState value);

  // optional bool is_new = 5;
  inline bool has_is_new() const;
  inline void clear_is_new();
  static const int kIsNewFieldNumber = 5;
  inline bool is_new() const;
  inline void set_is_new(bool value);

  // @@protoc_insertion_point(class_scope:pb.ServerInfo)
 private:
  inline void set_has_region_id();
  inline void clear_has_region_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_server_state();
  inline void clear_has_server_state();
  inline void set_has_is_new();
  inline void clear_has_is_new();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 region_id_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 server_id_;
  int server_state_;
  bool is_new_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static ServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class SGetServerList : public ::google::protobuf::Message {
 public:
  SGetServerList();
  virtual ~SGetServerList();

  SGetServerList(const SGetServerList& from);

  inline SGetServerList& operator=(const SGetServerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SGetServerList& default_instance();

  void Swap(SGetServerList* other);

  // implements Message ----------------------------------------------

  SGetServerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SGetServerList& from);
  void MergeFrom(const SGetServerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 region_id = 1;
  inline bool has_region_id() const;
  inline void clear_region_id();
  static const int kRegionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 region_id() const;
  inline void set_region_id(::google::protobuf::uint32 value);

  // optional uint32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // optional uint32 server_id = 3;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 3;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // repeated .pb.ServerInfo server_info = 4;
  inline int server_info_size() const;
  inline void clear_server_info();
  static const int kServerInfoFieldNumber = 4;
  inline const ::pb::ServerInfo& server_info(int index) const;
  inline ::pb::ServerInfo* mutable_server_info(int index);
  inline ::pb::ServerInfo* add_server_info();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::ServerInfo >&
      server_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::ServerInfo >*
      mutable_server_info();

  // @@protoc_insertion_point(class_scope:pb.SGetServerList)
 private:
  inline void set_has_region_id();
  inline void clear_has_region_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 region_id_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::RepeatedPtrField< ::pb::ServerInfo > server_info_;
  ::google::protobuf::uint32 server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SGetServerList* default_instance_;
};
// -------------------------------------------------------------------

class CSelectServerId : public ::google::protobuf::Message {
 public:
  CSelectServerId();
  virtual ~CSelectServerId();

  CSelectServerId(const CSelectServerId& from);

  inline CSelectServerId& operator=(const CSelectServerId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSelectServerId& default_instance();

  void Swap(CSelectServerId* other);

  // implements Message ----------------------------------------------

  CSelectServerId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSelectServerId& from);
  void MergeFrom(const CSelectServerId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 region_id = 1;
  inline bool has_region_id() const;
  inline void clear_region_id();
  static const int kRegionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 region_id() const;
  inline void set_region_id(::google::protobuf::uint32 value);

  // optional uint32 server_id = 2;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint64 account_id = 3;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 3;
  inline ::google::protobuf::uint64 account_id() const;
  inline void set_account_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.CSelectServerId)
 private:
  inline void set_has_region_id();
  inline void clear_has_region_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 region_id_;
  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint64 account_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static CSelectServerId* default_instance_;
};
// -------------------------------------------------------------------

class SSelectServerId : public ::google::protobuf::Message {
 public:
  SSelectServerId();
  virtual ~SSelectServerId();

  SSelectServerId(const SSelectServerId& from);

  inline SSelectServerId& operator=(const SSelectServerId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSelectServerId& default_instance();

  void Swap(SSelectServerId* other);

  // implements Message ----------------------------------------------

  SSelectServerId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SSelectServerId& from);
  void MergeFrom(const SSelectServerId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.ASK_SELECTSERVERID_RESULT result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::pb::ASK_SELECTSERVERID_RESULT result() const;
  inline void set_result(::pb::ASK_SELECTSERVERID_RESULT value);

  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline const ::std::string& port() const;
  inline void set_port(const ::std::string& value);
  inline void set_port(const char* value);
  inline void set_port(const char* value, size_t size);
  inline ::std::string* mutable_port();
  inline ::std::string* release_port();
  inline void set_allocated_port(::std::string* port);

  // optional string session_key = 4;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 4;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const char* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // optional uint64 key_value = 5;
  inline bool has_key_value() const;
  inline void clear_key_value();
  static const int kKeyValueFieldNumber = 5;
  inline ::google::protobuf::uint64 key_value() const;
  inline void set_key_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.SSelectServerId)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_key_value();
  inline void clear_has_key_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::std::string* port_;
  ::std::string* session_key_;
  ::google::protobuf::uint64 key_value_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SSelectServerId* default_instance_;
};
// -------------------------------------------------------------------

class CGetPlayerList : public ::google::protobuf::Message {
 public:
  CGetPlayerList();
  virtual ~CGetPlayerList();

  CGetPlayerList(const CGetPlayerList& from);

  inline CGetPlayerList& operator=(const CGetPlayerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGetPlayerList& default_instance();

  void Swap(CGetPlayerList* other);

  // implements Message ----------------------------------------------

  CGetPlayerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGetPlayerList& from);
  void MergeFrom(const CGetPlayerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint64 account_id() const;
  inline void set_account_id(::google::protobuf::uint64 value);

  // optional string session_key = 2;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 2;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const char* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // optional uint64 key_value = 3;
  inline bool has_key_value() const;
  inline void clear_key_value();
  static const int kKeyValueFieldNumber = 3;
  inline ::google::protobuf::uint64 key_value() const;
  inline void set_key_value(::google::protobuf::uint64 value);

  // optional string account = 4;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:pb.CGetPlayerList)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_key_value();
  inline void clear_has_key_value();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 account_id_;
  ::std::string* session_key_;
  ::google::protobuf::uint64 key_value_;
  ::std::string* account_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static CGetPlayerList* default_instance_;
};
// -------------------------------------------------------------------

class PlayerListInfo : public ::google::protobuf::Message {
 public:
  PlayerListInfo();
  virtual ~PlayerListInfo();

  PlayerListInfo(const PlayerListInfo& from);

  inline PlayerListInfo& operator=(const PlayerListInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerListInfo& default_instance();

  void Swap(PlayerListInfo* other);

  // implements Message ----------------------------------------------

  PlayerListInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerListInfo& from);
  void MergeFrom(const PlayerListInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 slot = 2;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 2;
  inline ::google::protobuf::int32 slot() const;
  inline void set_slot(::google::protobuf::int32 value);

  // required uint64 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::uint64 player_id() const;
  inline void set_player_id(::google::protobuf::uint64 value);

  // optional uint32 head_icon = 4;
  inline bool has_head_icon() const;
  inline void clear_head_icon();
  static const int kHeadIconFieldNumber = 4;
  inline ::google::protobuf::uint32 head_icon() const;
  inline void set_head_icon(::google::protobuf::uint32 value);

  // optional uint32 country_id = 5;
  inline bool has_country_id() const;
  inline void clear_country_id();
  static const int kCountryIdFieldNumber = 5;
  inline ::google::protobuf::uint32 country_id() const;
  inline void set_country_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.PlayerListInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_slot();
  inline void clear_has_slot();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_head_icon();
  inline void clear_has_head_icon();
  inline void set_has_country_id();
  inline void clear_has_country_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 player_id_;
  ::google::protobuf::int32 slot_;
  ::google::protobuf::uint32 head_icon_;
  ::google::protobuf::uint32 country_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static PlayerListInfo* default_instance_;
};
// -------------------------------------------------------------------

class SGetPlayerList : public ::google::protobuf::Message {
 public:
  SGetPlayerList();
  virtual ~SGetPlayerList();

  SGetPlayerList(const SGetPlayerList& from);

  inline SGetPlayerList& operator=(const SGetPlayerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SGetPlayerList& default_instance();

  void Swap(SGetPlayerList* other);

  // implements Message ----------------------------------------------

  SGetPlayerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SGetPlayerList& from);
  void MergeFrom(const SGetPlayerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.GET_PLAYER_LIST_RESULT result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::pb::GET_PLAYER_LIST_RESULT result() const;
  inline void set_result(::pb::GET_PLAYER_LIST_RESULT value);

  // repeated .pb.PlayerListInfo player_infos = 2;
  inline int player_infos_size() const;
  inline void clear_player_infos();
  static const int kPlayerInfosFieldNumber = 2;
  inline const ::pb::PlayerListInfo& player_infos(int index) const;
  inline ::pb::PlayerListInfo* mutable_player_infos(int index);
  inline ::pb::PlayerListInfo* add_player_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PlayerListInfo >&
      player_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PlayerListInfo >*
      mutable_player_infos();

  // @@protoc_insertion_point(class_scope:pb.SGetPlayerList)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::PlayerListInfo > player_infos_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SGetPlayerList* default_instance_;
};
// -------------------------------------------------------------------

class CCreateChar : public ::google::protobuf::Message {
 public:
  CCreateChar();
  virtual ~CCreateChar();

  CCreateChar(const CCreateChar& from);

  inline CCreateChar& operator=(const CCreateChar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCreateChar& default_instance();

  void Swap(CCreateChar* other);

  // implements Message ----------------------------------------------

  CCreateChar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCreateChar& from);
  void MergeFrom(const CCreateChar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional uint32 card_solution_id = 3;
  inline bool has_card_solution_id() const;
  inline void clear_card_solution_id();
  static const int kCardSolutionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 card_solution_id() const;
  inline void set_card_solution_id(::google::protobuf::uint32 value);

  // optional string sdk_user_id = 4;
  inline bool has_sdk_user_id() const;
  inline void clear_sdk_user_id();
  static const int kSdkUserIdFieldNumber = 4;
  inline const ::std::string& sdk_user_id() const;
  inline void set_sdk_user_id(const ::std::string& value);
  inline void set_sdk_user_id(const char* value);
  inline void set_sdk_user_id(const char* value, size_t size);
  inline ::std::string* mutable_sdk_user_id();
  inline ::std::string* release_sdk_user_id();
  inline void set_allocated_sdk_user_id(::std::string* sdk_user_id);

  // optional uint32 platform_id = 5;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 5;
  inline ::google::protobuf::uint32 platform_id() const;
  inline void set_platform_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.CCreateChar)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_card_solution_id();
  inline void clear_has_card_solution_id();
  inline void set_has_sdk_user_id();
  inline void clear_has_sdk_user_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 card_solution_id_;
  ::std::string* sdk_user_id_;
  ::google::protobuf::uint32 platform_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static CCreateChar* default_instance_;
};
// -------------------------------------------------------------------

class MSG_ChangeName : public ::google::protobuf::Message {
 public:
  MSG_ChangeName();
  virtual ~MSG_ChangeName();

  MSG_ChangeName(const MSG_ChangeName& from);

  inline MSG_ChangeName& operator=(const MSG_ChangeName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_ChangeName& default_instance();

  void Swap(MSG_ChangeName* other);

  // implements Message ----------------------------------------------

  MSG_ChangeName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_ChangeName& from);
  void MergeFrom(const MSG_ChangeName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 err_code = 2;
  inline bool has_err_code() const;
  inline void clear_err_code();
  static const int kErrCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 err_code() const;
  inline void set_err_code(::google::protobuf::uint32 value);

  // optional uint64 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::uint64 player_id() const;
  inline void set_player_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.MSG_ChangeName)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_err_code();
  inline void clear_has_err_code();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 player_id_;
  ::google::protobuf::uint32 err_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static MSG_ChangeName* default_instance_;
};
// -------------------------------------------------------------------

class MSG_SetNameAndHeadId : public ::google::protobuf::Message {
 public:
  MSG_SetNameAndHeadId();
  virtual ~MSG_SetNameAndHeadId();

  MSG_SetNameAndHeadId(const MSG_SetNameAndHeadId& from);

  inline MSG_SetNameAndHeadId& operator=(const MSG_SetNameAndHeadId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_SetNameAndHeadId& default_instance();

  void Swap(MSG_SetNameAndHeadId* other);

  // implements Message ----------------------------------------------

  MSG_SetNameAndHeadId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_SetNameAndHeadId& from);
  void MergeFrom(const MSG_SetNameAndHeadId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 head_id = 2;
  inline bool has_head_id() const;
  inline void clear_head_id();
  static const int kHeadIdFieldNumber = 2;
  inline ::google::protobuf::uint32 head_id() const;
  inline void set_head_id(::google::protobuf::uint32 value);

  // optional uint64 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::uint64 player_id() const;
  inline void set_player_id(::google::protobuf::uint64 value);

  // optional uint32 err_code = 4;
  inline bool has_err_code() const;
  inline void clear_err_code();
  static const int kErrCodeFieldNumber = 4;
  inline ::google::protobuf::uint32 err_code() const;
  inline void set_err_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.MSG_SetNameAndHeadId)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_head_id();
  inline void clear_has_head_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_err_code();
  inline void clear_has_err_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 player_id_;
  ::google::protobuf::uint32 head_id_;
  ::google::protobuf::uint32 err_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static MSG_SetNameAndHeadId* default_instance_;
};
// -------------------------------------------------------------------

class SCreateChar : public ::google::protobuf::Message {
 public:
  SCreateChar();
  virtual ~SCreateChar();

  SCreateChar(const SCreateChar& from);

  inline SCreateChar& operator=(const SCreateChar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCreateChar& default_instance();

  void Swap(SCreateChar* other);

  // implements Message ----------------------------------------------

  SCreateChar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCreateChar& from);
  void MergeFrom(const SCreateChar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.CREATE_PLAYER_RESULT result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::pb::CREATE_PLAYER_RESULT result() const;
  inline void set_result(::pb::CREATE_PLAYER_RESULT value);

  // optional uint64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint64 player_id() const;
  inline void set_player_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.SCreateChar)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 player_id_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SCreateChar* default_instance_;
};
// -------------------------------------------------------------------

class SCreateCharRes : public ::google::protobuf::Message {
 public:
  SCreateCharRes();
  virtual ~SCreateCharRes();

  SCreateCharRes(const SCreateCharRes& from);

  inline SCreateCharRes& operator=(const SCreateCharRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCreateCharRes& default_instance();

  void Swap(SCreateCharRes* other);

  // implements Message ----------------------------------------------

  SCreateCharRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCreateCharRes& from);
  void MergeFrom(const SCreateCharRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.SCreateChar res = 1;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 1;
  inline const ::pb::SCreateChar& res() const;
  inline ::pb::SCreateChar* mutable_res();
  inline ::pb::SCreateChar* release_res();
  inline void set_allocated_res(::pb::SCreateChar* res);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 channel_id = 3;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 3;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional string sdk_user_id = 4;
  inline bool has_sdk_user_id() const;
  inline void clear_sdk_user_id();
  static const int kSdkUserIdFieldNumber = 4;
  inline const ::std::string& sdk_user_id() const;
  inline void set_sdk_user_id(const ::std::string& value);
  inline void set_sdk_user_id(const char* value);
  inline void set_sdk_user_id(const char* value, size_t size);
  inline ::std::string* mutable_sdk_user_id();
  inline ::std::string* release_sdk_user_id();
  inline void set_allocated_sdk_user_id(::std::string* sdk_user_id);

  // optional uint32 platform_id = 5;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 5;
  inline ::google::protobuf::uint32 platform_id() const;
  inline void set_platform_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.SCreateCharRes)
 private:
  inline void set_has_res();
  inline void clear_has_res();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_sdk_user_id();
  inline void clear_has_sdk_user_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::SCreateChar* res_;
  ::std::string* name_;
  ::std::string* sdk_user_id_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 platform_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SCreateCharRes* default_instance_;
};
// -------------------------------------------------------------------

class CSlectPlayer : public ::google::protobuf::Message {
 public:
  CSlectPlayer();
  virtual ~CSlectPlayer();

  CSlectPlayer(const CSlectPlayer& from);

  inline CSlectPlayer& operator=(const CSlectPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSlectPlayer& default_instance();

  void Swap(CSlectPlayer* other);

  // implements Message ----------------------------------------------

  CSlectPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSlectPlayer& from);
  void MergeFrom(const CSlectPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 player_id() const;
  inline void set_player_id(::google::protobuf::uint64 value);

  // optional uint32 platform_id = 2;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 2;
  inline ::google::protobuf::uint32 platform_id() const;
  inline void set_platform_id(::google::protobuf::uint32 value);

  // optional uint32 country_id = 3;
  inline bool has_country_id() const;
  inline void clear_country_id();
  static const int kCountryIdFieldNumber = 3;
  inline ::google::protobuf::uint32 country_id() const;
  inline void set_country_id(::google::protobuf::uint32 value);

  // optional uint32 headpic_id = 4;
  inline bool has_headpic_id() const;
  inline void clear_headpic_id();
  static const int kHeadpicIdFieldNumber = 4;
  inline ::google::protobuf::uint32 headpic_id() const;
  inline void set_headpic_id(::google::protobuf::uint32 value);

  // optional uint32 expected_country_id = 5;
  inline bool has_expected_country_id() const;
  inline void clear_expected_country_id();
  static const int kExpectedCountryIdFieldNumber = 5;
  inline ::google::protobuf::uint32 expected_country_id() const;
  inline void set_expected_country_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.CSlectPlayer)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();
  inline void set_has_country_id();
  inline void clear_has_country_id();
  inline void set_has_headpic_id();
  inline void clear_has_headpic_id();
  inline void set_has_expected_country_id();
  inline void clear_has_expected_country_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 player_id_;
  ::google::protobuf::uint32 platform_id_;
  ::google::protobuf::uint32 country_id_;
  ::google::protobuf::uint32 headpic_id_;
  ::google::protobuf::uint32 expected_country_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static CSlectPlayer* default_instance_;
};
// -------------------------------------------------------------------

class SSlectPlayer : public ::google::protobuf::Message {
 public:
  SSlectPlayer();
  virtual ~SSlectPlayer();

  SSlectPlayer(const SSlectPlayer& from);

  inline SSlectPlayer& operator=(const SSlectPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSlectPlayer& default_instance();

  void Swap(SSlectPlayer* other);

  // implements Message ----------------------------------------------

  SSlectPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SSlectPlayer& from);
  void MergeFrom(const SSlectPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.SELECT_PLAYER_RESULT result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::pb::SELECT_PLAYER_RESULT result() const;
  inline void set_result(::pb::SELECT_PLAYER_RESULT value);

  // optional .pb.PlayerAllData player_data = 2;
  inline bool has_player_data() const;
  inline void clear_player_data();
  static const int kPlayerDataFieldNumber = 2;
  inline const ::pb::PlayerAllData& player_data() const;
  inline ::pb::PlayerAllData* mutable_player_data();
  inline ::pb::PlayerAllData* release_player_data();
  inline void set_allocated_player_data(::pb::PlayerAllData* player_data);

  // optional bool is_quick_login = 3;
  inline bool has_is_quick_login() const;
  inline void clear_is_quick_login();
  static const int kIsQuickLoginFieldNumber = 3;
  inline bool is_quick_login() const;
  inline void set_is_quick_login(bool value);

  // optional uint32 country_id = 4;
  inline bool has_country_id() const;
  inline void clear_country_id();
  static const int kCountryIdFieldNumber = 4;
  inline ::google::protobuf::uint32 country_id() const;
  inline void set_country_id(::google::protobuf::uint32 value);

  // optional uint32 headpic_id = 5;
  inline bool has_headpic_id() const;
  inline void clear_headpic_id();
  static const int kHeadpicIdFieldNumber = 5;
  inline ::google::protobuf::uint32 headpic_id() const;
  inline void set_headpic_id(::google::protobuf::uint32 value);

  // optional uint32 expected_country_id = 6;
  inline bool has_expected_country_id() const;
  inline void clear_expected_country_id();
  static const int kExpectedCountryIdFieldNumber = 6;
  inline ::google::protobuf::uint32 expected_country_id() const;
  inline void set_expected_country_id(::google::protobuf::uint32 value);

  // required uint64 player_id = 7;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 7;
  inline ::google::protobuf::uint64 player_id() const;
  inline void set_player_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.SSlectPlayer)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_player_data();
  inline void clear_has_player_data();
  inline void set_has_is_quick_login();
  inline void clear_has_is_quick_login();
  inline void set_has_country_id();
  inline void clear_has_country_id();
  inline void set_has_headpic_id();
  inline void clear_has_headpic_id();
  inline void set_has_expected_country_id();
  inline void clear_has_expected_country_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::PlayerAllData* player_data_;
  int result_;
  bool is_quick_login_;
  ::google::protobuf::uint32 country_id_;
  ::google::protobuf::uint32 headpic_id_;
  ::google::protobuf::uint64 player_id_;
  ::google::protobuf::uint32 expected_country_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SSlectPlayer* default_instance_;
};
// -------------------------------------------------------------------

class SGuideProcess : public ::google::protobuf::Message {
 public:
  SGuideProcess();
  virtual ~SGuideProcess();

  SGuideProcess(const SGuideProcess& from);

  inline SGuideProcess& operator=(const SGuideProcess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SGuideProcess& default_instance();

  void Swap(SGuideProcess* other);

  // implements Message ----------------------------------------------

  SGuideProcess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SGuideProcess& from);
  void MergeFrom(const SGuideProcess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_need_guide = 1;
  inline bool has_is_need_guide() const;
  inline void clear_is_need_guide();
  static const int kIsNeedGuideFieldNumber = 1;
  inline bool is_need_guide() const;
  inline void set_is_need_guide(bool value);

  // required bool is_finished_guide = 2;
  inline bool has_is_finished_guide() const;
  inline void clear_is_finished_guide();
  static const int kIsFinishedGuideFieldNumber = 2;
  inline bool is_finished_guide() const;
  inline void set_is_finished_guide(bool value);

  // required uint32 cur_process = 3;
  inline bool has_cur_process() const;
  inline void clear_cur_process();
  static const int kCurProcessFieldNumber = 3;
  inline ::google::protobuf::uint32 cur_process() const;
  inline void set_cur_process(::google::protobuf::uint32 value);

  // optional uint32 left_precess = 4;
  inline bool has_left_precess() const;
  inline void clear_left_precess();
  static const int kLeftPrecessFieldNumber = 4;
  inline ::google::protobuf::uint32 left_precess() const;
  inline void set_left_precess(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.SGuideProcess)
 private:
  inline void set_has_is_need_guide();
  inline void clear_has_is_need_guide();
  inline void set_has_is_finished_guide();
  inline void clear_has_is_finished_guide();
  inline void set_has_cur_process();
  inline void clear_has_cur_process();
  inline void set_has_left_precess();
  inline void clear_has_left_precess();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_need_guide_;
  bool is_finished_guide_;
  ::google::protobuf::uint32 cur_process_;
  ::google::protobuf::uint32 left_precess_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static SGuideProcess* default_instance_;
};
// ===================================================================


// ===================================================================

// CVersionCheck

// required uint32 channel_id = 1;
inline bool CVersionCheck::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CVersionCheck::set_has_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CVersionCheck::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CVersionCheck::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 CVersionCheck::channel_id() const {
  return channel_id_;
}
inline void CVersionCheck::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// required uint32 platform_id = 2;
inline bool CVersionCheck::has_platform_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CVersionCheck::set_has_platform_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CVersionCheck::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CVersionCheck::clear_platform_id() {
  platform_id_ = 0u;
  clear_has_platform_id();
}
inline ::google::protobuf::uint32 CVersionCheck::platform_id() const {
  return platform_id_;
}
inline void CVersionCheck::set_platform_id(::google::protobuf::uint32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// required uint32 version_id = 3;
inline bool CVersionCheck::has_version_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CVersionCheck::set_has_version_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CVersionCheck::clear_has_version_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CVersionCheck::clear_version_id() {
  version_id_ = 0u;
  clear_has_version_id();
}
inline ::google::protobuf::uint32 CVersionCheck::version_id() const {
  return version_id_;
}
inline void CVersionCheck::set_version_id(::google::protobuf::uint32 value) {
  set_has_version_id();
  version_id_ = value;
}

// required uint32 resource_id = 4;
inline bool CVersionCheck::has_resource_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CVersionCheck::set_has_resource_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CVersionCheck::clear_has_resource_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CVersionCheck::clear_resource_id() {
  resource_id_ = 0u;
  clear_has_resource_id();
}
inline ::google::protobuf::uint32 CVersionCheck::resource_id() const {
  return resource_id_;
}
inline void CVersionCheck::set_resource_id(::google::protobuf::uint32 value) {
  set_has_resource_id();
  resource_id_ = value;
}

// optional string device_id = 5;
inline bool CVersionCheck::has_device_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CVersionCheck::set_has_device_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CVersionCheck::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CVersionCheck::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CVersionCheck::device_id() const {
  return *device_id_;
}
inline void CVersionCheck::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CVersionCheck::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CVersionCheck::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CVersionCheck::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CVersionCheck::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CVersionCheck::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SVersionCheck

// required .pb.VERSION_CHECK_RESULT result = 1;
inline bool SVersionCheck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SVersionCheck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SVersionCheck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SVersionCheck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::pb::VERSION_CHECK_RESULT SVersionCheck::result() const {
  return static_cast< ::pb::VERSION_CHECK_RESULT >(result_);
}
inline void SVersionCheck::set_result(::pb::VERSION_CHECK_RESULT value) {
  assert(::pb::VERSION_CHECK_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional uint32 resource_id = 2;
inline bool SVersionCheck::has_resource_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SVersionCheck::set_has_resource_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SVersionCheck::clear_has_resource_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SVersionCheck::clear_resource_id() {
  resource_id_ = 0u;
  clear_has_resource_id();
}
inline ::google::protobuf::uint32 SVersionCheck::resource_id() const {
  return resource_id_;
}
inline void SVersionCheck::set_resource_id(::google::protobuf::uint32 value) {
  set_has_resource_id();
  resource_id_ = value;
}

// optional string notice_address = 3;
inline bool SVersionCheck::has_notice_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SVersionCheck::set_has_notice_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SVersionCheck::clear_has_notice_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SVersionCheck::clear_notice_address() {
  if (notice_address_ != &::google::protobuf::internal::kEmptyString) {
    notice_address_->clear();
  }
  clear_has_notice_address();
}
inline const ::std::string& SVersionCheck::notice_address() const {
  return *notice_address_;
}
inline void SVersionCheck::set_notice_address(const ::std::string& value) {
  set_has_notice_address();
  if (notice_address_ == &::google::protobuf::internal::kEmptyString) {
    notice_address_ = new ::std::string;
  }
  notice_address_->assign(value);
}
inline void SVersionCheck::set_notice_address(const char* value) {
  set_has_notice_address();
  if (notice_address_ == &::google::protobuf::internal::kEmptyString) {
    notice_address_ = new ::std::string;
  }
  notice_address_->assign(value);
}
inline void SVersionCheck::set_notice_address(const char* value, size_t size) {
  set_has_notice_address();
  if (notice_address_ == &::google::protobuf::internal::kEmptyString) {
    notice_address_ = new ::std::string;
  }
  notice_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SVersionCheck::mutable_notice_address() {
  set_has_notice_address();
  if (notice_address_ == &::google::protobuf::internal::kEmptyString) {
    notice_address_ = new ::std::string;
  }
  return notice_address_;
}
inline ::std::string* SVersionCheck::release_notice_address() {
  clear_has_notice_address();
  if (notice_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_address_;
    notice_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SVersionCheck::set_allocated_notice_address(::std::string* notice_address) {
  if (notice_address_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_address_;
  }
  if (notice_address) {
    set_has_notice_address();
    notice_address_ = notice_address;
  } else {
    clear_has_notice_address();
    notice_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resource_address = 4;
inline bool SVersionCheck::has_resource_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SVersionCheck::set_has_resource_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SVersionCheck::clear_has_resource_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SVersionCheck::clear_resource_address() {
  if (resource_address_ != &::google::protobuf::internal::kEmptyString) {
    resource_address_->clear();
  }
  clear_has_resource_address();
}
inline const ::std::string& SVersionCheck::resource_address() const {
  return *resource_address_;
}
inline void SVersionCheck::set_resource_address(const ::std::string& value) {
  set_has_resource_address();
  if (resource_address_ == &::google::protobuf::internal::kEmptyString) {
    resource_address_ = new ::std::string;
  }
  resource_address_->assign(value);
}
inline void SVersionCheck::set_resource_address(const char* value) {
  set_has_resource_address();
  if (resource_address_ == &::google::protobuf::internal::kEmptyString) {
    resource_address_ = new ::std::string;
  }
  resource_address_->assign(value);
}
inline void SVersionCheck::set_resource_address(const char* value, size_t size) {
  set_has_resource_address();
  if (resource_address_ == &::google::protobuf::internal::kEmptyString) {
    resource_address_ = new ::std::string;
  }
  resource_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SVersionCheck::mutable_resource_address() {
  set_has_resource_address();
  if (resource_address_ == &::google::protobuf::internal::kEmptyString) {
    resource_address_ = new ::std::string;
  }
  return resource_address_;
}
inline ::std::string* SVersionCheck::release_resource_address() {
  clear_has_resource_address();
  if (resource_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_address_;
    resource_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SVersionCheck::set_allocated_resource_address(::std::string* resource_address) {
  if (resource_address_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_address_;
  }
  if (resource_address) {
    set_has_resource_address();
    resource_address_ = resource_address;
  } else {
    clear_has_resource_address();
    resource_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 is_hot_update = 5;
inline bool SVersionCheck::has_is_hot_update() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SVersionCheck::set_has_is_hot_update() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SVersionCheck::clear_has_is_hot_update() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SVersionCheck::clear_is_hot_update() {
  is_hot_update_ = 0u;
  clear_has_is_hot_update();
}
inline ::google::protobuf::uint32 SVersionCheck::is_hot_update() const {
  return is_hot_update_;
}
inline void SVersionCheck::set_is_hot_update(::google::protobuf::uint32 value) {
  set_has_is_hot_update();
  is_hot_update_ = value;
}

// optional string newest_version_address = 6;
inline bool SVersionCheck::has_newest_version_address() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SVersionCheck::set_has_newest_version_address() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SVersionCheck::clear_has_newest_version_address() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SVersionCheck::clear_newest_version_address() {
  if (newest_version_address_ != &::google::protobuf::internal::kEmptyString) {
    newest_version_address_->clear();
  }
  clear_has_newest_version_address();
}
inline const ::std::string& SVersionCheck::newest_version_address() const {
  return *newest_version_address_;
}
inline void SVersionCheck::set_newest_version_address(const ::std::string& value) {
  set_has_newest_version_address();
  if (newest_version_address_ == &::google::protobuf::internal::kEmptyString) {
    newest_version_address_ = new ::std::string;
  }
  newest_version_address_->assign(value);
}
inline void SVersionCheck::set_newest_version_address(const char* value) {
  set_has_newest_version_address();
  if (newest_version_address_ == &::google::protobuf::internal::kEmptyString) {
    newest_version_address_ = new ::std::string;
  }
  newest_version_address_->assign(value);
}
inline void SVersionCheck::set_newest_version_address(const char* value, size_t size) {
  set_has_newest_version_address();
  if (newest_version_address_ == &::google::protobuf::internal::kEmptyString) {
    newest_version_address_ = new ::std::string;
  }
  newest_version_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SVersionCheck::mutable_newest_version_address() {
  set_has_newest_version_address();
  if (newest_version_address_ == &::google::protobuf::internal::kEmptyString) {
    newest_version_address_ = new ::std::string;
  }
  return newest_version_address_;
}
inline ::std::string* SVersionCheck::release_newest_version_address() {
  clear_has_newest_version_address();
  if (newest_version_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newest_version_address_;
    newest_version_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SVersionCheck::set_allocated_newest_version_address(::std::string* newest_version_address) {
  if (newest_version_address_ != &::google::protobuf::internal::kEmptyString) {
    delete newest_version_address_;
  }
  if (newest_version_address) {
    set_has_newest_version_address();
    newest_version_address_ = newest_version_address;
  } else {
    clear_has_newest_version_address();
    newest_version_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float apk_size = 7;
inline bool SVersionCheck::has_apk_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SVersionCheck::set_has_apk_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SVersionCheck::clear_has_apk_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SVersionCheck::clear_apk_size() {
  apk_size_ = 0;
  clear_has_apk_size();
}
inline float SVersionCheck::apk_size() const {
  return apk_size_;
}
inline void SVersionCheck::set_apk_size(float value) {
  set_has_apk_size();
  apk_size_ = value;
}

// -------------------------------------------------------------------

// CVstarGameAccountCheck

// optional string client_id = 1;
inline bool CVstarGameAccountCheck::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CVstarGameAccountCheck::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CVstarGameAccountCheck::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CVstarGameAccountCheck::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::kEmptyString) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& CVstarGameAccountCheck::client_id() const {
  return *client_id_;
}
inline void CVstarGameAccountCheck::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void CVstarGameAccountCheck::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void CVstarGameAccountCheck::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CVstarGameAccountCheck::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  return client_id_;
}
inline ::std::string* CVstarGameAccountCheck::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CVstarGameAccountCheck::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::kEmptyString) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sdk_user_id = 2;
inline bool CVstarGameAccountCheck::has_sdk_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CVstarGameAccountCheck::set_has_sdk_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CVstarGameAccountCheck::clear_has_sdk_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CVstarGameAccountCheck::clear_sdk_user_id() {
  if (sdk_user_id_ != &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_->clear();
  }
  clear_has_sdk_user_id();
}
inline const ::std::string& CVstarGameAccountCheck::sdk_user_id() const {
  return *sdk_user_id_;
}
inline void CVstarGameAccountCheck::set_sdk_user_id(const ::std::string& value) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(value);
}
inline void CVstarGameAccountCheck::set_sdk_user_id(const char* value) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(value);
}
inline void CVstarGameAccountCheck::set_sdk_user_id(const char* value, size_t size) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CVstarGameAccountCheck::mutable_sdk_user_id() {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  return sdk_user_id_;
}
inline ::std::string* CVstarGameAccountCheck::release_sdk_user_id() {
  clear_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdk_user_id_;
    sdk_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CVstarGameAccountCheck::set_allocated_sdk_user_id(::std::string* sdk_user_id) {
  if (sdk_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_user_id_;
  }
  if (sdk_user_id) {
    set_has_sdk_user_id();
    sdk_user_id_ = sdk_user_id;
  } else {
    clear_has_sdk_user_id();
    sdk_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 3;
inline bool CVstarGameAccountCheck::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CVstarGameAccountCheck::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CVstarGameAccountCheck::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CVstarGameAccountCheck::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CVstarGameAccountCheck::token() const {
  return *token_;
}
inline void CVstarGameAccountCheck::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CVstarGameAccountCheck::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CVstarGameAccountCheck::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CVstarGameAccountCheck::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CVstarGameAccountCheck::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CVstarGameAccountCheck::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pb.CRegisterAccount register_info = 4;
inline bool CVstarGameAccountCheck::has_register_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CVstarGameAccountCheck::set_has_register_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CVstarGameAccountCheck::clear_has_register_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CVstarGameAccountCheck::clear_register_info() {
  if (register_info_ != NULL) register_info_->::pb::CRegisterAccount::Clear();
  clear_has_register_info();
}
inline const ::pb::CRegisterAccount& CVstarGameAccountCheck::register_info() const {
  return register_info_ != NULL ? *register_info_ : *default_instance_->register_info_;
}
inline ::pb::CRegisterAccount* CVstarGameAccountCheck::mutable_register_info() {
  set_has_register_info();
  if (register_info_ == NULL) register_info_ = new ::pb::CRegisterAccount;
  return register_info_;
}
inline ::pb::CRegisterAccount* CVstarGameAccountCheck::release_register_info() {
  clear_has_register_info();
  ::pb::CRegisterAccount* temp = register_info_;
  register_info_ = NULL;
  return temp;
}
inline void CVstarGameAccountCheck::set_allocated_register_info(::pb::CRegisterAccount* register_info) {
  delete register_info_;
  register_info_ = register_info;
  if (register_info) {
    set_has_register_info();
  } else {
    clear_has_register_info();
  }
}

// -------------------------------------------------------------------

// SVstarGameAccountCheck

// optional bool status = 1;
inline bool SVstarGameAccountCheck::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SVstarGameAccountCheck::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SVstarGameAccountCheck::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SVstarGameAccountCheck::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool SVstarGameAccountCheck::status() const {
  return status_;
}
inline void SVstarGameAccountCheck::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// optional string sdk_user_id = 2;
inline bool SVstarGameAccountCheck::has_sdk_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SVstarGameAccountCheck::set_has_sdk_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SVstarGameAccountCheck::clear_has_sdk_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SVstarGameAccountCheck::clear_sdk_user_id() {
  if (sdk_user_id_ != &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_->clear();
  }
  clear_has_sdk_user_id();
}
inline const ::std::string& SVstarGameAccountCheck::sdk_user_id() const {
  return *sdk_user_id_;
}
inline void SVstarGameAccountCheck::set_sdk_user_id(const ::std::string& value) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(value);
}
inline void SVstarGameAccountCheck::set_sdk_user_id(const char* value) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(value);
}
inline void SVstarGameAccountCheck::set_sdk_user_id(const char* value, size_t size) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SVstarGameAccountCheck::mutable_sdk_user_id() {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  return sdk_user_id_;
}
inline ::std::string* SVstarGameAccountCheck::release_sdk_user_id() {
  clear_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdk_user_id_;
    sdk_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SVstarGameAccountCheck::set_allocated_sdk_user_id(::std::string* sdk_user_id) {
  if (sdk_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_user_id_;
  }
  if (sdk_user_id) {
    set_has_sdk_user_id();
    sdk_user_id_ = sdk_user_id;
  } else {
    clear_has_sdk_user_id();
    sdk_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 error_code = 3;
inline bool SVstarGameAccountCheck::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SVstarGameAccountCheck::set_has_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SVstarGameAccountCheck::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SVstarGameAccountCheck::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 SVstarGameAccountCheck::error_code() const {
  return error_code_;
}
inline void SVstarGameAccountCheck::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional string error_msg = 4;
inline bool SVstarGameAccountCheck::has_error_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SVstarGameAccountCheck::set_has_error_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SVstarGameAccountCheck::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SVstarGameAccountCheck::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& SVstarGameAccountCheck::error_msg() const {
  return *error_msg_;
}
inline void SVstarGameAccountCheck::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void SVstarGameAccountCheck::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void SVstarGameAccountCheck::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SVstarGameAccountCheck::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  return error_msg_;
}
inline ::std::string* SVstarGameAccountCheck::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SVstarGameAccountCheck::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete error_msg_;
  }
  if (error_msg) {
    set_has_error_msg();
    error_msg_ = error_msg;
  } else {
    clear_has_error_msg();
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 account_id = 5;
inline bool SVstarGameAccountCheck::has_account_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SVstarGameAccountCheck::set_has_account_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SVstarGameAccountCheck::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SVstarGameAccountCheck::clear_account_id() {
  account_id_ = GOOGLE_ULONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::uint64 SVstarGameAccountCheck::account_id() const {
  return account_id_;
}
inline void SVstarGameAccountCheck::set_account_id(::google::protobuf::uint64 value) {
  set_has_account_id();
  account_id_ = value;
}

// -------------------------------------------------------------------

// CAccountCheck

// required .pb.ACCOUNT_CHECK_METHOD method = 1;
inline bool CAccountCheck::has_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CAccountCheck::set_has_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CAccountCheck::clear_has_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CAccountCheck::clear_method() {
  method_ = 1;
  clear_has_method();
}
inline ::pb::ACCOUNT_CHECK_METHOD CAccountCheck::method() const {
  return static_cast< ::pb::ACCOUNT_CHECK_METHOD >(method_);
}
inline void CAccountCheck::set_method(::pb::ACCOUNT_CHECK_METHOD value) {
  assert(::pb::ACCOUNT_CHECK_METHOD_IsValid(value));
  set_has_method();
  method_ = value;
}

// optional string account = 2;
inline bool CAccountCheck::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CAccountCheck::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CAccountCheck::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CAccountCheck::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CAccountCheck::account() const {
  return *account_;
}
inline void CAccountCheck::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CAccountCheck::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CAccountCheck::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CAccountCheck::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* CAccountCheck::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CAccountCheck::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 3;
inline bool CAccountCheck::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CAccountCheck::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CAccountCheck::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CAccountCheck::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CAccountCheck::password() const {
  return *password_;
}
inline void CAccountCheck::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CAccountCheck::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CAccountCheck::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CAccountCheck::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CAccountCheck::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CAccountCheck::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 channel_id = 4;
inline bool CAccountCheck::has_channel_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CAccountCheck::set_has_channel_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CAccountCheck::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CAccountCheck::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 CAccountCheck::channel_id() const {
  return channel_id_;
}
inline void CAccountCheck::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// required uint32 platform_id = 5;
inline bool CAccountCheck::has_platform_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CAccountCheck::set_has_platform_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CAccountCheck::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CAccountCheck::clear_platform_id() {
  platform_id_ = 0u;
  clear_has_platform_id();
}
inline ::google::protobuf::uint32 CAccountCheck::platform_id() const {
  return platform_id_;
}
inline void CAccountCheck::set_platform_id(::google::protobuf::uint32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// -------------------------------------------------------------------

// SAccountCheck

// required .pb.ACCOUNT_CHECK_RESULT result = 1;
inline bool SAccountCheck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SAccountCheck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SAccountCheck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SAccountCheck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::pb::ACCOUNT_CHECK_RESULT SAccountCheck::result() const {
  return static_cast< ::pb::ACCOUNT_CHECK_RESULT >(result_);
}
inline void SAccountCheck::set_result(::pb::ACCOUNT_CHECK_RESULT value) {
  assert(::pb::ACCOUNT_CHECK_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .pb.ACCOUNT_TYPE account_type = 2;
inline bool SAccountCheck::has_account_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SAccountCheck::set_has_account_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SAccountCheck::clear_has_account_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SAccountCheck::clear_account_type() {
  account_type_ = 0;
  clear_has_account_type();
}
inline ::pb::ACCOUNT_TYPE SAccountCheck::account_type() const {
  return static_cast< ::pb::ACCOUNT_TYPE >(account_type_);
}
inline void SAccountCheck::set_account_type(::pb::ACCOUNT_TYPE value) {
  assert(::pb::ACCOUNT_TYPE_IsValid(value));
  set_has_account_type();
  account_type_ = value;
}

// optional uint64 account_id = 3;
inline bool SAccountCheck::has_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SAccountCheck::set_has_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SAccountCheck::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SAccountCheck::clear_account_id() {
  account_id_ = GOOGLE_ULONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::uint64 SAccountCheck::account_id() const {
  return account_id_;
}
inline void SAccountCheck::set_account_id(::google::protobuf::uint64 value) {
  set_has_account_id();
  account_id_ = value;
}

// -------------------------------------------------------------------

// CRegisterAccount

// required .pb.REGISTER_ACCOUNT_TYPE type = 1;
inline bool CRegisterAccount::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRegisterAccount::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRegisterAccount::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRegisterAccount::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pb::REGISTER_ACCOUNT_TYPE CRegisterAccount::type() const {
  return static_cast< ::pb::REGISTER_ACCOUNT_TYPE >(type_);
}
inline void CRegisterAccount::set_type(::pb::REGISTER_ACCOUNT_TYPE value) {
  assert(::pb::REGISTER_ACCOUNT_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string account = 2;
inline bool CRegisterAccount::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CRegisterAccount::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CRegisterAccount::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CRegisterAccount::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CRegisterAccount::account() const {
  return *account_;
}
inline void CRegisterAccount::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CRegisterAccount::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CRegisterAccount::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRegisterAccount::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* CRegisterAccount::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRegisterAccount::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 3;
inline bool CRegisterAccount::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CRegisterAccount::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CRegisterAccount::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CRegisterAccount::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CRegisterAccount::password() const {
  return *password_;
}
inline void CRegisterAccount::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CRegisterAccount::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CRegisterAccount::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRegisterAccount::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CRegisterAccount::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRegisterAccount::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone_number = 4;
inline bool CRegisterAccount::has_phone_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CRegisterAccount::set_has_phone_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CRegisterAccount::clear_has_phone_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CRegisterAccount::clear_phone_number() {
  if (phone_number_ != &::google::protobuf::internal::kEmptyString) {
    phone_number_->clear();
  }
  clear_has_phone_number();
}
inline const ::std::string& CRegisterAccount::phone_number() const {
  return *phone_number_;
}
inline void CRegisterAccount::set_phone_number(const ::std::string& value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
}
inline void CRegisterAccount::set_phone_number(const char* value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
}
inline void CRegisterAccount::set_phone_number(const char* value, size_t size) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRegisterAccount::mutable_phone_number() {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  return phone_number_;
}
inline ::std::string* CRegisterAccount::release_phone_number() {
  clear_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_number_;
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRegisterAccount::set_allocated_phone_number(::std::string* phone_number) {
  if (phone_number_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_number_;
  }
  if (phone_number) {
    set_has_phone_number();
    phone_number_ = phone_number;
  } else {
    clear_has_phone_number();
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_id = 5;
inline bool CRegisterAccount::has_device_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CRegisterAccount::set_has_device_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CRegisterAccount::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CRegisterAccount::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CRegisterAccount::device_id() const {
  return *device_id_;
}
inline void CRegisterAccount::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CRegisterAccount::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CRegisterAccount::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRegisterAccount::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CRegisterAccount::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRegisterAccount::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 channel_id = 6;
inline bool CRegisterAccount::has_channel_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CRegisterAccount::set_has_channel_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CRegisterAccount::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CRegisterAccount::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 CRegisterAccount::channel_id() const {
  return channel_id_;
}
inline void CRegisterAccount::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// optional uint32 platform_id = 7;
inline bool CRegisterAccount::has_platform_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CRegisterAccount::set_has_platform_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CRegisterAccount::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CRegisterAccount::clear_platform_id() {
  platform_id_ = 0u;
  clear_has_platform_id();
}
inline ::google::protobuf::uint32 CRegisterAccount::platform_id() const {
  return platform_id_;
}
inline void CRegisterAccount::set_platform_id(::google::protobuf::uint32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// -------------------------------------------------------------------

// SRegisterAccount

// required .pb.REGISTER_ACCOUNT_RESULT result = 1;
inline bool SRegisterAccount::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SRegisterAccount::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SRegisterAccount::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SRegisterAccount::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::pb::REGISTER_ACCOUNT_RESULT SRegisterAccount::result() const {
  return static_cast< ::pb::REGISTER_ACCOUNT_RESULT >(result_);
}
inline void SRegisterAccount::set_result(::pb::REGISTER_ACCOUNT_RESULT value) {
  assert(::pb::REGISTER_ACCOUNT_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional uint64 account_id = 2;
inline bool SRegisterAccount::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SRegisterAccount::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SRegisterAccount::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SRegisterAccount::clear_account_id() {
  account_id_ = GOOGLE_ULONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::uint64 SRegisterAccount::account_id() const {
  return account_id_;
}
inline void SRegisterAccount::set_account_id(::google::protobuf::uint64 value) {
  set_has_account_id();
  account_id_ = value;
}

// optional string account = 3;
inline bool SRegisterAccount::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SRegisterAccount::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SRegisterAccount::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SRegisterAccount::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& SRegisterAccount::account() const {
  return *account_;
}
inline void SRegisterAccount::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SRegisterAccount::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SRegisterAccount::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRegisterAccount::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* SRegisterAccount::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SRegisterAccount::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 4;
inline bool SRegisterAccount::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SRegisterAccount::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SRegisterAccount::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SRegisterAccount::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& SRegisterAccount::password() const {
  return *password_;
}
inline void SRegisterAccount::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SRegisterAccount::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SRegisterAccount::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRegisterAccount::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* SRegisterAccount::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SRegisterAccount::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CChangeAccountAndPassord

// optional string old_account = 1;
inline bool CChangeAccountAndPassord::has_old_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CChangeAccountAndPassord::set_has_old_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CChangeAccountAndPassord::clear_has_old_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CChangeAccountAndPassord::clear_old_account() {
  if (old_account_ != &::google::protobuf::internal::kEmptyString) {
    old_account_->clear();
  }
  clear_has_old_account();
}
inline const ::std::string& CChangeAccountAndPassord::old_account() const {
  return *old_account_;
}
inline void CChangeAccountAndPassord::set_old_account(const ::std::string& value) {
  set_has_old_account();
  if (old_account_ == &::google::protobuf::internal::kEmptyString) {
    old_account_ = new ::std::string;
  }
  old_account_->assign(value);
}
inline void CChangeAccountAndPassord::set_old_account(const char* value) {
  set_has_old_account();
  if (old_account_ == &::google::protobuf::internal::kEmptyString) {
    old_account_ = new ::std::string;
  }
  old_account_->assign(value);
}
inline void CChangeAccountAndPassord::set_old_account(const char* value, size_t size) {
  set_has_old_account();
  if (old_account_ == &::google::protobuf::internal::kEmptyString) {
    old_account_ = new ::std::string;
  }
  old_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CChangeAccountAndPassord::mutable_old_account() {
  set_has_old_account();
  if (old_account_ == &::google::protobuf::internal::kEmptyString) {
    old_account_ = new ::std::string;
  }
  return old_account_;
}
inline ::std::string* CChangeAccountAndPassord::release_old_account() {
  clear_has_old_account();
  if (old_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_account_;
    old_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CChangeAccountAndPassord::set_allocated_old_account(::std::string* old_account) {
  if (old_account_ != &::google::protobuf::internal::kEmptyString) {
    delete old_account_;
  }
  if (old_account) {
    set_has_old_account();
    old_account_ = old_account;
  } else {
    clear_has_old_account();
    old_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string old_password = 2;
inline bool CChangeAccountAndPassord::has_old_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CChangeAccountAndPassord::set_has_old_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CChangeAccountAndPassord::clear_has_old_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CChangeAccountAndPassord::clear_old_password() {
  if (old_password_ != &::google::protobuf::internal::kEmptyString) {
    old_password_->clear();
  }
  clear_has_old_password();
}
inline const ::std::string& CChangeAccountAndPassord::old_password() const {
  return *old_password_;
}
inline void CChangeAccountAndPassord::set_old_password(const ::std::string& value) {
  set_has_old_password();
  if (old_password_ == &::google::protobuf::internal::kEmptyString) {
    old_password_ = new ::std::string;
  }
  old_password_->assign(value);
}
inline void CChangeAccountAndPassord::set_old_password(const char* value) {
  set_has_old_password();
  if (old_password_ == &::google::protobuf::internal::kEmptyString) {
    old_password_ = new ::std::string;
  }
  old_password_->assign(value);
}
inline void CChangeAccountAndPassord::set_old_password(const char* value, size_t size) {
  set_has_old_password();
  if (old_password_ == &::google::protobuf::internal::kEmptyString) {
    old_password_ = new ::std::string;
  }
  old_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CChangeAccountAndPassord::mutable_old_password() {
  set_has_old_password();
  if (old_password_ == &::google::protobuf::internal::kEmptyString) {
    old_password_ = new ::std::string;
  }
  return old_password_;
}
inline ::std::string* CChangeAccountAndPassord::release_old_password() {
  clear_has_old_password();
  if (old_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_password_;
    old_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CChangeAccountAndPassord::set_allocated_old_password(::std::string* old_password) {
  if (old_password_ != &::google::protobuf::internal::kEmptyString) {
    delete old_password_;
  }
  if (old_password) {
    set_has_old_password();
    old_password_ = old_password;
  } else {
    clear_has_old_password();
    old_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string new_account = 3;
inline bool CChangeAccountAndPassord::has_new_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CChangeAccountAndPassord::set_has_new_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CChangeAccountAndPassord::clear_has_new_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CChangeAccountAndPassord::clear_new_account() {
  if (new_account_ != &::google::protobuf::internal::kEmptyString) {
    new_account_->clear();
  }
  clear_has_new_account();
}
inline const ::std::string& CChangeAccountAndPassord::new_account() const {
  return *new_account_;
}
inline void CChangeAccountAndPassord::set_new_account(const ::std::string& value) {
  set_has_new_account();
  if (new_account_ == &::google::protobuf::internal::kEmptyString) {
    new_account_ = new ::std::string;
  }
  new_account_->assign(value);
}
inline void CChangeAccountAndPassord::set_new_account(const char* value) {
  set_has_new_account();
  if (new_account_ == &::google::protobuf::internal::kEmptyString) {
    new_account_ = new ::std::string;
  }
  new_account_->assign(value);
}
inline void CChangeAccountAndPassord::set_new_account(const char* value, size_t size) {
  set_has_new_account();
  if (new_account_ == &::google::protobuf::internal::kEmptyString) {
    new_account_ = new ::std::string;
  }
  new_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CChangeAccountAndPassord::mutable_new_account() {
  set_has_new_account();
  if (new_account_ == &::google::protobuf::internal::kEmptyString) {
    new_account_ = new ::std::string;
  }
  return new_account_;
}
inline ::std::string* CChangeAccountAndPassord::release_new_account() {
  clear_has_new_account();
  if (new_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_account_;
    new_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CChangeAccountAndPassord::set_allocated_new_account(::std::string* new_account) {
  if (new_account_ != &::google::protobuf::internal::kEmptyString) {
    delete new_account_;
  }
  if (new_account) {
    set_has_new_account();
    new_account_ = new_account;
  } else {
    clear_has_new_account();
    new_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string new_password = 4;
inline bool CChangeAccountAndPassord::has_new_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CChangeAccountAndPassord::set_has_new_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CChangeAccountAndPassord::clear_has_new_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CChangeAccountAndPassord::clear_new_password() {
  if (new_password_ != &::google::protobuf::internal::kEmptyString) {
    new_password_->clear();
  }
  clear_has_new_password();
}
inline const ::std::string& CChangeAccountAndPassord::new_password() const {
  return *new_password_;
}
inline void CChangeAccountAndPassord::set_new_password(const ::std::string& value) {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::kEmptyString) {
    new_password_ = new ::std::string;
  }
  new_password_->assign(value);
}
inline void CChangeAccountAndPassord::set_new_password(const char* value) {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::kEmptyString) {
    new_password_ = new ::std::string;
  }
  new_password_->assign(value);
}
inline void CChangeAccountAndPassord::set_new_password(const char* value, size_t size) {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::kEmptyString) {
    new_password_ = new ::std::string;
  }
  new_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CChangeAccountAndPassord::mutable_new_password() {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::kEmptyString) {
    new_password_ = new ::std::string;
  }
  return new_password_;
}
inline ::std::string* CChangeAccountAndPassord::release_new_password() {
  clear_has_new_password();
  if (new_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_password_;
    new_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CChangeAccountAndPassord::set_allocated_new_password(::std::string* new_password) {
  if (new_password_ != &::google::protobuf::internal::kEmptyString) {
    delete new_password_;
  }
  if (new_password) {
    set_has_new_password();
    new_password_ = new_password;
  } else {
    clear_has_new_password();
    new_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 channel_id = 5;
inline bool CChangeAccountAndPassord::has_channel_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CChangeAccountAndPassord::set_has_channel_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CChangeAccountAndPassord::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CChangeAccountAndPassord::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 CChangeAccountAndPassord::channel_id() const {
  return channel_id_;
}
inline void CChangeAccountAndPassord::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// required uint32 platform_id = 6;
inline bool CChangeAccountAndPassord::has_platform_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CChangeAccountAndPassord::set_has_platform_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CChangeAccountAndPassord::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CChangeAccountAndPassord::clear_platform_id() {
  platform_id_ = 0u;
  clear_has_platform_id();
}
inline ::google::protobuf::uint32 CChangeAccountAndPassord::platform_id() const {
  return platform_id_;
}
inline void CChangeAccountAndPassord::set_platform_id(::google::protobuf::uint32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// -------------------------------------------------------------------

// SChangeAccountAndPassord

// required .pb.CHANGE_ACCOUNT_PASSWORD_RESULT result = 1;
inline bool SChangeAccountAndPassord::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SChangeAccountAndPassord::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SChangeAccountAndPassord::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SChangeAccountAndPassord::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::pb::CHANGE_ACCOUNT_PASSWORD_RESULT SChangeAccountAndPassord::result() const {
  return static_cast< ::pb::CHANGE_ACCOUNT_PASSWORD_RESULT >(result_);
}
inline void SChangeAccountAndPassord::set_result(::pb::CHANGE_ACCOUNT_PASSWORD_RESULT value) {
  assert(::pb::CHANGE_ACCOUNT_PASSWORD_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// CGetServerList

// required uint64 account_id = 1;
inline bool CGetServerList::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGetServerList::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGetServerList::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGetServerList::clear_account_id() {
  account_id_ = GOOGLE_ULONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::uint64 CGetServerList::account_id() const {
  return account_id_;
}
inline void CGetServerList::set_account_id(::google::protobuf::uint64 value) {
  set_has_account_id();
  account_id_ = value;
}

// optional uint32 channel_id = 2;
inline bool CGetServerList::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGetServerList::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGetServerList::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGetServerList::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 CGetServerList::channel_id() const {
  return channel_id_;
}
inline void CGetServerList::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// optional uint32 platform_id = 3;
inline bool CGetServerList::has_platform_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGetServerList::set_has_platform_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGetServerList::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGetServerList::clear_platform_id() {
  platform_id_ = 0u;
  clear_has_platform_id();
}
inline ::google::protobuf::uint32 CGetServerList::platform_id() const {
  return platform_id_;
}
inline void CGetServerList::set_platform_id(::google::protobuf::uint32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// optional uint32 version_id = 4;
inline bool CGetServerList::has_version_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGetServerList::set_has_version_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGetServerList::clear_has_version_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGetServerList::clear_version_id() {
  version_id_ = 0u;
  clear_has_version_id();
}
inline ::google::protobuf::uint32 CGetServerList::version_id() const {
  return version_id_;
}
inline void CGetServerList::set_version_id(::google::protobuf::uint32 value) {
  set_has_version_id();
  version_id_ = value;
}

// -------------------------------------------------------------------

// ServerInfo

// optional uint32 region_id = 1;
inline bool ServerInfo::has_region_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfo::set_has_region_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfo::clear_has_region_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfo::clear_region_id() {
  region_id_ = 0u;
  clear_has_region_id();
}
inline ::google::protobuf::uint32 ServerInfo::region_id() const {
  return region_id_;
}
inline void ServerInfo::set_region_id(::google::protobuf::uint32 value) {
  set_has_region_id();
  region_id_ = value;
}

// optional uint32 group_id = 2;
inline bool ServerInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 ServerInfo::group_id() const {
  return group_id_;
}
inline void ServerInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional uint32 server_id = 3;
inline bool ServerInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 ServerInfo::server_id() const {
  return server_id_;
}
inline void ServerInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional .pb.ServerState server_state = 4;
inline bool ServerInfo::has_server_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerInfo::set_has_server_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerInfo::clear_has_server_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerInfo::clear_server_state() {
  server_state_ = 0;
  clear_has_server_state();
}
inline ::pb::ServerState ServerInfo::server_state() const {
  return static_cast< ::pb::ServerState >(server_state_);
}
inline void ServerInfo::set_server_state(::pb::ServerState value) {
  assert(::pb::ServerState_IsValid(value));
  set_has_server_state();
  server_state_ = value;
}

// optional bool is_new = 5;
inline bool ServerInfo::has_is_new() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerInfo::set_has_is_new() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerInfo::clear_has_is_new() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerInfo::clear_is_new() {
  is_new_ = false;
  clear_has_is_new();
}
inline bool ServerInfo::is_new() const {
  return is_new_;
}
inline void ServerInfo::set_is_new(bool value) {
  set_has_is_new();
  is_new_ = value;
}

// -------------------------------------------------------------------

// SGetServerList

// optional uint32 region_id = 1;
inline bool SGetServerList::has_region_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SGetServerList::set_has_region_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SGetServerList::clear_has_region_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SGetServerList::clear_region_id() {
  region_id_ = 0u;
  clear_has_region_id();
}
inline ::google::protobuf::uint32 SGetServerList::region_id() const {
  return region_id_;
}
inline void SGetServerList::set_region_id(::google::protobuf::uint32 value) {
  set_has_region_id();
  region_id_ = value;
}

// optional uint32 group_id = 2;
inline bool SGetServerList::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SGetServerList::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SGetServerList::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SGetServerList::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 SGetServerList::group_id() const {
  return group_id_;
}
inline void SGetServerList::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional uint32 server_id = 3;
inline bool SGetServerList::has_server_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SGetServerList::set_has_server_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SGetServerList::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SGetServerList::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 SGetServerList::server_id() const {
  return server_id_;
}
inline void SGetServerList::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// repeated .pb.ServerInfo server_info = 4;
inline int SGetServerList::server_info_size() const {
  return server_info_.size();
}
inline void SGetServerList::clear_server_info() {
  server_info_.Clear();
}
inline const ::pb::ServerInfo& SGetServerList::server_info(int index) const {
  return server_info_.Get(index);
}
inline ::pb::ServerInfo* SGetServerList::mutable_server_info(int index) {
  return server_info_.Mutable(index);
}
inline ::pb::ServerInfo* SGetServerList::add_server_info() {
  return server_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ServerInfo >&
SGetServerList::server_info() const {
  return server_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ServerInfo >*
SGetServerList::mutable_server_info() {
  return &server_info_;
}

// -------------------------------------------------------------------

// CSelectServerId

// optional uint32 region_id = 1;
inline bool CSelectServerId::has_region_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSelectServerId::set_has_region_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSelectServerId::clear_has_region_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSelectServerId::clear_region_id() {
  region_id_ = 0u;
  clear_has_region_id();
}
inline ::google::protobuf::uint32 CSelectServerId::region_id() const {
  return region_id_;
}
inline void CSelectServerId::set_region_id(::google::protobuf::uint32 value) {
  set_has_region_id();
  region_id_ = value;
}

// optional uint32 server_id = 2;
inline bool CSelectServerId::has_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSelectServerId::set_has_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSelectServerId::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSelectServerId::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 CSelectServerId::server_id() const {
  return server_id_;
}
inline void CSelectServerId::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint64 account_id = 3;
inline bool CSelectServerId::has_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSelectServerId::set_has_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSelectServerId::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSelectServerId::clear_account_id() {
  account_id_ = GOOGLE_ULONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::uint64 CSelectServerId::account_id() const {
  return account_id_;
}
inline void CSelectServerId::set_account_id(::google::protobuf::uint64 value) {
  set_has_account_id();
  account_id_ = value;
}

// -------------------------------------------------------------------

// SSelectServerId

// required .pb.ASK_SELECTSERVERID_RESULT result = 1;
inline bool SSelectServerId::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSelectServerId::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSelectServerId::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSelectServerId::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::pb::ASK_SELECTSERVERID_RESULT SSelectServerId::result() const {
  return static_cast< ::pb::ASK_SELECTSERVERID_RESULT >(result_);
}
inline void SSelectServerId::set_result(::pb::ASK_SELECTSERVERID_RESULT value) {
  assert(::pb::ASK_SELECTSERVERID_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional string ip = 2;
inline bool SSelectServerId::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSelectServerId::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSelectServerId::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSelectServerId::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& SSelectServerId::ip() const {
  return *ip_;
}
inline void SSelectServerId::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void SSelectServerId::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void SSelectServerId::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSelectServerId::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* SSelectServerId::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SSelectServerId::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string port = 3;
inline bool SSelectServerId::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SSelectServerId::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SSelectServerId::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SSelectServerId::clear_port() {
  if (port_ != &::google::protobuf::internal::kEmptyString) {
    port_->clear();
  }
  clear_has_port();
}
inline const ::std::string& SSelectServerId::port() const {
  return *port_;
}
inline void SSelectServerId::set_port(const ::std::string& value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(value);
}
inline void SSelectServerId::set_port(const char* value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(value);
}
inline void SSelectServerId::set_port(const char* value, size_t size) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSelectServerId::mutable_port() {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  return port_;
}
inline ::std::string* SSelectServerId::release_port() {
  clear_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = port_;
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SSelectServerId::set_allocated_port(::std::string* port) {
  if (port_ != &::google::protobuf::internal::kEmptyString) {
    delete port_;
  }
  if (port) {
    set_has_port();
    port_ = port;
  } else {
    clear_has_port();
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string session_key = 4;
inline bool SSelectServerId::has_session_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SSelectServerId::set_has_session_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SSelectServerId::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SSelectServerId::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& SSelectServerId::session_key() const {
  return *session_key_;
}
inline void SSelectServerId::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void SSelectServerId::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void SSelectServerId::set_session_key(const char* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSelectServerId::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  return session_key_;
}
inline ::std::string* SSelectServerId::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SSelectServerId::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 key_value = 5;
inline bool SSelectServerId::has_key_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SSelectServerId::set_has_key_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SSelectServerId::clear_has_key_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SSelectServerId::clear_key_value() {
  key_value_ = GOOGLE_ULONGLONG(0);
  clear_has_key_value();
}
inline ::google::protobuf::uint64 SSelectServerId::key_value() const {
  return key_value_;
}
inline void SSelectServerId::set_key_value(::google::protobuf::uint64 value) {
  set_has_key_value();
  key_value_ = value;
}

// -------------------------------------------------------------------

// CGetPlayerList

// required uint64 account_id = 1;
inline bool CGetPlayerList::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGetPlayerList::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGetPlayerList::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGetPlayerList::clear_account_id() {
  account_id_ = GOOGLE_ULONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::uint64 CGetPlayerList::account_id() const {
  return account_id_;
}
inline void CGetPlayerList::set_account_id(::google::protobuf::uint64 value) {
  set_has_account_id();
  account_id_ = value;
}

// optional string session_key = 2;
inline bool CGetPlayerList::has_session_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGetPlayerList::set_has_session_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGetPlayerList::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGetPlayerList::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& CGetPlayerList::session_key() const {
  return *session_key_;
}
inline void CGetPlayerList::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void CGetPlayerList::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void CGetPlayerList::set_session_key(const char* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGetPlayerList::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  return session_key_;
}
inline ::std::string* CGetPlayerList::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGetPlayerList::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 key_value = 3;
inline bool CGetPlayerList::has_key_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGetPlayerList::set_has_key_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGetPlayerList::clear_has_key_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGetPlayerList::clear_key_value() {
  key_value_ = GOOGLE_ULONGLONG(0);
  clear_has_key_value();
}
inline ::google::protobuf::uint64 CGetPlayerList::key_value() const {
  return key_value_;
}
inline void CGetPlayerList::set_key_value(::google::protobuf::uint64 value) {
  set_has_key_value();
  key_value_ = value;
}

// optional string account = 4;
inline bool CGetPlayerList::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGetPlayerList::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGetPlayerList::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGetPlayerList::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CGetPlayerList::account() const {
  return *account_;
}
inline void CGetPlayerList::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CGetPlayerList::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CGetPlayerList::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGetPlayerList::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* CGetPlayerList::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGetPlayerList::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerListInfo

// required string name = 1;
inline bool PlayerListInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerListInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerListInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerListInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayerListInfo::name() const {
  return *name_;
}
inline void PlayerListInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerListInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerListInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerListInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlayerListInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerListInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 slot = 2;
inline bool PlayerListInfo::has_slot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerListInfo::set_has_slot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerListInfo::clear_has_slot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerListInfo::clear_slot() {
  slot_ = 0;
  clear_has_slot();
}
inline ::google::protobuf::int32 PlayerListInfo::slot() const {
  return slot_;
}
inline void PlayerListInfo::set_slot(::google::protobuf::int32 value) {
  set_has_slot();
  slot_ = value;
}

// required uint64 player_id = 3;
inline bool PlayerListInfo::has_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerListInfo::set_has_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerListInfo::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerListInfo::clear_player_id() {
  player_id_ = GOOGLE_ULONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::uint64 PlayerListInfo::player_id() const {
  return player_id_;
}
inline void PlayerListInfo::set_player_id(::google::protobuf::uint64 value) {
  set_has_player_id();
  player_id_ = value;
}

// optional uint32 head_icon = 4;
inline bool PlayerListInfo::has_head_icon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerListInfo::set_has_head_icon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerListInfo::clear_has_head_icon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerListInfo::clear_head_icon() {
  head_icon_ = 0u;
  clear_has_head_icon();
}
inline ::google::protobuf::uint32 PlayerListInfo::head_icon() const {
  return head_icon_;
}
inline void PlayerListInfo::set_head_icon(::google::protobuf::uint32 value) {
  set_has_head_icon();
  head_icon_ = value;
}

// optional uint32 country_id = 5;
inline bool PlayerListInfo::has_country_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerListInfo::set_has_country_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerListInfo::clear_has_country_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerListInfo::clear_country_id() {
  country_id_ = 0u;
  clear_has_country_id();
}
inline ::google::protobuf::uint32 PlayerListInfo::country_id() const {
  return country_id_;
}
inline void PlayerListInfo::set_country_id(::google::protobuf::uint32 value) {
  set_has_country_id();
  country_id_ = value;
}

// -------------------------------------------------------------------

// SGetPlayerList

// required .pb.GET_PLAYER_LIST_RESULT result = 1;
inline bool SGetPlayerList::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SGetPlayerList::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SGetPlayerList::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SGetPlayerList::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::pb::GET_PLAYER_LIST_RESULT SGetPlayerList::result() const {
  return static_cast< ::pb::GET_PLAYER_LIST_RESULT >(result_);
}
inline void SGetPlayerList::set_result(::pb::GET_PLAYER_LIST_RESULT value) {
  assert(::pb::GET_PLAYER_LIST_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
}

// repeated .pb.PlayerListInfo player_infos = 2;
inline int SGetPlayerList::player_infos_size() const {
  return player_infos_.size();
}
inline void SGetPlayerList::clear_player_infos() {
  player_infos_.Clear();
}
inline const ::pb::PlayerListInfo& SGetPlayerList::player_infos(int index) const {
  return player_infos_.Get(index);
}
inline ::pb::PlayerListInfo* SGetPlayerList::mutable_player_infos(int index) {
  return player_infos_.Mutable(index);
}
inline ::pb::PlayerListInfo* SGetPlayerList::add_player_infos() {
  return player_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PlayerListInfo >&
SGetPlayerList::player_infos() const {
  return player_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PlayerListInfo >*
SGetPlayerList::mutable_player_infos() {
  return &player_infos_;
}

// -------------------------------------------------------------------

// CCreateChar

// required string name = 1;
inline bool CCreateChar::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCreateChar::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCreateChar::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCreateChar::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CCreateChar::name() const {
  return *name_;
}
inline void CCreateChar::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CCreateChar::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CCreateChar::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCreateChar::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CCreateChar::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CCreateChar::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 channel_id = 2;
inline bool CCreateChar::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCreateChar::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCreateChar::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCreateChar::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 CCreateChar::channel_id() const {
  return channel_id_;
}
inline void CCreateChar::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// optional uint32 card_solution_id = 3;
inline bool CCreateChar::has_card_solution_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CCreateChar::set_has_card_solution_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CCreateChar::clear_has_card_solution_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CCreateChar::clear_card_solution_id() {
  card_solution_id_ = 0u;
  clear_has_card_solution_id();
}
inline ::google::protobuf::uint32 CCreateChar::card_solution_id() const {
  return card_solution_id_;
}
inline void CCreateChar::set_card_solution_id(::google::protobuf::uint32 value) {
  set_has_card_solution_id();
  card_solution_id_ = value;
}

// optional string sdk_user_id = 4;
inline bool CCreateChar::has_sdk_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CCreateChar::set_has_sdk_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CCreateChar::clear_has_sdk_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CCreateChar::clear_sdk_user_id() {
  if (sdk_user_id_ != &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_->clear();
  }
  clear_has_sdk_user_id();
}
inline const ::std::string& CCreateChar::sdk_user_id() const {
  return *sdk_user_id_;
}
inline void CCreateChar::set_sdk_user_id(const ::std::string& value) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(value);
}
inline void CCreateChar::set_sdk_user_id(const char* value) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(value);
}
inline void CCreateChar::set_sdk_user_id(const char* value, size_t size) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCreateChar::mutable_sdk_user_id() {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  return sdk_user_id_;
}
inline ::std::string* CCreateChar::release_sdk_user_id() {
  clear_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdk_user_id_;
    sdk_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CCreateChar::set_allocated_sdk_user_id(::std::string* sdk_user_id) {
  if (sdk_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_user_id_;
  }
  if (sdk_user_id) {
    set_has_sdk_user_id();
    sdk_user_id_ = sdk_user_id;
  } else {
    clear_has_sdk_user_id();
    sdk_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 platform_id = 5;
inline bool CCreateChar::has_platform_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CCreateChar::set_has_platform_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CCreateChar::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CCreateChar::clear_platform_id() {
  platform_id_ = 0u;
  clear_has_platform_id();
}
inline ::google::protobuf::uint32 CCreateChar::platform_id() const {
  return platform_id_;
}
inline void CCreateChar::set_platform_id(::google::protobuf::uint32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// -------------------------------------------------------------------

// MSG_ChangeName

// required string name = 1;
inline bool MSG_ChangeName::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_ChangeName::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_ChangeName::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_ChangeName::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MSG_ChangeName::name() const {
  return *name_;
}
inline void MSG_ChangeName::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MSG_ChangeName::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MSG_ChangeName::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MSG_ChangeName::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MSG_ChangeName::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MSG_ChangeName::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 err_code = 2;
inline bool MSG_ChangeName::has_err_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MSG_ChangeName::set_has_err_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MSG_ChangeName::clear_has_err_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MSG_ChangeName::clear_err_code() {
  err_code_ = 0u;
  clear_has_err_code();
}
inline ::google::protobuf::uint32 MSG_ChangeName::err_code() const {
  return err_code_;
}
inline void MSG_ChangeName::set_err_code(::google::protobuf::uint32 value) {
  set_has_err_code();
  err_code_ = value;
}

// optional uint64 player_id = 3;
inline bool MSG_ChangeName::has_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MSG_ChangeName::set_has_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MSG_ChangeName::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MSG_ChangeName::clear_player_id() {
  player_id_ = GOOGLE_ULONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::uint64 MSG_ChangeName::player_id() const {
  return player_id_;
}
inline void MSG_ChangeName::set_player_id(::google::protobuf::uint64 value) {
  set_has_player_id();
  player_id_ = value;
}

// -------------------------------------------------------------------

// MSG_SetNameAndHeadId

// required string name = 1;
inline bool MSG_SetNameAndHeadId::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_SetNameAndHeadId::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_SetNameAndHeadId::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_SetNameAndHeadId::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MSG_SetNameAndHeadId::name() const {
  return *name_;
}
inline void MSG_SetNameAndHeadId::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MSG_SetNameAndHeadId::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MSG_SetNameAndHeadId::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MSG_SetNameAndHeadId::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MSG_SetNameAndHeadId::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MSG_SetNameAndHeadId::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 head_id = 2;
inline bool MSG_SetNameAndHeadId::has_head_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MSG_SetNameAndHeadId::set_has_head_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MSG_SetNameAndHeadId::clear_has_head_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MSG_SetNameAndHeadId::clear_head_id() {
  head_id_ = 0u;
  clear_has_head_id();
}
inline ::google::protobuf::uint32 MSG_SetNameAndHeadId::head_id() const {
  return head_id_;
}
inline void MSG_SetNameAndHeadId::set_head_id(::google::protobuf::uint32 value) {
  set_has_head_id();
  head_id_ = value;
}

// optional uint64 player_id = 3;
inline bool MSG_SetNameAndHeadId::has_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MSG_SetNameAndHeadId::set_has_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MSG_SetNameAndHeadId::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MSG_SetNameAndHeadId::clear_player_id() {
  player_id_ = GOOGLE_ULONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::uint64 MSG_SetNameAndHeadId::player_id() const {
  return player_id_;
}
inline void MSG_SetNameAndHeadId::set_player_id(::google::protobuf::uint64 value) {
  set_has_player_id();
  player_id_ = value;
}

// optional uint32 err_code = 4;
inline bool MSG_SetNameAndHeadId::has_err_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MSG_SetNameAndHeadId::set_has_err_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MSG_SetNameAndHeadId::clear_has_err_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MSG_SetNameAndHeadId::clear_err_code() {
  err_code_ = 0u;
  clear_has_err_code();
}
inline ::google::protobuf::uint32 MSG_SetNameAndHeadId::err_code() const {
  return err_code_;
}
inline void MSG_SetNameAndHeadId::set_err_code(::google::protobuf::uint32 value) {
  set_has_err_code();
  err_code_ = value;
}

// -------------------------------------------------------------------

// SCreateChar

// required .pb.CREATE_PLAYER_RESULT result = 1;
inline bool SCreateChar::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SCreateChar::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SCreateChar::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SCreateChar::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::pb::CREATE_PLAYER_RESULT SCreateChar::result() const {
  return static_cast< ::pb::CREATE_PLAYER_RESULT >(result_);
}
inline void SCreateChar::set_result(::pb::CREATE_PLAYER_RESULT value) {
  assert(::pb::CREATE_PLAYER_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional uint64 player_id = 2;
inline bool SCreateChar::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SCreateChar::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SCreateChar::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SCreateChar::clear_player_id() {
  player_id_ = GOOGLE_ULONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::uint64 SCreateChar::player_id() const {
  return player_id_;
}
inline void SCreateChar::set_player_id(::google::protobuf::uint64 value) {
  set_has_player_id();
  player_id_ = value;
}

// -------------------------------------------------------------------

// SCreateCharRes

// required .pb.SCreateChar res = 1;
inline bool SCreateCharRes::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SCreateCharRes::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SCreateCharRes::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SCreateCharRes::clear_res() {
  if (res_ != NULL) res_->::pb::SCreateChar::Clear();
  clear_has_res();
}
inline const ::pb::SCreateChar& SCreateCharRes::res() const {
  return res_ != NULL ? *res_ : *default_instance_->res_;
}
inline ::pb::SCreateChar* SCreateCharRes::mutable_res() {
  set_has_res();
  if (res_ == NULL) res_ = new ::pb::SCreateChar;
  return res_;
}
inline ::pb::SCreateChar* SCreateCharRes::release_res() {
  clear_has_res();
  ::pb::SCreateChar* temp = res_;
  res_ = NULL;
  return temp;
}
inline void SCreateCharRes::set_allocated_res(::pb::SCreateChar* res) {
  delete res_;
  res_ = res;
  if (res) {
    set_has_res();
  } else {
    clear_has_res();
  }
}

// required string name = 2;
inline bool SCreateCharRes::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SCreateCharRes::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SCreateCharRes::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SCreateCharRes::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SCreateCharRes::name() const {
  return *name_;
}
inline void SCreateCharRes::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SCreateCharRes::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SCreateCharRes::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SCreateCharRes::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SCreateCharRes::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SCreateCharRes::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 channel_id = 3;
inline bool SCreateCharRes::has_channel_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SCreateCharRes::set_has_channel_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SCreateCharRes::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SCreateCharRes::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 SCreateCharRes::channel_id() const {
  return channel_id_;
}
inline void SCreateCharRes::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// optional string sdk_user_id = 4;
inline bool SCreateCharRes::has_sdk_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SCreateCharRes::set_has_sdk_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SCreateCharRes::clear_has_sdk_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SCreateCharRes::clear_sdk_user_id() {
  if (sdk_user_id_ != &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_->clear();
  }
  clear_has_sdk_user_id();
}
inline const ::std::string& SCreateCharRes::sdk_user_id() const {
  return *sdk_user_id_;
}
inline void SCreateCharRes::set_sdk_user_id(const ::std::string& value) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(value);
}
inline void SCreateCharRes::set_sdk_user_id(const char* value) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(value);
}
inline void SCreateCharRes::set_sdk_user_id(const char* value, size_t size) {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  sdk_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SCreateCharRes::mutable_sdk_user_id() {
  set_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    sdk_user_id_ = new ::std::string;
  }
  return sdk_user_id_;
}
inline ::std::string* SCreateCharRes::release_sdk_user_id() {
  clear_has_sdk_user_id();
  if (sdk_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdk_user_id_;
    sdk_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SCreateCharRes::set_allocated_sdk_user_id(::std::string* sdk_user_id) {
  if (sdk_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_user_id_;
  }
  if (sdk_user_id) {
    set_has_sdk_user_id();
    sdk_user_id_ = sdk_user_id;
  } else {
    clear_has_sdk_user_id();
    sdk_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 platform_id = 5;
inline bool SCreateCharRes::has_platform_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SCreateCharRes::set_has_platform_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SCreateCharRes::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SCreateCharRes::clear_platform_id() {
  platform_id_ = 0u;
  clear_has_platform_id();
}
inline ::google::protobuf::uint32 SCreateCharRes::platform_id() const {
  return platform_id_;
}
inline void SCreateCharRes::set_platform_id(::google::protobuf::uint32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// -------------------------------------------------------------------

// CSlectPlayer

// required uint64 player_id = 1;
inline bool CSlectPlayer::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSlectPlayer::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSlectPlayer::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSlectPlayer::clear_player_id() {
  player_id_ = GOOGLE_ULONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::uint64 CSlectPlayer::player_id() const {
  return player_id_;
}
inline void CSlectPlayer::set_player_id(::google::protobuf::uint64 value) {
  set_has_player_id();
  player_id_ = value;
}

// optional uint32 platform_id = 2;
inline bool CSlectPlayer::has_platform_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSlectPlayer::set_has_platform_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSlectPlayer::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSlectPlayer::clear_platform_id() {
  platform_id_ = 0u;
  clear_has_platform_id();
}
inline ::google::protobuf::uint32 CSlectPlayer::platform_id() const {
  return platform_id_;
}
inline void CSlectPlayer::set_platform_id(::google::protobuf::uint32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// optional uint32 country_id = 3;
inline bool CSlectPlayer::has_country_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSlectPlayer::set_has_country_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSlectPlayer::clear_has_country_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSlectPlayer::clear_country_id() {
  country_id_ = 0u;
  clear_has_country_id();
}
inline ::google::protobuf::uint32 CSlectPlayer::country_id() const {
  return country_id_;
}
inline void CSlectPlayer::set_country_id(::google::protobuf::uint32 value) {
  set_has_country_id();
  country_id_ = value;
}

// optional uint32 headpic_id = 4;
inline bool CSlectPlayer::has_headpic_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSlectPlayer::set_has_headpic_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSlectPlayer::clear_has_headpic_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSlectPlayer::clear_headpic_id() {
  headpic_id_ = 0u;
  clear_has_headpic_id();
}
inline ::google::protobuf::uint32 CSlectPlayer::headpic_id() const {
  return headpic_id_;
}
inline void CSlectPlayer::set_headpic_id(::google::protobuf::uint32 value) {
  set_has_headpic_id();
  headpic_id_ = value;
}

// optional uint32 expected_country_id = 5;
inline bool CSlectPlayer::has_expected_country_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSlectPlayer::set_has_expected_country_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSlectPlayer::clear_has_expected_country_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSlectPlayer::clear_expected_country_id() {
  expected_country_id_ = 0u;
  clear_has_expected_country_id();
}
inline ::google::protobuf::uint32 CSlectPlayer::expected_country_id() const {
  return expected_country_id_;
}
inline void CSlectPlayer::set_expected_country_id(::google::protobuf::uint32 value) {
  set_has_expected_country_id();
  expected_country_id_ = value;
}

// -------------------------------------------------------------------

// SSlectPlayer

// required .pb.SELECT_PLAYER_RESULT result = 1;
inline bool SSlectPlayer::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSlectPlayer::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSlectPlayer::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSlectPlayer::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::pb::SELECT_PLAYER_RESULT SSlectPlayer::result() const {
  return static_cast< ::pb::SELECT_PLAYER_RESULT >(result_);
}
inline void SSlectPlayer::set_result(::pb::SELECT_PLAYER_RESULT value) {
  assert(::pb::SELECT_PLAYER_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .pb.PlayerAllData player_data = 2;
inline bool SSlectPlayer::has_player_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSlectPlayer::set_has_player_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSlectPlayer::clear_has_player_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSlectPlayer::clear_player_data() {
  if (player_data_ != NULL) player_data_->::pb::PlayerAllData::Clear();
  clear_has_player_data();
}
inline const ::pb::PlayerAllData& SSlectPlayer::player_data() const {
  return player_data_ != NULL ? *player_data_ : *default_instance_->player_data_;
}
inline ::pb::PlayerAllData* SSlectPlayer::mutable_player_data() {
  set_has_player_data();
  if (player_data_ == NULL) player_data_ = new ::pb::PlayerAllData;
  return player_data_;
}
inline ::pb::PlayerAllData* SSlectPlayer::release_player_data() {
  clear_has_player_data();
  ::pb::PlayerAllData* temp = player_data_;
  player_data_ = NULL;
  return temp;
}
inline void SSlectPlayer::set_allocated_player_data(::pb::PlayerAllData* player_data) {
  delete player_data_;
  player_data_ = player_data;
  if (player_data) {
    set_has_player_data();
  } else {
    clear_has_player_data();
  }
}

// optional bool is_quick_login = 3;
inline bool SSlectPlayer::has_is_quick_login() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SSlectPlayer::set_has_is_quick_login() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SSlectPlayer::clear_has_is_quick_login() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SSlectPlayer::clear_is_quick_login() {
  is_quick_login_ = false;
  clear_has_is_quick_login();
}
inline bool SSlectPlayer::is_quick_login() const {
  return is_quick_login_;
}
inline void SSlectPlayer::set_is_quick_login(bool value) {
  set_has_is_quick_login();
  is_quick_login_ = value;
}

// optional uint32 country_id = 4;
inline bool SSlectPlayer::has_country_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SSlectPlayer::set_has_country_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SSlectPlayer::clear_has_country_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SSlectPlayer::clear_country_id() {
  country_id_ = 0u;
  clear_has_country_id();
}
inline ::google::protobuf::uint32 SSlectPlayer::country_id() const {
  return country_id_;
}
inline void SSlectPlayer::set_country_id(::google::protobuf::uint32 value) {
  set_has_country_id();
  country_id_ = value;
}

// optional uint32 headpic_id = 5;
inline bool SSlectPlayer::has_headpic_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SSlectPlayer::set_has_headpic_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SSlectPlayer::clear_has_headpic_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SSlectPlayer::clear_headpic_id() {
  headpic_id_ = 0u;
  clear_has_headpic_id();
}
inline ::google::protobuf::uint32 SSlectPlayer::headpic_id() const {
  return headpic_id_;
}
inline void SSlectPlayer::set_headpic_id(::google::protobuf::uint32 value) {
  set_has_headpic_id();
  headpic_id_ = value;
}

// optional uint32 expected_country_id = 6;
inline bool SSlectPlayer::has_expected_country_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SSlectPlayer::set_has_expected_country_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SSlectPlayer::clear_has_expected_country_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SSlectPlayer::clear_expected_country_id() {
  expected_country_id_ = 0u;
  clear_has_expected_country_id();
}
inline ::google::protobuf::uint32 SSlectPlayer::expected_country_id() const {
  return expected_country_id_;
}
inline void SSlectPlayer::set_expected_country_id(::google::protobuf::uint32 value) {
  set_has_expected_country_id();
  expected_country_id_ = value;
}

// required uint64 player_id = 7;
inline bool SSlectPlayer::has_player_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SSlectPlayer::set_has_player_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SSlectPlayer::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SSlectPlayer::clear_player_id() {
  player_id_ = GOOGLE_ULONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::uint64 SSlectPlayer::player_id() const {
  return player_id_;
}
inline void SSlectPlayer::set_player_id(::google::protobuf::uint64 value) {
  set_has_player_id();
  player_id_ = value;
}

// -------------------------------------------------------------------

// SGuideProcess

// required bool is_need_guide = 1;
inline bool SGuideProcess::has_is_need_guide() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SGuideProcess::set_has_is_need_guide() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SGuideProcess::clear_has_is_need_guide() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SGuideProcess::clear_is_need_guide() {
  is_need_guide_ = false;
  clear_has_is_need_guide();
}
inline bool SGuideProcess::is_need_guide() const {
  return is_need_guide_;
}
inline void SGuideProcess::set_is_need_guide(bool value) {
  set_has_is_need_guide();
  is_need_guide_ = value;
}

// required bool is_finished_guide = 2;
inline bool SGuideProcess::has_is_finished_guide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SGuideProcess::set_has_is_finished_guide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SGuideProcess::clear_has_is_finished_guide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SGuideProcess::clear_is_finished_guide() {
  is_finished_guide_ = false;
  clear_has_is_finished_guide();
}
inline bool SGuideProcess::is_finished_guide() const {
  return is_finished_guide_;
}
inline void SGuideProcess::set_is_finished_guide(bool value) {
  set_has_is_finished_guide();
  is_finished_guide_ = value;
}

// required uint32 cur_process = 3;
inline bool SGuideProcess::has_cur_process() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SGuideProcess::set_has_cur_process() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SGuideProcess::clear_has_cur_process() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SGuideProcess::clear_cur_process() {
  cur_process_ = 0u;
  clear_has_cur_process();
}
inline ::google::protobuf::uint32 SGuideProcess::cur_process() const {
  return cur_process_;
}
inline void SGuideProcess::set_cur_process(::google::protobuf::uint32 value) {
  set_has_cur_process();
  cur_process_ = value;
}

// optional uint32 left_precess = 4;
inline bool SGuideProcess::has_left_precess() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SGuideProcess::set_has_left_precess() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SGuideProcess::clear_has_left_precess() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SGuideProcess::clear_left_precess() {
  left_precess_ = 0u;
  clear_has_left_precess();
}
inline ::google::protobuf::uint32 SGuideProcess::left_precess() const {
  return left_precess_;
}
inline void SGuideProcess::set_left_precess(::google::protobuf::uint32 value) {
  set_has_left_precess();
  left_precess_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::VERSION_CHECK_RESULT>() {
  return ::pb::VERSION_CHECK_RESULT_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ACCOUNT_CHECK_METHOD>() {
  return ::pb::ACCOUNT_CHECK_METHOD_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ACCOUNT_CHECK_RESULT>() {
  return ::pb::ACCOUNT_CHECK_RESULT_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ACCOUNT_TYPE>() {
  return ::pb::ACCOUNT_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::REGISTER_ACCOUNT_TYPE>() {
  return ::pb::REGISTER_ACCOUNT_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::REGISTER_ACCOUNT_RESULT>() {
  return ::pb::REGISTER_ACCOUNT_RESULT_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::CHANGE_ACCOUNT_PASSWORD_RESULT>() {
  return ::pb::CHANGE_ACCOUNT_PASSWORD_RESULT_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ServerState>() {
  return ::pb::ServerState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ASK_SELECTSERVERID_RESULT>() {
  return ::pb::ASK_SELECTSERVERID_RESULT_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::GET_PLAYER_LIST_RESULT>() {
  return ::pb::GET_PLAYER_LIST_RESULT_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::CREATE_PLAYER_RESULT>() {
  return ::pb::CREATE_PLAYER_RESULT_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::SELECT_PLAYER_RESULT>() {
  return ::pb::SELECT_PLAYER_RESULT_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Login_2eproto__INCLUDED
