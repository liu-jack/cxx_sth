// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Web.proto

#ifndef PROTOBUF_Web_2eproto__INCLUDED
#define PROTOBUF_Web_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Web_2eproto();
void protobuf_AssignDesc_Web_2eproto();
void protobuf_ShutdownFile_Web_2eproto();

class GetGameServerList;
class GameServerInfo;
class GameServerList;
class WebGetPlayerList;
class WebPlayerInfo;
class WebGetPlayerListRet;
class WebPay;
class WebPayRet;
class WebPayToDatabase;
class WebPayToDatabaseRet;
class GXDB_PayOrder;
class Sdk_PayResult;
class ServerCode;
class ServerResponse;
class ServersMail;
class PlayerMail;
class PlayerForbid;
class SetPlayerVip;
class ReCreateOder;
class ServersNotice;
class HotResReload;
class OnlinePlayerCount;
class serverInfo;
class CreateGiftCode;

enum Language {
  sc = 0,
  en = 1,
  th = 2,
  ve = 3,
  tc = 4
};
bool Language_IsValid(int value);
const Language Language_MIN = sc;
const Language Language_MAX = tc;
const int Language_ARRAYSIZE = Language_MAX + 1;

const ::google::protobuf::EnumDescriptor* Language_descriptor();
inline const ::std::string& Language_Name(Language value) {
  return ::google::protobuf::internal::NameOfEnum(
    Language_descriptor(), value);
}
inline bool Language_Parse(
    const ::std::string& name, Language* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Language>(
    Language_descriptor(), name, value);
}
enum WebPayCurrentType {
  WEB_PAY_USD = 0,
  WEB_PAY_RMB = 1
};
bool WebPayCurrentType_IsValid(int value);
const WebPayCurrentType WebPayCurrentType_MIN = WEB_PAY_USD;
const WebPayCurrentType WebPayCurrentType_MAX = WEB_PAY_RMB;
const int WebPayCurrentType_ARRAYSIZE = WebPayCurrentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WebPayCurrentType_descriptor();
inline const ::std::string& WebPayCurrentType_Name(WebPayCurrentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WebPayCurrentType_descriptor(), value);
}
inline bool WebPayCurrentType_Parse(
    const ::std::string& name, WebPayCurrentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WebPayCurrentType>(
    WebPayCurrentType_descriptor(), name, value);
}
enum SdkChannelType {
  SDK_NONE = 0,
  SDK_CAOHUA = 1,
  SDK_UC = 2,
  SDK_HUAWEI = 3,
  SDK_JINLI = 4,
  SDK_360 = 5,
  SDK_MEIZU = 6,
  SDK_XIAOMI = 7,
  SDK_OPPO = 8,
  SDK_VIVO = 9,
  SDK_YINGYOUBAO = 10,
  SDK_ALL = 11
};
bool SdkChannelType_IsValid(int value);
const SdkChannelType SdkChannelType_MIN = SDK_NONE;
const SdkChannelType SdkChannelType_MAX = SDK_ALL;
const int SdkChannelType_ARRAYSIZE = SdkChannelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdkChannelType_descriptor();
inline const ::std::string& SdkChannelType_Name(SdkChannelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdkChannelType_descriptor(), value);
}
inline bool SdkChannelType_Parse(
    const ::std::string& name, SdkChannelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdkChannelType>(
    SdkChannelType_descriptor(), name, value);
}
enum PlatformType {
  WINDOWS = 0,
  ANDROID = 1,
  IOS = 2,
  THIRD_PARTY = 3,
  WEB_PAGE = 4,
  ALL_PLATFORM = 5
};
bool PlatformType_IsValid(int value);
const PlatformType PlatformType_MIN = WINDOWS;
const PlatformType PlatformType_MAX = ALL_PLATFORM;
const int PlatformType_ARRAYSIZE = PlatformType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlatformType_descriptor();
inline const ::std::string& PlatformType_Name(PlatformType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlatformType_descriptor(), value);
}
inline bool PlatformType_Parse(
    const ::std::string& name, PlatformType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlatformType>(
    PlatformType_descriptor(), name, value);
}
enum WebPayResult {
  WEB_PAY_RERSULT_OK = 0,
  CAN_NOT_FIND_ACCOUNT = 1,
  CAN_NOT_FIND_ROLE = 2,
  CHANNEL_PLATFORM_ID_ERROR = 3,
  CAN_NOT_FIND_SERVER = 4,
  CAN_NOT_FIND_MONEY_TYPE = 5,
  CAN_NOT_FIND_ITEM_TYPE = 6,
  CAN_MONEY_NOT_ENOUGH = 7
};
bool WebPayResult_IsValid(int value);
const WebPayResult WebPayResult_MIN = WEB_PAY_RERSULT_OK;
const WebPayResult WebPayResult_MAX = CAN_MONEY_NOT_ENOUGH;
const int WebPayResult_ARRAYSIZE = WebPayResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* WebPayResult_descriptor();
inline const ::std::string& WebPayResult_Name(WebPayResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    WebPayResult_descriptor(), value);
}
inline bool WebPayResult_Parse(
    const ::std::string& name, WebPayResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WebPayResult>(
    WebPayResult_descriptor(), name, value);
}
// ===================================================================

class GetGameServerList : public ::google::protobuf::Message {
 public:
  GetGameServerList();
  virtual ~GetGameServerList();

  GetGameServerList(const GetGameServerList& from);

  inline GetGameServerList& operator=(const GetGameServerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGameServerList& default_instance();

  void Swap(GetGameServerList* other);

  // implements Message ----------------------------------------------

  GetGameServerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetGameServerList& from);
  void MergeFrom(const GetGameServerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.Language lang = 1;
  inline bool has_lang() const;
  inline void clear_lang();
  static const int kLangFieldNumber = 1;
  inline ::pb::Language lang() const;
  inline void set_lang(::pb::Language value);

  // @@protoc_insertion_point(class_scope:pb.GetGameServerList)
 private:
  inline void set_has_lang();
  inline void clear_has_lang();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int lang_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static GetGameServerList* default_instance_;
};
// -------------------------------------------------------------------

class GameServerInfo : public ::google::protobuf::Message {
 public:
  GameServerInfo();
  virtual ~GameServerInfo();

  GameServerInfo(const GameServerInfo& from);

  inline GameServerInfo& operator=(const GameServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameServerInfo& default_instance();

  void Swap(GameServerInfo* other);

  // implements Message ----------------------------------------------

  GameServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameServerInfo& from);
  void MergeFrom(const GameServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:pb.GameServerInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static GameServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameServerList : public ::google::protobuf::Message {
 public:
  GameServerList();
  virtual ~GameServerList();

  GameServerList(const GameServerList& from);

  inline GameServerList& operator=(const GameServerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameServerList& default_instance();

  void Swap(GameServerList* other);

  // implements Message ----------------------------------------------

  GameServerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameServerList& from);
  void MergeFrom(const GameServerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.GameServerInfo infos = 1;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 1;
  inline const ::pb::GameServerInfo& infos(int index) const;
  inline ::pb::GameServerInfo* mutable_infos(int index);
  inline ::pb::GameServerInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::GameServerInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::GameServerInfo >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:pb.GameServerList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::GameServerInfo > infos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static GameServerList* default_instance_;
};
// -------------------------------------------------------------------

class WebGetPlayerList : public ::google::protobuf::Message {
 public:
  WebGetPlayerList();
  virtual ~WebGetPlayerList();

  WebGetPlayerList(const WebGetPlayerList& from);

  inline WebGetPlayerList& operator=(const WebGetPlayerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WebGetPlayerList& default_instance();

  void Swap(WebGetPlayerList* other);

  // implements Message ----------------------------------------------

  WebGetPlayerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WebGetPlayerList& from);
  void MergeFrom(const WebGetPlayerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional string user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:pb.WebGetPlayerList)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_id_;
  ::google::protobuf::uint32 server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static WebGetPlayerList* default_instance_;
};
// -------------------------------------------------------------------

class WebPlayerInfo : public ::google::protobuf::Message {
 public:
  WebPlayerInfo();
  virtual ~WebPlayerInfo();

  WebPlayerInfo(const WebPlayerInfo& from);

  inline WebPlayerInfo& operator=(const WebPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WebPlayerInfo& default_instance();

  void Swap(WebPlayerInfo* other);

  // implements Message ----------------------------------------------

  WebPlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WebPlayerInfo& from);
  void MergeFrom(const WebPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline const ::std::string& role_id() const;
  inline void set_role_id(const ::std::string& value);
  inline void set_role_id(const char* value);
  inline void set_role_id(const char* value, size_t size);
  inline ::std::string* mutable_role_id();
  inline ::std::string* release_role_id();
  inline void set_allocated_role_id(::std::string* role_id);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional string prefession_name = 3;
  inline bool has_prefession_name() const;
  inline void clear_prefession_name();
  static const int kPrefessionNameFieldNumber = 3;
  inline const ::std::string& prefession_name() const;
  inline void set_prefession_name(const ::std::string& value);
  inline void set_prefession_name(const char* value);
  inline void set_prefession_name(const char* value, size_t size);
  inline ::std::string* mutable_prefession_name();
  inline ::std::string* release_prefession_name();
  inline void set_allocated_prefession_name(::std::string* prefession_name);

  // @@protoc_insertion_point(class_scope:pb.WebPlayerInfo)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_prefession_name();
  inline void clear_has_prefession_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_id_;
  ::std::string* role_name_;
  ::std::string* prefession_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static WebPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class WebGetPlayerListRet : public ::google::protobuf::Message {
 public:
  WebGetPlayerListRet();
  virtual ~WebGetPlayerListRet();

  WebGetPlayerListRet(const WebGetPlayerListRet& from);

  inline WebGetPlayerListRet& operator=(const WebGetPlayerListRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WebGetPlayerListRet& default_instance();

  void Swap(WebGetPlayerListRet* other);

  // implements Message ----------------------------------------------

  WebGetPlayerListRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WebGetPlayerListRet& from);
  void MergeFrom(const WebGetPlayerListRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.WebPlayerInfo player_info = 1;
  inline int player_info_size() const;
  inline void clear_player_info();
  static const int kPlayerInfoFieldNumber = 1;
  inline const ::pb::WebPlayerInfo& player_info(int index) const;
  inline ::pb::WebPlayerInfo* mutable_player_info(int index);
  inline ::pb::WebPlayerInfo* add_player_info();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::WebPlayerInfo >&
      player_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::WebPlayerInfo >*
      mutable_player_info();

  // @@protoc_insertion_point(class_scope:pb.WebGetPlayerListRet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::WebPlayerInfo > player_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static WebGetPlayerListRet* default_instance_;
};
// -------------------------------------------------------------------

class WebPay : public ::google::protobuf::Message {
 public:
  WebPay();
  virtual ~WebPay();

  WebPay(const WebPay& from);

  inline WebPay& operator=(const WebPay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WebPay& default_instance();

  void Swap(WebPay* other);

  // implements Message ----------------------------------------------

  WebPay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WebPay& from);
  void MergeFrom(const WebPay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string order_id = 1;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 1;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // optional .pb.SdkChannelType channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::pb::SdkChannelType channel() const;
  inline void set_channel(::pb::SdkChannelType value);

  // optional .pb.PlatformType platform = 3;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 3;
  inline ::pb::PlatformType platform() const;
  inline void set_platform(::pb::PlatformType value);

  // optional .pb.WebPayCurrentType currency = 4;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 4;
  inline ::pb::WebPayCurrentType currency() const;
  inline void set_currency(::pb::WebPayCurrentType value);

  // optional float money = 5;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 5;
  inline float money() const;
  inline void set_money(float value);

  // optional string sdk_account = 6;
  inline bool has_sdk_account() const;
  inline void clear_sdk_account();
  static const int kSdkAccountFieldNumber = 6;
  inline const ::std::string& sdk_account() const;
  inline void set_sdk_account(const ::std::string& value);
  inline void set_sdk_account(const char* value);
  inline void set_sdk_account(const char* value, size_t size);
  inline ::std::string* mutable_sdk_account();
  inline ::std::string* release_sdk_account();
  inline void set_allocated_sdk_account(::std::string* sdk_account);

  // optional string role_id = 7;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 7;
  inline const ::std::string& role_id() const;
  inline void set_role_id(const ::std::string& value);
  inline void set_role_id(const char* value);
  inline void set_role_id(const char* value, size_t size);
  inline ::std::string* mutable_role_id();
  inline ::std::string* release_role_id();
  inline void set_allocated_role_id(::std::string* role_id);

  // optional uint32 server_id = 8;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 8;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional float present = 9;
  inline bool has_present() const;
  inline void clear_present();
  static const int kPresentFieldNumber = 9;
  inline float present() const;
  inline void set_present(float value);

  // optional string product_id = 10;
  inline bool has_product_id() const;
  inline void clear_product_id();
  static const int kProductIdFieldNumber = 10;
  inline const ::std::string& product_id() const;
  inline void set_product_id(const ::std::string& value);
  inline void set_product_id(const char* value);
  inline void set_product_id(const char* value, size_t size);
  inline ::std::string* mutable_product_id();
  inline ::std::string* release_product_id();
  inline void set_allocated_product_id(::std::string* product_id);

  // @@protoc_insertion_point(class_scope:pb.WebPay)
 private:
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_sdk_account();
  inline void clear_has_sdk_account();
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_present();
  inline void clear_has_present();
  inline void set_has_product_id();
  inline void clear_has_product_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* order_id_;
  int channel_;
  int platform_;
  int currency_;
  float money_;
  ::std::string* sdk_account_;
  ::std::string* role_id_;
  ::google::protobuf::uint32 server_id_;
  float present_;
  ::std::string* product_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static WebPay* default_instance_;
};
// -------------------------------------------------------------------

class WebPayRet : public ::google::protobuf::Message {
 public:
  WebPayRet();
  virtual ~WebPayRet();

  WebPayRet(const WebPayRet& from);

  inline WebPayRet& operator=(const WebPayRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WebPayRet& default_instance();

  void Swap(WebPayRet* other);

  // implements Message ----------------------------------------------

  WebPayRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WebPayRet& from);
  void MergeFrom(const WebPayRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.WebPayResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::pb::WebPayResult result() const;
  inline void set_result(::pb::WebPayResult value);

  // optional string order_id = 2;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 2;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // optional string error_msg = 3;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 3;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  inline void set_allocated_error_msg(::std::string* error_msg);

  // @@protoc_insertion_point(class_scope:pb.WebPayRet)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* order_id_;
  ::std::string* error_msg_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static WebPayRet* default_instance_;
};
// -------------------------------------------------------------------

class WebPayToDatabase : public ::google::protobuf::Message {
 public:
  WebPayToDatabase();
  virtual ~WebPayToDatabase();

  WebPayToDatabase(const WebPayToDatabase& from);

  inline WebPayToDatabase& operator=(const WebPayToDatabase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WebPayToDatabase& default_instance();

  void Swap(WebPayToDatabase* other);

  // implements Message ----------------------------------------------

  WebPayToDatabase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WebPayToDatabase& from);
  void MergeFrom(const WebPayToDatabase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string order_id = 1;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 1;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // optional uint32 currency = 2;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 2;
  inline ::google::protobuf::uint32 currency() const;
  inline void set_currency(::google::protobuf::uint32 value);

  // optional float present = 3;
  inline bool has_present() const;
  inline void clear_present();
  static const int kPresentFieldNumber = 3;
  inline float present() const;
  inline void set_present(float value);

  // optional uint64 player_id = 4;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 4;
  inline ::google::protobuf::uint64 player_id() const;
  inline void set_player_id(::google::protobuf::uint64 value);

  // optional string sdk_account = 5;
  inline bool has_sdk_account() const;
  inline void clear_sdk_account();
  static const int kSdkAccountFieldNumber = 5;
  inline const ::std::string& sdk_account() const;
  inline void set_sdk_account(const ::std::string& value);
  inline void set_sdk_account(const char* value);
  inline void set_sdk_account(const char* value, size_t size);
  inline ::std::string* mutable_sdk_account();
  inline ::std::string* release_sdk_account();
  inline void set_allocated_sdk_account(::std::string* sdk_account);

  // optional float money = 6;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 6;
  inline float money() const;
  inline void set_money(float value);

  // optional .pb.SdkChannelType channel = 7;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 7;
  inline ::pb::SdkChannelType channel() const;
  inline void set_channel(::pb::SdkChannelType value);

  // optional .pb.PlatformType platform = 8;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 8;
  inline ::pb::PlatformType platform() const;
  inline void set_platform(::pb::PlatformType value);

  // @@protoc_insertion_point(class_scope:pb.WebPayToDatabase)
 private:
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_present();
  inline void clear_has_present();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_sdk_account();
  inline void clear_has_sdk_account();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_platform();
  inline void clear_has_platform();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* order_id_;
  ::google::protobuf::uint32 currency_;
  float present_;
  ::google::protobuf::uint64 player_id_;
  ::std::string* sdk_account_;
  float money_;
  int channel_;
  int platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static WebPayToDatabase* default_instance_;
};
// -------------------------------------------------------------------

class WebPayToDatabaseRet : public ::google::protobuf::Message {
 public:
  WebPayToDatabaseRet();
  virtual ~WebPayToDatabaseRet();

  WebPayToDatabaseRet(const WebPayToDatabaseRet& from);

  inline WebPayToDatabaseRet& operator=(const WebPayToDatabaseRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WebPayToDatabaseRet& default_instance();

  void Swap(WebPayToDatabaseRet* other);

  // implements Message ----------------------------------------------

  WebPayToDatabaseRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WebPayToDatabaseRet& from);
  void MergeFrom(const WebPayToDatabaseRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_ok = 1;
  inline bool has_is_ok() const;
  inline void clear_is_ok();
  static const int kIsOkFieldNumber = 1;
  inline bool is_ok() const;
  inline void set_is_ok(bool value);

  // optional string order_id = 2;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 2;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // optional bool is_online = 3;
  inline bool has_is_online() const;
  inline void clear_is_online();
  static const int kIsOnlineFieldNumber = 3;
  inline bool is_online() const;
  inline void set_is_online(bool value);

  // optional .pb.GXDB_PayOrder order_record = 4;
  inline bool has_order_record() const;
  inline void clear_order_record();
  static const int kOrderRecordFieldNumber = 4;
  inline const ::pb::GXDB_PayOrder& order_record() const;
  inline ::pb::GXDB_PayOrder* mutable_order_record();
  inline ::pb::GXDB_PayOrder* release_order_record();
  inline void set_allocated_order_record(::pb::GXDB_PayOrder* order_record);

  // optional uint64 player_id = 5;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 5;
  inline ::google::protobuf::uint64 player_id() const;
  inline void set_player_id(::google::protobuf::uint64 value);

  // optional string error_msg = 6;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 6;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  inline void set_allocated_error_msg(::std::string* error_msg);

  // optional .pb.SdkChannelType channel = 7;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 7;
  inline ::pb::SdkChannelType channel() const;
  inline void set_channel(::pb::SdkChannelType value);

  // optional .pb.WebPayResult result = 8;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 8;
  inline ::pb::WebPayResult result() const;
  inline void set_result(::pb::WebPayResult value);

  // optional float money = 9;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 9;
  inline float money() const;
  inline void set_money(float value);

  // optional .pb.PlatformType platform = 10;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 10;
  inline ::pb::PlatformType platform() const;
  inline void set_platform(::pb::PlatformType value);

  // @@protoc_insertion_point(class_scope:pb.WebPayToDatabaseRet)
 private:
  inline void set_has_is_ok();
  inline void clear_has_is_ok();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_is_online();
  inline void clear_has_is_online();
  inline void set_has_order_record();
  inline void clear_has_order_record();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_platform();
  inline void clear_has_platform();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* order_id_;
  bool is_ok_;
  bool is_online_;
  int channel_;
  ::pb::GXDB_PayOrder* order_record_;
  ::google::protobuf::uint64 player_id_;
  ::std::string* error_msg_;
  int result_;
  float money_;
  int platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static WebPayToDatabaseRet* default_instance_;
};
// -------------------------------------------------------------------

class GXDB_PayOrder : public ::google::protobuf::Message {
 public:
  GXDB_PayOrder();
  virtual ~GXDB_PayOrder();

  GXDB_PayOrder(const GXDB_PayOrder& from);

  inline GXDB_PayOrder& operator=(const GXDB_PayOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GXDB_PayOrder& default_instance();

  void Swap(GXDB_PayOrder* other);

  // implements Message ----------------------------------------------

  GXDB_PayOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GXDB_PayOrder& from);
  void MergeFrom(const GXDB_PayOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_new = 1;
  inline bool has_is_new() const;
  inline void clear_is_new();
  static const int kIsNewFieldNumber = 1;
  inline bool is_new() const;
  inline void set_is_new(bool value);

  // optional string product_id = 2;
  inline bool has_product_id() const;
  inline void clear_product_id();
  static const int kProductIdFieldNumber = 2;
  inline const ::std::string& product_id() const;
  inline void set_product_id(const ::std::string& value);
  inline void set_product_id(const char* value);
  inline void set_product_id(const char* value, size_t size);
  inline ::std::string* mutable_product_id();
  inline ::std::string* release_product_id();
  inline void set_allocated_product_id(::std::string* product_id);

  // optional uint32 vip_xp = 3;
  inline bool has_vip_xp() const;
  inline void clear_vip_xp();
  static const int kVipXpFieldNumber = 3;
  inline ::google::protobuf::uint32 vip_xp() const;
  inline void set_vip_xp(::google::protobuf::uint32 value);

  // optional uint32 crystal_final = 4;
  inline bool has_crystal_final() const;
  inline void clear_crystal_final();
  static const int kCrystalFinalFieldNumber = 4;
  inline ::google::protobuf::uint32 crystal_final() const;
  inline void set_crystal_final(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.GXDB_PayOrder)
 private:
  inline void set_has_is_new();
  inline void clear_has_is_new();
  inline void set_has_product_id();
  inline void clear_has_product_id();
  inline void set_has_vip_xp();
  inline void clear_has_vip_xp();
  inline void set_has_crystal_final();
  inline void clear_has_crystal_final();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* product_id_;
  bool is_new_;
  ::google::protobuf::uint32 vip_xp_;
  ::google::protobuf::uint32 crystal_final_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static GXDB_PayOrder* default_instance_;
};
// -------------------------------------------------------------------

class Sdk_PayResult : public ::google::protobuf::Message {
 public:
  Sdk_PayResult();
  virtual ~Sdk_PayResult();

  Sdk_PayResult(const Sdk_PayResult& from);

  inline Sdk_PayResult& operator=(const Sdk_PayResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sdk_PayResult& default_instance();

  void Swap(Sdk_PayResult* other);

  // implements Message ----------------------------------------------

  Sdk_PayResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sdk_PayResult& from);
  void MergeFrom(const Sdk_PayResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.WebPayRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::pb::WebPayRet& result() const;
  inline ::pb::WebPayRet* mutable_result();
  inline ::pb::WebPayRet* release_result();
  inline void set_allocated_result(::pb::WebPayRet* result);

  // optional .pb.WebPay payInfo = 2;
  inline bool has_payinfo() const;
  inline void clear_payinfo();
  static const int kPayInfoFieldNumber = 2;
  inline const ::pb::WebPay& payinfo() const;
  inline ::pb::WebPay* mutable_payinfo();
  inline ::pb::WebPay* release_payinfo();
  inline void set_allocated_payinfo(::pb::WebPay* payinfo);

  // @@protoc_insertion_point(class_scope:pb.Sdk_PayResult)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_payinfo();
  inline void clear_has_payinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::WebPayRet* result_;
  ::pb::WebPay* payinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static Sdk_PayResult* default_instance_;
};
// -------------------------------------------------------------------

class ServerCode : public ::google::protobuf::Message {
 public:
  ServerCode();
  virtual ~ServerCode();

  ServerCode(const ServerCode& from);

  inline ServerCode& operator=(const ServerCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerCode& default_instance();

  void Swap(ServerCode* other);

  // implements Message ----------------------------------------------

  ServerCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerCode& from);
  void MergeFrom(const ServerCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.ServerCode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static ServerCode* default_instance_;
};
// -------------------------------------------------------------------

class ServerResponse : public ::google::protobuf::Message {
 public:
  ServerResponse();
  virtual ~ServerResponse();

  ServerResponse(const ServerResponse& from);

  inline ServerResponse& operator=(const ServerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerResponse& default_instance();

  void Swap(ServerResponse* other);

  // implements Message ----------------------------------------------

  ServerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerResponse& from);
  void MergeFrom(const ServerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // repeated .pb.ServerCode reg = 2;
  inline int reg_size() const;
  inline void clear_reg();
  static const int kRegFieldNumber = 2;
  inline const ::pb::ServerCode& reg(int index) const;
  inline ::pb::ServerCode* mutable_reg(int index);
  inline ::pb::ServerCode* add_reg();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::ServerCode >&
      reg() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::ServerCode >*
      mutable_reg();

  // @@protoc_insertion_point(class_scope:pb.ServerResponse)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::ServerCode > reg_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static ServerResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServersMail : public ::google::protobuf::Message {
 public:
  ServersMail();
  virtual ~ServersMail();

  ServersMail(const ServersMail& from);

  inline ServersMail& operator=(const ServersMail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServersMail& default_instance();

  void Swap(ServersMail* other);

  // implements Message ----------------------------------------------

  ServersMail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServersMail& from);
  void MergeFrom(const ServersMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void set_allocated_sid(::std::string* sid);

  // optional int32 online = 2;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 2;
  inline ::google::protobuf::int32 online() const;
  inline void set_online(::google::protobuf::int32 value);

  // optional string channel = 3;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 3;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // optional int32 moldid = 4;
  inline bool has_moldid() const;
  inline void clear_moldid();
  static const int kMoldidFieldNumber = 4;
  inline ::google::protobuf::int32 moldid() const;
  inline void set_moldid(::google::protobuf::int32 value);

  // optional string title = 5;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 5;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string content = 6;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 6;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string mail_award = 7;
  inline bool has_mail_award() const;
  inline void clear_mail_award();
  static const int kMailAwardFieldNumber = 7;
  inline const ::std::string& mail_award() const;
  inline void set_mail_award(const ::std::string& value);
  inline void set_mail_award(const char* value);
  inline void set_mail_award(const char* value, size_t size);
  inline ::std::string* mutable_mail_award();
  inline ::std::string* release_mail_award();
  inline void set_allocated_mail_award(::std::string* mail_award);

  // optional int32 alv = 8;
  inline bool has_alv() const;
  inline void clear_alv();
  static const int kAlvFieldNumber = 8;
  inline ::google::protobuf::int32 alv() const;
  inline void set_alv(::google::protobuf::int32 value);

  // optional int32 blv = 9;
  inline bool has_blv() const;
  inline void clear_blv();
  static const int kBlvFieldNumber = 9;
  inline ::google::protobuf::int32 blv() const;
  inline void set_blv(::google::protobuf::int32 value);

  // optional int32 avip = 10;
  inline bool has_avip() const;
  inline void clear_avip();
  static const int kAvipFieldNumber = 10;
  inline ::google::protobuf::int32 avip() const;
  inline void set_avip(::google::protobuf::int32 value);

  // optional int32 bvip = 11;
  inline bool has_bvip() const;
  inline void clear_bvip();
  static const int kBvipFieldNumber = 11;
  inline ::google::protobuf::int32 bvip() const;
  inline void set_bvip(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.ServersMail)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_moldid();
  inline void clear_has_moldid();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_mail_award();
  inline void clear_has_mail_award();
  inline void set_has_alv();
  inline void clear_has_alv();
  inline void set_has_blv();
  inline void clear_has_blv();
  inline void set_has_avip();
  inline void clear_has_avip();
  inline void set_has_bvip();
  inline void clear_has_bvip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sid_;
  ::std::string* channel_;
  ::google::protobuf::int32 online_;
  ::google::protobuf::int32 moldid_;
  ::std::string* title_;
  ::std::string* content_;
  ::std::string* mail_award_;
  ::google::protobuf::int32 alv_;
  ::google::protobuf::int32 blv_;
  ::google::protobuf::int32 avip_;
  ::google::protobuf::int32 bvip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static ServersMail* default_instance_;
};
// -------------------------------------------------------------------

class PlayerMail : public ::google::protobuf::Message {
 public:
  PlayerMail();
  virtual ~PlayerMail();

  PlayerMail(const PlayerMail& from);

  inline PlayerMail& operator=(const PlayerMail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerMail& default_instance();

  void Swap(PlayerMail* other);

  // implements Message ----------------------------------------------

  PlayerMail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerMail& from);
  void MergeFrom(const PlayerMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::int32 sid() const;
  inline void set_sid(::google::protobuf::int32 value);

  // optional string to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // optional int32 moldid = 3;
  inline bool has_moldid() const;
  inline void clear_moldid();
  static const int kMoldidFieldNumber = 3;
  inline ::google::protobuf::int32 moldid() const;
  inline void set_moldid(::google::protobuf::int32 value);

  // optional string title = 4;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 4;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string mail_award = 6;
  inline bool has_mail_award() const;
  inline void clear_mail_award();
  static const int kMailAwardFieldNumber = 6;
  inline const ::std::string& mail_award() const;
  inline void set_mail_award(const ::std::string& value);
  inline void set_mail_award(const char* value);
  inline void set_mail_award(const char* value, size_t size);
  inline ::std::string* mutable_mail_award();
  inline ::std::string* release_mail_award();
  inline void set_allocated_mail_award(::std::string* mail_award);

  // @@protoc_insertion_point(class_scope:pb.PlayerMail)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_moldid();
  inline void clear_has_moldid();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_mail_award();
  inline void clear_has_mail_award();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* to_;
  ::google::protobuf::int32 sid_;
  ::google::protobuf::int32 moldid_;
  ::std::string* title_;
  ::std::string* content_;
  ::std::string* mail_award_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static PlayerMail* default_instance_;
};
// -------------------------------------------------------------------

class PlayerForbid : public ::google::protobuf::Message {
 public:
  PlayerForbid();
  virtual ~PlayerForbid();

  PlayerForbid(const PlayerForbid& from);

  inline PlayerForbid& operator=(const PlayerForbid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerForbid& default_instance();

  void Swap(PlayerForbid* other);

  // implements Message ----------------------------------------------

  PlayerForbid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerForbid& from);
  void MergeFrom(const PlayerForbid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::int32 sid() const;
  inline void set_sid(::google::protobuf::int32 value);

  // optional string lordId = 2;
  inline bool has_lordid() const;
  inline void clear_lordid();
  static const int kLordIdFieldNumber = 2;
  inline const ::std::string& lordid() const;
  inline void set_lordid(const ::std::string& value);
  inline void set_lordid(const char* value);
  inline void set_lordid(const char* value, size_t size);
  inline ::std::string* mutable_lordid();
  inline ::std::string* release_lordid();
  inline void set_allocated_lordid(::std::string* lordid);

  // optional int32 forbidId = 3;
  inline bool has_forbidid() const;
  inline void clear_forbidid();
  static const int kForbidIdFieldNumber = 3;
  inline ::google::protobuf::int32 forbidid() const;
  inline void set_forbidid(::google::protobuf::int32 value);

  // optional int32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.PlayerForbid)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_lordid();
  inline void clear_has_lordid();
  inline void set_has_forbidid();
  inline void clear_has_forbidid();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* lordid_;
  ::google::protobuf::int32 sid_;
  ::google::protobuf::int32 forbidid_;
  ::google::protobuf::int32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static PlayerForbid* default_instance_;
};
// -------------------------------------------------------------------

class SetPlayerVip : public ::google::protobuf::Message {
 public:
  SetPlayerVip();
  virtual ~SetPlayerVip();

  SetPlayerVip(const SetPlayerVip& from);

  inline SetPlayerVip& operator=(const SetPlayerVip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetPlayerVip& default_instance();

  void Swap(SetPlayerVip* other);

  // implements Message ----------------------------------------------

  SetPlayerVip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetPlayerVip& from);
  void MergeFrom(const SetPlayerVip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::int32 sid() const;
  inline void set_sid(::google::protobuf::int32 value);

  // optional string lordId = 2;
  inline bool has_lordid() const;
  inline void clear_lordid();
  static const int kLordIdFieldNumber = 2;
  inline const ::std::string& lordid() const;
  inline void set_lordid(const ::std::string& value);
  inline void set_lordid(const char* value);
  inline void set_lordid(const char* value, size_t size);
  inline ::std::string* mutable_lordid();
  inline ::std::string* release_lordid();
  inline void set_allocated_lordid(::std::string* lordid);

  // optional int32 typeValue = 3;
  inline bool has_typevalue() const;
  inline void clear_typevalue();
  static const int kTypeValueFieldNumber = 3;
  inline ::google::protobuf::int32 typevalue() const;
  inline void set_typevalue(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.SetPlayerVip)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_lordid();
  inline void clear_has_lordid();
  inline void set_has_typevalue();
  inline void clear_has_typevalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* lordid_;
  ::google::protobuf::int32 sid_;
  ::google::protobuf::int32 typevalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static SetPlayerVip* default_instance_;
};
// -------------------------------------------------------------------

class ReCreateOder : public ::google::protobuf::Message {
 public:
  ReCreateOder();
  virtual ~ReCreateOder();

  ReCreateOder(const ReCreateOder& from);

  inline ReCreateOder& operator=(const ReCreateOder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReCreateOder& default_instance();

  void Swap(ReCreateOder* other);

  // implements Message ----------------------------------------------

  ReCreateOder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReCreateOder& from);
  void MergeFrom(const ReCreateOder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::int32 sid() const;
  inline void set_sid(::google::protobuf::int32 value);

  // optional string lordId = 2;
  inline bool has_lordid() const;
  inline void clear_lordid();
  static const int kLordIdFieldNumber = 2;
  inline const ::std::string& lordid() const;
  inline void set_lordid(const ::std::string& value);
  inline void set_lordid(const char* value);
  inline void set_lordid(const char* value, size_t size);
  inline ::std::string* mutable_lordid();
  inline ::std::string* release_lordid();
  inline void set_allocated_lordid(::std::string* lordid);

  // optional int32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional string oredrId = 4;
  inline bool has_oredrid() const;
  inline void clear_oredrid();
  static const int kOredrIdFieldNumber = 4;
  inline const ::std::string& oredrid() const;
  inline void set_oredrid(const ::std::string& value);
  inline void set_oredrid(const char* value);
  inline void set_oredrid(const char* value, size_t size);
  inline ::std::string* mutable_oredrid();
  inline ::std::string* release_oredrid();
  inline void set_allocated_oredrid(::std::string* oredrid);

  // optional string platNo = 5;
  inline bool has_platno() const;
  inline void clear_platno();
  static const int kPlatNoFieldNumber = 5;
  inline const ::std::string& platno() const;
  inline void set_platno(const ::std::string& value);
  inline void set_platno(const char* value);
  inline void set_platno(const char* value, size_t size);
  inline ::std::string* mutable_platno();
  inline ::std::string* release_platno();
  inline void set_allocated_platno(::std::string* platno);

  // optional string platId = 6;
  inline bool has_platid() const;
  inline void clear_platid();
  static const int kPlatIdFieldNumber = 6;
  inline const ::std::string& platid() const;
  inline void set_platid(const ::std::string& value);
  inline void set_platid(const char* value);
  inline void set_platid(const char* value, size_t size);
  inline ::std::string* mutable_platid();
  inline ::std::string* release_platid();
  inline void set_allocated_platid(::std::string* platid);

  // @@protoc_insertion_point(class_scope:pb.ReCreateOder)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_lordid();
  inline void clear_has_lordid();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_oredrid();
  inline void clear_has_oredrid();
  inline void set_has_platno();
  inline void clear_has_platno();
  inline void set_has_platid();
  inline void clear_has_platid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* lordid_;
  ::google::protobuf::int32 sid_;
  ::google::protobuf::int32 money_;
  ::std::string* oredrid_;
  ::std::string* platno_;
  ::std::string* platid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static ReCreateOder* default_instance_;
};
// -------------------------------------------------------------------

class ServersNotice : public ::google::protobuf::Message {
 public:
  ServersNotice();
  virtual ~ServersNotice();

  ServersNotice(const ServersNotice& from);

  inline ServersNotice& operator=(const ServersNotice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServersNotice& default_instance();

  void Swap(ServersNotice* other);

  // implements Message ----------------------------------------------

  ServersNotice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServersNotice& from);
  void MergeFrom(const ServersNotice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void set_allocated_sid(::std::string* sid);

  // optional string notice = 2;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 2;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const char* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // @@protoc_insertion_point(class_scope:pb.ServersNotice)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_notice();
  inline void clear_has_notice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sid_;
  ::std::string* notice_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static ServersNotice* default_instance_;
};
// -------------------------------------------------------------------

class HotResReload : public ::google::protobuf::Message {
 public:
  HotResReload();
  virtual ~HotResReload();

  HotResReload(const HotResReload& from);

  inline HotResReload& operator=(const HotResReload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HotResReload& default_instance();

  void Swap(HotResReload* other);

  // implements Message ----------------------------------------------

  HotResReload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HotResReload& from);
  void MergeFrom(const HotResReload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void set_allocated_sid(::std::string* sid);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:pb.HotResReload)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sid_;
  ::std::string* type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static HotResReload* default_instance_;
};
// -------------------------------------------------------------------

class OnlinePlayerCount : public ::google::protobuf::Message {
 public:
  OnlinePlayerCount();
  virtual ~OnlinePlayerCount();

  OnlinePlayerCount(const OnlinePlayerCount& from);

  inline OnlinePlayerCount& operator=(const OnlinePlayerCount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlinePlayerCount& default_instance();

  void Swap(OnlinePlayerCount* other);

  // implements Message ----------------------------------------------

  OnlinePlayerCount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlinePlayerCount& from);
  void MergeFrom(const OnlinePlayerCount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::int32 sid() const;
  inline void set_sid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.OnlinePlayerCount)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 sid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static OnlinePlayerCount* default_instance_;
};
// -------------------------------------------------------------------

class serverInfo : public ::google::protobuf::Message {
 public:
  serverInfo();
  virtual ~serverInfo();

  serverInfo(const serverInfo& from);

  inline serverInfo& operator=(const serverInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const serverInfo& default_instance();

  void Swap(serverInfo* other);

  // implements Message ----------------------------------------------

  serverInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const serverInfo& from);
  void MergeFrom(const serverInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::int32 sid() const;
  inline void set_sid(::google::protobuf::int32 value);

  // optional string info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:pb.serverInfo)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* info_;
  ::google::protobuf::int32 sid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static serverInfo* default_instance_;
};
// -------------------------------------------------------------------

class CreateGiftCode : public ::google::protobuf::Message {
 public:
  CreateGiftCode();
  virtual ~CreateGiftCode();

  CreateGiftCode(const CreateGiftCode& from);

  inline CreateGiftCode& operator=(const CreateGiftCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateGiftCode& default_instance();

  void Swap(CreateGiftCode* other);

  // implements Message ----------------------------------------------

  CreateGiftCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateGiftCode& from);
  void MergeFrom(const CreateGiftCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 operate = 1;
  inline bool has_operate() const;
  inline void clear_operate();
  static const int kOperateFieldNumber = 1;
  inline ::google::protobuf::int32 operate() const;
  inline void set_operate(::google::protobuf::int32 value);

  // optional int32 giftId = 2;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIdFieldNumber = 2;
  inline ::google::protobuf::int32 giftid() const;
  inline void set_giftid(::google::protobuf::int32 value);

  // optional string giftName = 3;
  inline bool has_giftname() const;
  inline void clear_giftname();
  static const int kGiftNameFieldNumber = 3;
  inline const ::std::string& giftname() const;
  inline void set_giftname(const ::std::string& value);
  inline void set_giftname(const char* value);
  inline void set_giftname(const char* value, size_t size);
  inline ::std::string* mutable_giftname();
  inline ::std::string* release_giftname();
  inline void set_allocated_giftname(::std::string* giftname);

  // optional string beginTime = 4;
  inline bool has_begintime() const;
  inline void clear_begintime();
  static const int kBeginTimeFieldNumber = 4;
  inline const ::std::string& begintime() const;
  inline void set_begintime(const ::std::string& value);
  inline void set_begintime(const char* value);
  inline void set_begintime(const char* value, size_t size);
  inline ::std::string* mutable_begintime();
  inline ::std::string* release_begintime();
  inline void set_allocated_begintime(::std::string* begintime);

  // optional string endTime = 5;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 5;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional string gift = 6;
  inline bool has_gift() const;
  inline void clear_gift();
  static const int kGiftFieldNumber = 6;
  inline const ::std::string& gift() const;
  inline void set_gift(const ::std::string& value);
  inline void set_gift(const char* value);
  inline void set_gift(const char* value, size_t size);
  inline ::std::string* mutable_gift();
  inline ::std::string* release_gift();
  inline void set_allocated_gift(::std::string* gift);

  // optional int32 reuse = 7;
  inline bool has_reuse() const;
  inline void clear_reuse();
  static const int kReuseFieldNumber = 7;
  inline ::google::protobuf::int32 reuse() const;
  inline void set_reuse(::google::protobuf::int32 value);

  // optional int32 count = 8;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 8;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional string platNo = 9;
  inline bool has_platno() const;
  inline void clear_platno();
  static const int kPlatNoFieldNumber = 9;
  inline const ::std::string& platno() const;
  inline void set_platno(const ::std::string& value);
  inline void set_platno(const char* value);
  inline void set_platno(const char* value, size_t size);
  inline ::std::string* mutable_platno();
  inline ::std::string* release_platno();
  inline void set_allocated_platno(::std::string* platno);

  // optional string mark = 10;
  inline bool has_mark() const;
  inline void clear_mark();
  static const int kMarkFieldNumber = 10;
  inline const ::std::string& mark() const;
  inline void set_mark(const ::std::string& value);
  inline void set_mark(const char* value);
  inline void set_mark(const char* value, size_t size);
  inline ::std::string* mutable_mark();
  inline ::std::string* release_mark();
  inline void set_allocated_mark(::std::string* mark);

  // @@protoc_insertion_point(class_scope:pb.CreateGiftCode)
 private:
  inline void set_has_operate();
  inline void clear_has_operate();
  inline void set_has_giftid();
  inline void clear_has_giftid();
  inline void set_has_giftname();
  inline void clear_has_giftname();
  inline void set_has_begintime();
  inline void clear_has_begintime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_gift();
  inline void clear_has_gift();
  inline void set_has_reuse();
  inline void clear_has_reuse();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_platno();
  inline void clear_has_platno();
  inline void set_has_mark();
  inline void clear_has_mark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 operate_;
  ::google::protobuf::int32 giftid_;
  ::std::string* giftname_;
  ::std::string* begintime_;
  ::std::string* endtime_;
  ::std::string* gift_;
  ::google::protobuf::int32 reuse_;
  ::google::protobuf::int32 count_;
  ::std::string* platno_;
  ::std::string* mark_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_Web_2eproto();
  friend void protobuf_AssignDesc_Web_2eproto();
  friend void protobuf_ShutdownFile_Web_2eproto();

  void InitAsDefaultInstance();
  static CreateGiftCode* default_instance_;
};
// ===================================================================


// ===================================================================

// GetGameServerList

// optional .pb.Language lang = 1;
inline bool GetGameServerList::has_lang() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGameServerList::set_has_lang() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGameServerList::clear_has_lang() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGameServerList::clear_lang() {
  lang_ = 0;
  clear_has_lang();
}
inline ::pb::Language GetGameServerList::lang() const {
  return static_cast< ::pb::Language >(lang_);
}
inline void GetGameServerList::set_lang(::pb::Language value) {
  assert(::pb::Language_IsValid(value));
  set_has_lang();
  lang_ = value;
}

// -------------------------------------------------------------------

// GameServerInfo

// optional uint32 id = 1;
inline bool GameServerInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameServerInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameServerInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameServerInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 GameServerInfo::id() const {
  return id_;
}
inline void GameServerInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool GameServerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameServerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameServerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameServerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GameServerInfo::name() const {
  return *name_;
}
inline void GameServerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GameServerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GameServerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameServerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GameServerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameServerInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameServerList

// repeated .pb.GameServerInfo infos = 1;
inline int GameServerList::infos_size() const {
  return infos_.size();
}
inline void GameServerList::clear_infos() {
  infos_.Clear();
}
inline const ::pb::GameServerInfo& GameServerList::infos(int index) const {
  return infos_.Get(index);
}
inline ::pb::GameServerInfo* GameServerList::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::pb::GameServerInfo* GameServerList::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::GameServerInfo >&
GameServerList::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::GameServerInfo >*
GameServerList::mutable_infos() {
  return &infos_;
}

// -------------------------------------------------------------------

// WebGetPlayerList

// optional uint32 server_id = 1;
inline bool WebGetPlayerList::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebGetPlayerList::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebGetPlayerList::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebGetPlayerList::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 WebGetPlayerList::server_id() const {
  return server_id_;
}
inline void WebGetPlayerList::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional string user_id = 2;
inline bool WebGetPlayerList::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WebGetPlayerList::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WebGetPlayerList::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WebGetPlayerList::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& WebGetPlayerList::user_id() const {
  return *user_id_;
}
inline void WebGetPlayerList::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void WebGetPlayerList::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void WebGetPlayerList::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebGetPlayerList::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* WebGetPlayerList::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebGetPlayerList::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WebPlayerInfo

// optional string role_id = 1;
inline bool WebPlayerInfo::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebPlayerInfo::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebPlayerInfo::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebPlayerInfo::clear_role_id() {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    role_id_->clear();
  }
  clear_has_role_id();
}
inline const ::std::string& WebPlayerInfo::role_id() const {
  return *role_id_;
}
inline void WebPlayerInfo::set_role_id(const ::std::string& value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void WebPlayerInfo::set_role_id(const char* value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void WebPlayerInfo::set_role_id(const char* value, size_t size) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPlayerInfo::mutable_role_id() {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  return role_id_;
}
inline ::std::string* WebPlayerInfo::release_role_id() {
  clear_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_id_;
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPlayerInfo::set_allocated_role_id(::std::string* role_id) {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    delete role_id_;
  }
  if (role_id) {
    set_has_role_id();
    role_id_ = role_id;
  } else {
    clear_has_role_id();
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_name = 2;
inline bool WebPlayerInfo::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WebPlayerInfo::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WebPlayerInfo::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WebPlayerInfo::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& WebPlayerInfo::role_name() const {
  return *role_name_;
}
inline void WebPlayerInfo::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void WebPlayerInfo::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void WebPlayerInfo::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPlayerInfo::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* WebPlayerInfo::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPlayerInfo::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string prefession_name = 3;
inline bool WebPlayerInfo::has_prefession_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WebPlayerInfo::set_has_prefession_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WebPlayerInfo::clear_has_prefession_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WebPlayerInfo::clear_prefession_name() {
  if (prefession_name_ != &::google::protobuf::internal::kEmptyString) {
    prefession_name_->clear();
  }
  clear_has_prefession_name();
}
inline const ::std::string& WebPlayerInfo::prefession_name() const {
  return *prefession_name_;
}
inline void WebPlayerInfo::set_prefession_name(const ::std::string& value) {
  set_has_prefession_name();
  if (prefession_name_ == &::google::protobuf::internal::kEmptyString) {
    prefession_name_ = new ::std::string;
  }
  prefession_name_->assign(value);
}
inline void WebPlayerInfo::set_prefession_name(const char* value) {
  set_has_prefession_name();
  if (prefession_name_ == &::google::protobuf::internal::kEmptyString) {
    prefession_name_ = new ::std::string;
  }
  prefession_name_->assign(value);
}
inline void WebPlayerInfo::set_prefession_name(const char* value, size_t size) {
  set_has_prefession_name();
  if (prefession_name_ == &::google::protobuf::internal::kEmptyString) {
    prefession_name_ = new ::std::string;
  }
  prefession_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPlayerInfo::mutable_prefession_name() {
  set_has_prefession_name();
  if (prefession_name_ == &::google::protobuf::internal::kEmptyString) {
    prefession_name_ = new ::std::string;
  }
  return prefession_name_;
}
inline ::std::string* WebPlayerInfo::release_prefession_name() {
  clear_has_prefession_name();
  if (prefession_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefession_name_;
    prefession_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPlayerInfo::set_allocated_prefession_name(::std::string* prefession_name) {
  if (prefession_name_ != &::google::protobuf::internal::kEmptyString) {
    delete prefession_name_;
  }
  if (prefession_name) {
    set_has_prefession_name();
    prefession_name_ = prefession_name;
  } else {
    clear_has_prefession_name();
    prefession_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WebGetPlayerListRet

// repeated .pb.WebPlayerInfo player_info = 1;
inline int WebGetPlayerListRet::player_info_size() const {
  return player_info_.size();
}
inline void WebGetPlayerListRet::clear_player_info() {
  player_info_.Clear();
}
inline const ::pb::WebPlayerInfo& WebGetPlayerListRet::player_info(int index) const {
  return player_info_.Get(index);
}
inline ::pb::WebPlayerInfo* WebGetPlayerListRet::mutable_player_info(int index) {
  return player_info_.Mutable(index);
}
inline ::pb::WebPlayerInfo* WebGetPlayerListRet::add_player_info() {
  return player_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::WebPlayerInfo >&
WebGetPlayerListRet::player_info() const {
  return player_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::WebPlayerInfo >*
WebGetPlayerListRet::mutable_player_info() {
  return &player_info_;
}

// -------------------------------------------------------------------

// WebPay

// optional string order_id = 1;
inline bool WebPay::has_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebPay::set_has_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebPay::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebPay::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& WebPay::order_id() const {
  return *order_id_;
}
inline void WebPay::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void WebPay::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void WebPay::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPay::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* WebPay::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPay::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pb.SdkChannelType channel = 2;
inline bool WebPay::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WebPay::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WebPay::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WebPay::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::pb::SdkChannelType WebPay::channel() const {
  return static_cast< ::pb::SdkChannelType >(channel_);
}
inline void WebPay::set_channel(::pb::SdkChannelType value) {
  assert(::pb::SdkChannelType_IsValid(value));
  set_has_channel();
  channel_ = value;
}

// optional .pb.PlatformType platform = 3;
inline bool WebPay::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WebPay::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WebPay::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WebPay::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::pb::PlatformType WebPay::platform() const {
  return static_cast< ::pb::PlatformType >(platform_);
}
inline void WebPay::set_platform(::pb::PlatformType value) {
  assert(::pb::PlatformType_IsValid(value));
  set_has_platform();
  platform_ = value;
}

// optional .pb.WebPayCurrentType currency = 4;
inline bool WebPay::has_currency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WebPay::set_has_currency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WebPay::clear_has_currency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WebPay::clear_currency() {
  currency_ = 0;
  clear_has_currency();
}
inline ::pb::WebPayCurrentType WebPay::currency() const {
  return static_cast< ::pb::WebPayCurrentType >(currency_);
}
inline void WebPay::set_currency(::pb::WebPayCurrentType value) {
  assert(::pb::WebPayCurrentType_IsValid(value));
  set_has_currency();
  currency_ = value;
}

// optional float money = 5;
inline bool WebPay::has_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WebPay::set_has_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WebPay::clear_has_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WebPay::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline float WebPay::money() const {
  return money_;
}
inline void WebPay::set_money(float value) {
  set_has_money();
  money_ = value;
}

// optional string sdk_account = 6;
inline bool WebPay::has_sdk_account() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WebPay::set_has_sdk_account() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WebPay::clear_has_sdk_account() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WebPay::clear_sdk_account() {
  if (sdk_account_ != &::google::protobuf::internal::kEmptyString) {
    sdk_account_->clear();
  }
  clear_has_sdk_account();
}
inline const ::std::string& WebPay::sdk_account() const {
  return *sdk_account_;
}
inline void WebPay::set_sdk_account(const ::std::string& value) {
  set_has_sdk_account();
  if (sdk_account_ == &::google::protobuf::internal::kEmptyString) {
    sdk_account_ = new ::std::string;
  }
  sdk_account_->assign(value);
}
inline void WebPay::set_sdk_account(const char* value) {
  set_has_sdk_account();
  if (sdk_account_ == &::google::protobuf::internal::kEmptyString) {
    sdk_account_ = new ::std::string;
  }
  sdk_account_->assign(value);
}
inline void WebPay::set_sdk_account(const char* value, size_t size) {
  set_has_sdk_account();
  if (sdk_account_ == &::google::protobuf::internal::kEmptyString) {
    sdk_account_ = new ::std::string;
  }
  sdk_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPay::mutable_sdk_account() {
  set_has_sdk_account();
  if (sdk_account_ == &::google::protobuf::internal::kEmptyString) {
    sdk_account_ = new ::std::string;
  }
  return sdk_account_;
}
inline ::std::string* WebPay::release_sdk_account() {
  clear_has_sdk_account();
  if (sdk_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdk_account_;
    sdk_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPay::set_allocated_sdk_account(::std::string* sdk_account) {
  if (sdk_account_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_account_;
  }
  if (sdk_account) {
    set_has_sdk_account();
    sdk_account_ = sdk_account;
  } else {
    clear_has_sdk_account();
    sdk_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_id = 7;
inline bool WebPay::has_role_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WebPay::set_has_role_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WebPay::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WebPay::clear_role_id() {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    role_id_->clear();
  }
  clear_has_role_id();
}
inline const ::std::string& WebPay::role_id() const {
  return *role_id_;
}
inline void WebPay::set_role_id(const ::std::string& value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void WebPay::set_role_id(const char* value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void WebPay::set_role_id(const char* value, size_t size) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPay::mutable_role_id() {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  return role_id_;
}
inline ::std::string* WebPay::release_role_id() {
  clear_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_id_;
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPay::set_allocated_role_id(::std::string* role_id) {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    delete role_id_;
  }
  if (role_id) {
    set_has_role_id();
    role_id_ = role_id;
  } else {
    clear_has_role_id();
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 server_id = 8;
inline bool WebPay::has_server_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WebPay::set_has_server_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WebPay::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WebPay::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 WebPay::server_id() const {
  return server_id_;
}
inline void WebPay::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional float present = 9;
inline bool WebPay::has_present() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WebPay::set_has_present() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WebPay::clear_has_present() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WebPay::clear_present() {
  present_ = 0;
  clear_has_present();
}
inline float WebPay::present() const {
  return present_;
}
inline void WebPay::set_present(float value) {
  set_has_present();
  present_ = value;
}

// optional string product_id = 10;
inline bool WebPay::has_product_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WebPay::set_has_product_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void WebPay::clear_has_product_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void WebPay::clear_product_id() {
  if (product_id_ != &::google::protobuf::internal::kEmptyString) {
    product_id_->clear();
  }
  clear_has_product_id();
}
inline const ::std::string& WebPay::product_id() const {
  return *product_id_;
}
inline void WebPay::set_product_id(const ::std::string& value) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::kEmptyString) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(value);
}
inline void WebPay::set_product_id(const char* value) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::kEmptyString) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(value);
}
inline void WebPay::set_product_id(const char* value, size_t size) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::kEmptyString) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPay::mutable_product_id() {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::kEmptyString) {
    product_id_ = new ::std::string;
  }
  return product_id_;
}
inline ::std::string* WebPay::release_product_id() {
  clear_has_product_id();
  if (product_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = product_id_;
    product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPay::set_allocated_product_id(::std::string* product_id) {
  if (product_id_ != &::google::protobuf::internal::kEmptyString) {
    delete product_id_;
  }
  if (product_id) {
    set_has_product_id();
    product_id_ = product_id;
  } else {
    clear_has_product_id();
    product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WebPayRet

// optional .pb.WebPayResult result = 1;
inline bool WebPayRet::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebPayRet::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebPayRet::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebPayRet::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::pb::WebPayResult WebPayRet::result() const {
  return static_cast< ::pb::WebPayResult >(result_);
}
inline void WebPayRet::set_result(::pb::WebPayResult value) {
  assert(::pb::WebPayResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional string order_id = 2;
inline bool WebPayRet::has_order_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WebPayRet::set_has_order_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WebPayRet::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WebPayRet::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& WebPayRet::order_id() const {
  return *order_id_;
}
inline void WebPayRet::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void WebPayRet::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void WebPayRet::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPayRet::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* WebPayRet::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPayRet::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string error_msg = 3;
inline bool WebPayRet::has_error_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WebPayRet::set_has_error_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WebPayRet::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WebPayRet::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& WebPayRet::error_msg() const {
  return *error_msg_;
}
inline void WebPayRet::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void WebPayRet::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void WebPayRet::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPayRet::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  return error_msg_;
}
inline ::std::string* WebPayRet::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPayRet::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete error_msg_;
  }
  if (error_msg) {
    set_has_error_msg();
    error_msg_ = error_msg;
  } else {
    clear_has_error_msg();
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WebPayToDatabase

// optional string order_id = 1;
inline bool WebPayToDatabase::has_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebPayToDatabase::set_has_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebPayToDatabase::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebPayToDatabase::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& WebPayToDatabase::order_id() const {
  return *order_id_;
}
inline void WebPayToDatabase::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void WebPayToDatabase::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void WebPayToDatabase::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPayToDatabase::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* WebPayToDatabase::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPayToDatabase::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 currency = 2;
inline bool WebPayToDatabase::has_currency() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WebPayToDatabase::set_has_currency() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WebPayToDatabase::clear_has_currency() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WebPayToDatabase::clear_currency() {
  currency_ = 0u;
  clear_has_currency();
}
inline ::google::protobuf::uint32 WebPayToDatabase::currency() const {
  return currency_;
}
inline void WebPayToDatabase::set_currency(::google::protobuf::uint32 value) {
  set_has_currency();
  currency_ = value;
}

// optional float present = 3;
inline bool WebPayToDatabase::has_present() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WebPayToDatabase::set_has_present() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WebPayToDatabase::clear_has_present() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WebPayToDatabase::clear_present() {
  present_ = 0;
  clear_has_present();
}
inline float WebPayToDatabase::present() const {
  return present_;
}
inline void WebPayToDatabase::set_present(float value) {
  set_has_present();
  present_ = value;
}

// optional uint64 player_id = 4;
inline bool WebPayToDatabase::has_player_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WebPayToDatabase::set_has_player_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WebPayToDatabase::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WebPayToDatabase::clear_player_id() {
  player_id_ = GOOGLE_ULONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::uint64 WebPayToDatabase::player_id() const {
  return player_id_;
}
inline void WebPayToDatabase::set_player_id(::google::protobuf::uint64 value) {
  set_has_player_id();
  player_id_ = value;
}

// optional string sdk_account = 5;
inline bool WebPayToDatabase::has_sdk_account() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WebPayToDatabase::set_has_sdk_account() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WebPayToDatabase::clear_has_sdk_account() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WebPayToDatabase::clear_sdk_account() {
  if (sdk_account_ != &::google::protobuf::internal::kEmptyString) {
    sdk_account_->clear();
  }
  clear_has_sdk_account();
}
inline const ::std::string& WebPayToDatabase::sdk_account() const {
  return *sdk_account_;
}
inline void WebPayToDatabase::set_sdk_account(const ::std::string& value) {
  set_has_sdk_account();
  if (sdk_account_ == &::google::protobuf::internal::kEmptyString) {
    sdk_account_ = new ::std::string;
  }
  sdk_account_->assign(value);
}
inline void WebPayToDatabase::set_sdk_account(const char* value) {
  set_has_sdk_account();
  if (sdk_account_ == &::google::protobuf::internal::kEmptyString) {
    sdk_account_ = new ::std::string;
  }
  sdk_account_->assign(value);
}
inline void WebPayToDatabase::set_sdk_account(const char* value, size_t size) {
  set_has_sdk_account();
  if (sdk_account_ == &::google::protobuf::internal::kEmptyString) {
    sdk_account_ = new ::std::string;
  }
  sdk_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPayToDatabase::mutable_sdk_account() {
  set_has_sdk_account();
  if (sdk_account_ == &::google::protobuf::internal::kEmptyString) {
    sdk_account_ = new ::std::string;
  }
  return sdk_account_;
}
inline ::std::string* WebPayToDatabase::release_sdk_account() {
  clear_has_sdk_account();
  if (sdk_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdk_account_;
    sdk_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPayToDatabase::set_allocated_sdk_account(::std::string* sdk_account) {
  if (sdk_account_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_account_;
  }
  if (sdk_account) {
    set_has_sdk_account();
    sdk_account_ = sdk_account;
  } else {
    clear_has_sdk_account();
    sdk_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float money = 6;
inline bool WebPayToDatabase::has_money() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WebPayToDatabase::set_has_money() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WebPayToDatabase::clear_has_money() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WebPayToDatabase::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline float WebPayToDatabase::money() const {
  return money_;
}
inline void WebPayToDatabase::set_money(float value) {
  set_has_money();
  money_ = value;
}

// optional .pb.SdkChannelType channel = 7;
inline bool WebPayToDatabase::has_channel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WebPayToDatabase::set_has_channel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WebPayToDatabase::clear_has_channel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WebPayToDatabase::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::pb::SdkChannelType WebPayToDatabase::channel() const {
  return static_cast< ::pb::SdkChannelType >(channel_);
}
inline void WebPayToDatabase::set_channel(::pb::SdkChannelType value) {
  assert(::pb::SdkChannelType_IsValid(value));
  set_has_channel();
  channel_ = value;
}

// optional .pb.PlatformType platform = 8;
inline bool WebPayToDatabase::has_platform() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WebPayToDatabase::set_has_platform() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WebPayToDatabase::clear_has_platform() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WebPayToDatabase::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::pb::PlatformType WebPayToDatabase::platform() const {
  return static_cast< ::pb::PlatformType >(platform_);
}
inline void WebPayToDatabase::set_platform(::pb::PlatformType value) {
  assert(::pb::PlatformType_IsValid(value));
  set_has_platform();
  platform_ = value;
}

// -------------------------------------------------------------------

// WebPayToDatabaseRet

// optional bool is_ok = 1;
inline bool WebPayToDatabaseRet::has_is_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebPayToDatabaseRet::set_has_is_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebPayToDatabaseRet::clear_has_is_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebPayToDatabaseRet::clear_is_ok() {
  is_ok_ = false;
  clear_has_is_ok();
}
inline bool WebPayToDatabaseRet::is_ok() const {
  return is_ok_;
}
inline void WebPayToDatabaseRet::set_is_ok(bool value) {
  set_has_is_ok();
  is_ok_ = value;
}

// optional string order_id = 2;
inline bool WebPayToDatabaseRet::has_order_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WebPayToDatabaseRet::set_has_order_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WebPayToDatabaseRet::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WebPayToDatabaseRet::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& WebPayToDatabaseRet::order_id() const {
  return *order_id_;
}
inline void WebPayToDatabaseRet::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void WebPayToDatabaseRet::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void WebPayToDatabaseRet::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPayToDatabaseRet::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* WebPayToDatabaseRet::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPayToDatabaseRet::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_online = 3;
inline bool WebPayToDatabaseRet::has_is_online() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WebPayToDatabaseRet::set_has_is_online() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WebPayToDatabaseRet::clear_has_is_online() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WebPayToDatabaseRet::clear_is_online() {
  is_online_ = false;
  clear_has_is_online();
}
inline bool WebPayToDatabaseRet::is_online() const {
  return is_online_;
}
inline void WebPayToDatabaseRet::set_is_online(bool value) {
  set_has_is_online();
  is_online_ = value;
}

// optional .pb.GXDB_PayOrder order_record = 4;
inline bool WebPayToDatabaseRet::has_order_record() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WebPayToDatabaseRet::set_has_order_record() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WebPayToDatabaseRet::clear_has_order_record() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WebPayToDatabaseRet::clear_order_record() {
  if (order_record_ != NULL) order_record_->::pb::GXDB_PayOrder::Clear();
  clear_has_order_record();
}
inline const ::pb::GXDB_PayOrder& WebPayToDatabaseRet::order_record() const {
  return order_record_ != NULL ? *order_record_ : *default_instance_->order_record_;
}
inline ::pb::GXDB_PayOrder* WebPayToDatabaseRet::mutable_order_record() {
  set_has_order_record();
  if (order_record_ == NULL) order_record_ = new ::pb::GXDB_PayOrder;
  return order_record_;
}
inline ::pb::GXDB_PayOrder* WebPayToDatabaseRet::release_order_record() {
  clear_has_order_record();
  ::pb::GXDB_PayOrder* temp = order_record_;
  order_record_ = NULL;
  return temp;
}
inline void WebPayToDatabaseRet::set_allocated_order_record(::pb::GXDB_PayOrder* order_record) {
  delete order_record_;
  order_record_ = order_record;
  if (order_record) {
    set_has_order_record();
  } else {
    clear_has_order_record();
  }
}

// optional uint64 player_id = 5;
inline bool WebPayToDatabaseRet::has_player_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WebPayToDatabaseRet::set_has_player_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WebPayToDatabaseRet::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WebPayToDatabaseRet::clear_player_id() {
  player_id_ = GOOGLE_ULONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::uint64 WebPayToDatabaseRet::player_id() const {
  return player_id_;
}
inline void WebPayToDatabaseRet::set_player_id(::google::protobuf::uint64 value) {
  set_has_player_id();
  player_id_ = value;
}

// optional string error_msg = 6;
inline bool WebPayToDatabaseRet::has_error_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WebPayToDatabaseRet::set_has_error_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WebPayToDatabaseRet::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WebPayToDatabaseRet::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& WebPayToDatabaseRet::error_msg() const {
  return *error_msg_;
}
inline void WebPayToDatabaseRet::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void WebPayToDatabaseRet::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void WebPayToDatabaseRet::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebPayToDatabaseRet::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  return error_msg_;
}
inline ::std::string* WebPayToDatabaseRet::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebPayToDatabaseRet::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete error_msg_;
  }
  if (error_msg) {
    set_has_error_msg();
    error_msg_ = error_msg;
  } else {
    clear_has_error_msg();
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pb.SdkChannelType channel = 7;
inline bool WebPayToDatabaseRet::has_channel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WebPayToDatabaseRet::set_has_channel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WebPayToDatabaseRet::clear_has_channel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WebPayToDatabaseRet::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::pb::SdkChannelType WebPayToDatabaseRet::channel() const {
  return static_cast< ::pb::SdkChannelType >(channel_);
}
inline void WebPayToDatabaseRet::set_channel(::pb::SdkChannelType value) {
  assert(::pb::SdkChannelType_IsValid(value));
  set_has_channel();
  channel_ = value;
}

// optional .pb.WebPayResult result = 8;
inline bool WebPayToDatabaseRet::has_result() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WebPayToDatabaseRet::set_has_result() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WebPayToDatabaseRet::clear_has_result() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WebPayToDatabaseRet::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::pb::WebPayResult WebPayToDatabaseRet::result() const {
  return static_cast< ::pb::WebPayResult >(result_);
}
inline void WebPayToDatabaseRet::set_result(::pb::WebPayResult value) {
  assert(::pb::WebPayResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional float money = 9;
inline bool WebPayToDatabaseRet::has_money() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WebPayToDatabaseRet::set_has_money() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WebPayToDatabaseRet::clear_has_money() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WebPayToDatabaseRet::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline float WebPayToDatabaseRet::money() const {
  return money_;
}
inline void WebPayToDatabaseRet::set_money(float value) {
  set_has_money();
  money_ = value;
}

// optional .pb.PlatformType platform = 10;
inline bool WebPayToDatabaseRet::has_platform() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WebPayToDatabaseRet::set_has_platform() {
  _has_bits_[0] |= 0x00000200u;
}
inline void WebPayToDatabaseRet::clear_has_platform() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void WebPayToDatabaseRet::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::pb::PlatformType WebPayToDatabaseRet::platform() const {
  return static_cast< ::pb::PlatformType >(platform_);
}
inline void WebPayToDatabaseRet::set_platform(::pb::PlatformType value) {
  assert(::pb::PlatformType_IsValid(value));
  set_has_platform();
  platform_ = value;
}

// -------------------------------------------------------------------

// GXDB_PayOrder

// optional bool is_new = 1;
inline bool GXDB_PayOrder::has_is_new() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GXDB_PayOrder::set_has_is_new() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GXDB_PayOrder::clear_has_is_new() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GXDB_PayOrder::clear_is_new() {
  is_new_ = false;
  clear_has_is_new();
}
inline bool GXDB_PayOrder::is_new() const {
  return is_new_;
}
inline void GXDB_PayOrder::set_is_new(bool value) {
  set_has_is_new();
  is_new_ = value;
}

// optional string product_id = 2;
inline bool GXDB_PayOrder::has_product_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GXDB_PayOrder::set_has_product_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GXDB_PayOrder::clear_has_product_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GXDB_PayOrder::clear_product_id() {
  if (product_id_ != &::google::protobuf::internal::kEmptyString) {
    product_id_->clear();
  }
  clear_has_product_id();
}
inline const ::std::string& GXDB_PayOrder::product_id() const {
  return *product_id_;
}
inline void GXDB_PayOrder::set_product_id(const ::std::string& value) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::kEmptyString) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(value);
}
inline void GXDB_PayOrder::set_product_id(const char* value) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::kEmptyString) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(value);
}
inline void GXDB_PayOrder::set_product_id(const char* value, size_t size) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::kEmptyString) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GXDB_PayOrder::mutable_product_id() {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::kEmptyString) {
    product_id_ = new ::std::string;
  }
  return product_id_;
}
inline ::std::string* GXDB_PayOrder::release_product_id() {
  clear_has_product_id();
  if (product_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = product_id_;
    product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GXDB_PayOrder::set_allocated_product_id(::std::string* product_id) {
  if (product_id_ != &::google::protobuf::internal::kEmptyString) {
    delete product_id_;
  }
  if (product_id) {
    set_has_product_id();
    product_id_ = product_id;
  } else {
    clear_has_product_id();
    product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 vip_xp = 3;
inline bool GXDB_PayOrder::has_vip_xp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GXDB_PayOrder::set_has_vip_xp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GXDB_PayOrder::clear_has_vip_xp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GXDB_PayOrder::clear_vip_xp() {
  vip_xp_ = 0u;
  clear_has_vip_xp();
}
inline ::google::protobuf::uint32 GXDB_PayOrder::vip_xp() const {
  return vip_xp_;
}
inline void GXDB_PayOrder::set_vip_xp(::google::protobuf::uint32 value) {
  set_has_vip_xp();
  vip_xp_ = value;
}

// optional uint32 crystal_final = 4;
inline bool GXDB_PayOrder::has_crystal_final() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GXDB_PayOrder::set_has_crystal_final() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GXDB_PayOrder::clear_has_crystal_final() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GXDB_PayOrder::clear_crystal_final() {
  crystal_final_ = 0u;
  clear_has_crystal_final();
}
inline ::google::protobuf::uint32 GXDB_PayOrder::crystal_final() const {
  return crystal_final_;
}
inline void GXDB_PayOrder::set_crystal_final(::google::protobuf::uint32 value) {
  set_has_crystal_final();
  crystal_final_ = value;
}

// -------------------------------------------------------------------

// Sdk_PayResult

// optional .pb.WebPayRet result = 1;
inline bool Sdk_PayResult::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sdk_PayResult::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sdk_PayResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sdk_PayResult::clear_result() {
  if (result_ != NULL) result_->::pb::WebPayRet::Clear();
  clear_has_result();
}
inline const ::pb::WebPayRet& Sdk_PayResult::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::pb::WebPayRet* Sdk_PayResult::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::pb::WebPayRet;
  return result_;
}
inline ::pb::WebPayRet* Sdk_PayResult::release_result() {
  clear_has_result();
  ::pb::WebPayRet* temp = result_;
  result_ = NULL;
  return temp;
}
inline void Sdk_PayResult::set_allocated_result(::pb::WebPayRet* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional .pb.WebPay payInfo = 2;
inline bool Sdk_PayResult::has_payinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sdk_PayResult::set_has_payinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sdk_PayResult::clear_has_payinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sdk_PayResult::clear_payinfo() {
  if (payinfo_ != NULL) payinfo_->::pb::WebPay::Clear();
  clear_has_payinfo();
}
inline const ::pb::WebPay& Sdk_PayResult::payinfo() const {
  return payinfo_ != NULL ? *payinfo_ : *default_instance_->payinfo_;
}
inline ::pb::WebPay* Sdk_PayResult::mutable_payinfo() {
  set_has_payinfo();
  if (payinfo_ == NULL) payinfo_ = new ::pb::WebPay;
  return payinfo_;
}
inline ::pb::WebPay* Sdk_PayResult::release_payinfo() {
  clear_has_payinfo();
  ::pb::WebPay* temp = payinfo_;
  payinfo_ = NULL;
  return temp;
}
inline void Sdk_PayResult::set_allocated_payinfo(::pb::WebPay* payinfo) {
  delete payinfo_;
  payinfo_ = payinfo;
  if (payinfo) {
    set_has_payinfo();
  } else {
    clear_has_payinfo();
  }
}

// -------------------------------------------------------------------

// ServerCode

// optional int32 id = 1;
inline bool ServerCode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerCode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerCode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerCode::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ServerCode::id() const {
  return id_;
}
inline void ServerCode::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 code = 2;
inline bool ServerCode::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerCode::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerCode::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerCode::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ServerCode::code() const {
  return code_;
}
inline void ServerCode::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// ServerResponse

// optional int32 code = 1;
inline bool ServerResponse::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerResponse::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerResponse::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerResponse::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ServerResponse::code() const {
  return code_;
}
inline void ServerResponse::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// repeated .pb.ServerCode reg = 2;
inline int ServerResponse::reg_size() const {
  return reg_.size();
}
inline void ServerResponse::clear_reg() {
  reg_.Clear();
}
inline const ::pb::ServerCode& ServerResponse::reg(int index) const {
  return reg_.Get(index);
}
inline ::pb::ServerCode* ServerResponse::mutable_reg(int index) {
  return reg_.Mutable(index);
}
inline ::pb::ServerCode* ServerResponse::add_reg() {
  return reg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ServerCode >&
ServerResponse::reg() const {
  return reg_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ServerCode >*
ServerResponse::mutable_reg() {
  return &reg_;
}

// -------------------------------------------------------------------

// ServersMail

// optional string sid = 1;
inline bool ServersMail::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServersMail::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServersMail::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServersMail::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& ServersMail::sid() const {
  return *sid_;
}
inline void ServersMail::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void ServersMail::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void ServersMail::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServersMail::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* ServersMail::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServersMail::set_allocated_sid(::std::string* sid) {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (sid) {
    set_has_sid();
    sid_ = sid;
  } else {
    clear_has_sid();
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 online = 2;
inline bool ServersMail::has_online() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServersMail::set_has_online() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServersMail::clear_has_online() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServersMail::clear_online() {
  online_ = 0;
  clear_has_online();
}
inline ::google::protobuf::int32 ServersMail::online() const {
  return online_;
}
inline void ServersMail::set_online(::google::protobuf::int32 value) {
  set_has_online();
  online_ = value;
}

// optional string channel = 3;
inline bool ServersMail::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServersMail::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServersMail::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServersMail::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& ServersMail::channel() const {
  return *channel_;
}
inline void ServersMail::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void ServersMail::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void ServersMail::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServersMail::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* ServersMail::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServersMail::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 moldid = 4;
inline bool ServersMail::has_moldid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServersMail::set_has_moldid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServersMail::clear_has_moldid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServersMail::clear_moldid() {
  moldid_ = 0;
  clear_has_moldid();
}
inline ::google::protobuf::int32 ServersMail::moldid() const {
  return moldid_;
}
inline void ServersMail::set_moldid(::google::protobuf::int32 value) {
  set_has_moldid();
  moldid_ = value;
}

// optional string title = 5;
inline bool ServersMail::has_title() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServersMail::set_has_title() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServersMail::clear_has_title() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServersMail::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& ServersMail::title() const {
  return *title_;
}
inline void ServersMail::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void ServersMail::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void ServersMail::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServersMail::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* ServersMail::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServersMail::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 6;
inline bool ServersMail::has_content() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServersMail::set_has_content() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServersMail::clear_has_content() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServersMail::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& ServersMail::content() const {
  return *content_;
}
inline void ServersMail::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ServersMail::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ServersMail::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServersMail::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* ServersMail::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServersMail::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mail_award = 7;
inline bool ServersMail::has_mail_award() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServersMail::set_has_mail_award() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServersMail::clear_has_mail_award() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServersMail::clear_mail_award() {
  if (mail_award_ != &::google::protobuf::internal::kEmptyString) {
    mail_award_->clear();
  }
  clear_has_mail_award();
}
inline const ::std::string& ServersMail::mail_award() const {
  return *mail_award_;
}
inline void ServersMail::set_mail_award(const ::std::string& value) {
  set_has_mail_award();
  if (mail_award_ == &::google::protobuf::internal::kEmptyString) {
    mail_award_ = new ::std::string;
  }
  mail_award_->assign(value);
}
inline void ServersMail::set_mail_award(const char* value) {
  set_has_mail_award();
  if (mail_award_ == &::google::protobuf::internal::kEmptyString) {
    mail_award_ = new ::std::string;
  }
  mail_award_->assign(value);
}
inline void ServersMail::set_mail_award(const char* value, size_t size) {
  set_has_mail_award();
  if (mail_award_ == &::google::protobuf::internal::kEmptyString) {
    mail_award_ = new ::std::string;
  }
  mail_award_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServersMail::mutable_mail_award() {
  set_has_mail_award();
  if (mail_award_ == &::google::protobuf::internal::kEmptyString) {
    mail_award_ = new ::std::string;
  }
  return mail_award_;
}
inline ::std::string* ServersMail::release_mail_award() {
  clear_has_mail_award();
  if (mail_award_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mail_award_;
    mail_award_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServersMail::set_allocated_mail_award(::std::string* mail_award) {
  if (mail_award_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_award_;
  }
  if (mail_award) {
    set_has_mail_award();
    mail_award_ = mail_award;
  } else {
    clear_has_mail_award();
    mail_award_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 alv = 8;
inline bool ServersMail::has_alv() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServersMail::set_has_alv() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServersMail::clear_has_alv() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServersMail::clear_alv() {
  alv_ = 0;
  clear_has_alv();
}
inline ::google::protobuf::int32 ServersMail::alv() const {
  return alv_;
}
inline void ServersMail::set_alv(::google::protobuf::int32 value) {
  set_has_alv();
  alv_ = value;
}

// optional int32 blv = 9;
inline bool ServersMail::has_blv() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServersMail::set_has_blv() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServersMail::clear_has_blv() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServersMail::clear_blv() {
  blv_ = 0;
  clear_has_blv();
}
inline ::google::protobuf::int32 ServersMail::blv() const {
  return blv_;
}
inline void ServersMail::set_blv(::google::protobuf::int32 value) {
  set_has_blv();
  blv_ = value;
}

// optional int32 avip = 10;
inline bool ServersMail::has_avip() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ServersMail::set_has_avip() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ServersMail::clear_has_avip() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ServersMail::clear_avip() {
  avip_ = 0;
  clear_has_avip();
}
inline ::google::protobuf::int32 ServersMail::avip() const {
  return avip_;
}
inline void ServersMail::set_avip(::google::protobuf::int32 value) {
  set_has_avip();
  avip_ = value;
}

// optional int32 bvip = 11;
inline bool ServersMail::has_bvip() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ServersMail::set_has_bvip() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ServersMail::clear_has_bvip() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ServersMail::clear_bvip() {
  bvip_ = 0;
  clear_has_bvip();
}
inline ::google::protobuf::int32 ServersMail::bvip() const {
  return bvip_;
}
inline void ServersMail::set_bvip(::google::protobuf::int32 value) {
  set_has_bvip();
  bvip_ = value;
}

// -------------------------------------------------------------------

// PlayerMail

// optional int32 sid = 1;
inline bool PlayerMail::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerMail::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerMail::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerMail::clear_sid() {
  sid_ = 0;
  clear_has_sid();
}
inline ::google::protobuf::int32 PlayerMail::sid() const {
  return sid_;
}
inline void PlayerMail::set_sid(::google::protobuf::int32 value) {
  set_has_sid();
  sid_ = value;
}

// optional string to = 2;
inline bool PlayerMail::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerMail::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerMail::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerMail::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& PlayerMail::to() const {
  return *to_;
}
inline void PlayerMail::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void PlayerMail::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void PlayerMail::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMail::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* PlayerMail::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMail::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 moldid = 3;
inline bool PlayerMail::has_moldid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerMail::set_has_moldid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerMail::clear_has_moldid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerMail::clear_moldid() {
  moldid_ = 0;
  clear_has_moldid();
}
inline ::google::protobuf::int32 PlayerMail::moldid() const {
  return moldid_;
}
inline void PlayerMail::set_moldid(::google::protobuf::int32 value) {
  set_has_moldid();
  moldid_ = value;
}

// optional string title = 4;
inline bool PlayerMail::has_title() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerMail::set_has_title() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerMail::clear_has_title() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerMail::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& PlayerMail::title() const {
  return *title_;
}
inline void PlayerMail::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void PlayerMail::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void PlayerMail::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMail::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* PlayerMail::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMail::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 5;
inline bool PlayerMail::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerMail::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerMail::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerMail::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& PlayerMail::content() const {
  return *content_;
}
inline void PlayerMail::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void PlayerMail::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void PlayerMail::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMail::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* PlayerMail::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMail::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mail_award = 6;
inline bool PlayerMail::has_mail_award() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerMail::set_has_mail_award() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerMail::clear_has_mail_award() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerMail::clear_mail_award() {
  if (mail_award_ != &::google::protobuf::internal::kEmptyString) {
    mail_award_->clear();
  }
  clear_has_mail_award();
}
inline const ::std::string& PlayerMail::mail_award() const {
  return *mail_award_;
}
inline void PlayerMail::set_mail_award(const ::std::string& value) {
  set_has_mail_award();
  if (mail_award_ == &::google::protobuf::internal::kEmptyString) {
    mail_award_ = new ::std::string;
  }
  mail_award_->assign(value);
}
inline void PlayerMail::set_mail_award(const char* value) {
  set_has_mail_award();
  if (mail_award_ == &::google::protobuf::internal::kEmptyString) {
    mail_award_ = new ::std::string;
  }
  mail_award_->assign(value);
}
inline void PlayerMail::set_mail_award(const char* value, size_t size) {
  set_has_mail_award();
  if (mail_award_ == &::google::protobuf::internal::kEmptyString) {
    mail_award_ = new ::std::string;
  }
  mail_award_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMail::mutable_mail_award() {
  set_has_mail_award();
  if (mail_award_ == &::google::protobuf::internal::kEmptyString) {
    mail_award_ = new ::std::string;
  }
  return mail_award_;
}
inline ::std::string* PlayerMail::release_mail_award() {
  clear_has_mail_award();
  if (mail_award_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mail_award_;
    mail_award_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMail::set_allocated_mail_award(::std::string* mail_award) {
  if (mail_award_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_award_;
  }
  if (mail_award) {
    set_has_mail_award();
    mail_award_ = mail_award;
  } else {
    clear_has_mail_award();
    mail_award_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerForbid

// optional int32 sid = 1;
inline bool PlayerForbid::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerForbid::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerForbid::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerForbid::clear_sid() {
  sid_ = 0;
  clear_has_sid();
}
inline ::google::protobuf::int32 PlayerForbid::sid() const {
  return sid_;
}
inline void PlayerForbid::set_sid(::google::protobuf::int32 value) {
  set_has_sid();
  sid_ = value;
}

// optional string lordId = 2;
inline bool PlayerForbid::has_lordid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerForbid::set_has_lordid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerForbid::clear_has_lordid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerForbid::clear_lordid() {
  if (lordid_ != &::google::protobuf::internal::kEmptyString) {
    lordid_->clear();
  }
  clear_has_lordid();
}
inline const ::std::string& PlayerForbid::lordid() const {
  return *lordid_;
}
inline void PlayerForbid::set_lordid(const ::std::string& value) {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  lordid_->assign(value);
}
inline void PlayerForbid::set_lordid(const char* value) {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  lordid_->assign(value);
}
inline void PlayerForbid::set_lordid(const char* value, size_t size) {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  lordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerForbid::mutable_lordid() {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  return lordid_;
}
inline ::std::string* PlayerForbid::release_lordid() {
  clear_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lordid_;
    lordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerForbid::set_allocated_lordid(::std::string* lordid) {
  if (lordid_ != &::google::protobuf::internal::kEmptyString) {
    delete lordid_;
  }
  if (lordid) {
    set_has_lordid();
    lordid_ = lordid;
  } else {
    clear_has_lordid();
    lordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 forbidId = 3;
inline bool PlayerForbid::has_forbidid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerForbid::set_has_forbidid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerForbid::clear_has_forbidid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerForbid::clear_forbidid() {
  forbidid_ = 0;
  clear_has_forbidid();
}
inline ::google::protobuf::int32 PlayerForbid::forbidid() const {
  return forbidid_;
}
inline void PlayerForbid::set_forbidid(::google::protobuf::int32 value) {
  set_has_forbidid();
  forbidid_ = value;
}

// optional int32 time = 4;
inline bool PlayerForbid::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerForbid::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerForbid::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerForbid::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 PlayerForbid::time() const {
  return time_;
}
inline void PlayerForbid::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// SetPlayerVip

// optional int32 sid = 1;
inline bool SetPlayerVip::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetPlayerVip::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetPlayerVip::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetPlayerVip::clear_sid() {
  sid_ = 0;
  clear_has_sid();
}
inline ::google::protobuf::int32 SetPlayerVip::sid() const {
  return sid_;
}
inline void SetPlayerVip::set_sid(::google::protobuf::int32 value) {
  set_has_sid();
  sid_ = value;
}

// optional string lordId = 2;
inline bool SetPlayerVip::has_lordid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetPlayerVip::set_has_lordid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetPlayerVip::clear_has_lordid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetPlayerVip::clear_lordid() {
  if (lordid_ != &::google::protobuf::internal::kEmptyString) {
    lordid_->clear();
  }
  clear_has_lordid();
}
inline const ::std::string& SetPlayerVip::lordid() const {
  return *lordid_;
}
inline void SetPlayerVip::set_lordid(const ::std::string& value) {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  lordid_->assign(value);
}
inline void SetPlayerVip::set_lordid(const char* value) {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  lordid_->assign(value);
}
inline void SetPlayerVip::set_lordid(const char* value, size_t size) {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  lordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetPlayerVip::mutable_lordid() {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  return lordid_;
}
inline ::std::string* SetPlayerVip::release_lordid() {
  clear_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lordid_;
    lordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetPlayerVip::set_allocated_lordid(::std::string* lordid) {
  if (lordid_ != &::google::protobuf::internal::kEmptyString) {
    delete lordid_;
  }
  if (lordid) {
    set_has_lordid();
    lordid_ = lordid;
  } else {
    clear_has_lordid();
    lordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 typeValue = 3;
inline bool SetPlayerVip::has_typevalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetPlayerVip::set_has_typevalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetPlayerVip::clear_has_typevalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetPlayerVip::clear_typevalue() {
  typevalue_ = 0;
  clear_has_typevalue();
}
inline ::google::protobuf::int32 SetPlayerVip::typevalue() const {
  return typevalue_;
}
inline void SetPlayerVip::set_typevalue(::google::protobuf::int32 value) {
  set_has_typevalue();
  typevalue_ = value;
}

// -------------------------------------------------------------------

// ReCreateOder

// optional int32 sid = 1;
inline bool ReCreateOder::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReCreateOder::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReCreateOder::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReCreateOder::clear_sid() {
  sid_ = 0;
  clear_has_sid();
}
inline ::google::protobuf::int32 ReCreateOder::sid() const {
  return sid_;
}
inline void ReCreateOder::set_sid(::google::protobuf::int32 value) {
  set_has_sid();
  sid_ = value;
}

// optional string lordId = 2;
inline bool ReCreateOder::has_lordid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReCreateOder::set_has_lordid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReCreateOder::clear_has_lordid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReCreateOder::clear_lordid() {
  if (lordid_ != &::google::protobuf::internal::kEmptyString) {
    lordid_->clear();
  }
  clear_has_lordid();
}
inline const ::std::string& ReCreateOder::lordid() const {
  return *lordid_;
}
inline void ReCreateOder::set_lordid(const ::std::string& value) {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  lordid_->assign(value);
}
inline void ReCreateOder::set_lordid(const char* value) {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  lordid_->assign(value);
}
inline void ReCreateOder::set_lordid(const char* value, size_t size) {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  lordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReCreateOder::mutable_lordid() {
  set_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    lordid_ = new ::std::string;
  }
  return lordid_;
}
inline ::std::string* ReCreateOder::release_lordid() {
  clear_has_lordid();
  if (lordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lordid_;
    lordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReCreateOder::set_allocated_lordid(::std::string* lordid) {
  if (lordid_ != &::google::protobuf::internal::kEmptyString) {
    delete lordid_;
  }
  if (lordid) {
    set_has_lordid();
    lordid_ = lordid;
  } else {
    clear_has_lordid();
    lordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 money = 3;
inline bool ReCreateOder::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReCreateOder::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReCreateOder::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReCreateOder::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 ReCreateOder::money() const {
  return money_;
}
inline void ReCreateOder::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional string oredrId = 4;
inline bool ReCreateOder::has_oredrid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReCreateOder::set_has_oredrid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReCreateOder::clear_has_oredrid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReCreateOder::clear_oredrid() {
  if (oredrid_ != &::google::protobuf::internal::kEmptyString) {
    oredrid_->clear();
  }
  clear_has_oredrid();
}
inline const ::std::string& ReCreateOder::oredrid() const {
  return *oredrid_;
}
inline void ReCreateOder::set_oredrid(const ::std::string& value) {
  set_has_oredrid();
  if (oredrid_ == &::google::protobuf::internal::kEmptyString) {
    oredrid_ = new ::std::string;
  }
  oredrid_->assign(value);
}
inline void ReCreateOder::set_oredrid(const char* value) {
  set_has_oredrid();
  if (oredrid_ == &::google::protobuf::internal::kEmptyString) {
    oredrid_ = new ::std::string;
  }
  oredrid_->assign(value);
}
inline void ReCreateOder::set_oredrid(const char* value, size_t size) {
  set_has_oredrid();
  if (oredrid_ == &::google::protobuf::internal::kEmptyString) {
    oredrid_ = new ::std::string;
  }
  oredrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReCreateOder::mutable_oredrid() {
  set_has_oredrid();
  if (oredrid_ == &::google::protobuf::internal::kEmptyString) {
    oredrid_ = new ::std::string;
  }
  return oredrid_;
}
inline ::std::string* ReCreateOder::release_oredrid() {
  clear_has_oredrid();
  if (oredrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oredrid_;
    oredrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReCreateOder::set_allocated_oredrid(::std::string* oredrid) {
  if (oredrid_ != &::google::protobuf::internal::kEmptyString) {
    delete oredrid_;
  }
  if (oredrid) {
    set_has_oredrid();
    oredrid_ = oredrid;
  } else {
    clear_has_oredrid();
    oredrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string platNo = 5;
inline bool ReCreateOder::has_platno() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReCreateOder::set_has_platno() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReCreateOder::clear_has_platno() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReCreateOder::clear_platno() {
  if (platno_ != &::google::protobuf::internal::kEmptyString) {
    platno_->clear();
  }
  clear_has_platno();
}
inline const ::std::string& ReCreateOder::platno() const {
  return *platno_;
}
inline void ReCreateOder::set_platno(const ::std::string& value) {
  set_has_platno();
  if (platno_ == &::google::protobuf::internal::kEmptyString) {
    platno_ = new ::std::string;
  }
  platno_->assign(value);
}
inline void ReCreateOder::set_platno(const char* value) {
  set_has_platno();
  if (platno_ == &::google::protobuf::internal::kEmptyString) {
    platno_ = new ::std::string;
  }
  platno_->assign(value);
}
inline void ReCreateOder::set_platno(const char* value, size_t size) {
  set_has_platno();
  if (platno_ == &::google::protobuf::internal::kEmptyString) {
    platno_ = new ::std::string;
  }
  platno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReCreateOder::mutable_platno() {
  set_has_platno();
  if (platno_ == &::google::protobuf::internal::kEmptyString) {
    platno_ = new ::std::string;
  }
  return platno_;
}
inline ::std::string* ReCreateOder::release_platno() {
  clear_has_platno();
  if (platno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platno_;
    platno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReCreateOder::set_allocated_platno(::std::string* platno) {
  if (platno_ != &::google::protobuf::internal::kEmptyString) {
    delete platno_;
  }
  if (platno) {
    set_has_platno();
    platno_ = platno;
  } else {
    clear_has_platno();
    platno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string platId = 6;
inline bool ReCreateOder::has_platid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReCreateOder::set_has_platid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReCreateOder::clear_has_platid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReCreateOder::clear_platid() {
  if (platid_ != &::google::protobuf::internal::kEmptyString) {
    platid_->clear();
  }
  clear_has_platid();
}
inline const ::std::string& ReCreateOder::platid() const {
  return *platid_;
}
inline void ReCreateOder::set_platid(const ::std::string& value) {
  set_has_platid();
  if (platid_ == &::google::protobuf::internal::kEmptyString) {
    platid_ = new ::std::string;
  }
  platid_->assign(value);
}
inline void ReCreateOder::set_platid(const char* value) {
  set_has_platid();
  if (platid_ == &::google::protobuf::internal::kEmptyString) {
    platid_ = new ::std::string;
  }
  platid_->assign(value);
}
inline void ReCreateOder::set_platid(const char* value, size_t size) {
  set_has_platid();
  if (platid_ == &::google::protobuf::internal::kEmptyString) {
    platid_ = new ::std::string;
  }
  platid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReCreateOder::mutable_platid() {
  set_has_platid();
  if (platid_ == &::google::protobuf::internal::kEmptyString) {
    platid_ = new ::std::string;
  }
  return platid_;
}
inline ::std::string* ReCreateOder::release_platid() {
  clear_has_platid();
  if (platid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platid_;
    platid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReCreateOder::set_allocated_platid(::std::string* platid) {
  if (platid_ != &::google::protobuf::internal::kEmptyString) {
    delete platid_;
  }
  if (platid) {
    set_has_platid();
    platid_ = platid;
  } else {
    clear_has_platid();
    platid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ServersNotice

// optional string sid = 1;
inline bool ServersNotice::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServersNotice::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServersNotice::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServersNotice::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& ServersNotice::sid() const {
  return *sid_;
}
inline void ServersNotice::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void ServersNotice::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void ServersNotice::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServersNotice::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* ServersNotice::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServersNotice::set_allocated_sid(::std::string* sid) {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (sid) {
    set_has_sid();
    sid_ = sid;
  } else {
    clear_has_sid();
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string notice = 2;
inline bool ServersNotice::has_notice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServersNotice::set_has_notice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServersNotice::clear_has_notice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServersNotice::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& ServersNotice::notice() const {
  return *notice_;
}
inline void ServersNotice::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void ServersNotice::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void ServersNotice::set_notice(const char* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServersNotice::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* ServersNotice::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServersNotice::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HotResReload

// optional string sid = 1;
inline bool HotResReload::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HotResReload::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HotResReload::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HotResReload::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& HotResReload::sid() const {
  return *sid_;
}
inline void HotResReload::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void HotResReload::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void HotResReload::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HotResReload::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* HotResReload::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HotResReload::set_allocated_sid(::std::string* sid) {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (sid) {
    set_has_sid();
    sid_ = sid;
  } else {
    clear_has_sid();
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 2;
inline bool HotResReload::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HotResReload::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HotResReload::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HotResReload::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& HotResReload::type() const {
  return *type_;
}
inline void HotResReload::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void HotResReload::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void HotResReload::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HotResReload::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* HotResReload::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HotResReload::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OnlinePlayerCount

// optional int32 sid = 1;
inline bool OnlinePlayerCount::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnlinePlayerCount::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnlinePlayerCount::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnlinePlayerCount::clear_sid() {
  sid_ = 0;
  clear_has_sid();
}
inline ::google::protobuf::int32 OnlinePlayerCount::sid() const {
  return sid_;
}
inline void OnlinePlayerCount::set_sid(::google::protobuf::int32 value) {
  set_has_sid();
  sid_ = value;
}

// -------------------------------------------------------------------

// serverInfo

// optional int32 sid = 1;
inline bool serverInfo::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void serverInfo::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void serverInfo::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void serverInfo::clear_sid() {
  sid_ = 0;
  clear_has_sid();
}
inline ::google::protobuf::int32 serverInfo::sid() const {
  return sid_;
}
inline void serverInfo::set_sid(::google::protobuf::int32 value) {
  set_has_sid();
  sid_ = value;
}

// optional string info = 2;
inline bool serverInfo::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void serverInfo::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void serverInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void serverInfo::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& serverInfo::info() const {
  return *info_;
}
inline void serverInfo::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void serverInfo::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void serverInfo::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* serverInfo::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* serverInfo::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void serverInfo::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateGiftCode

// optional int32 operate = 1;
inline bool CreateGiftCode::has_operate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateGiftCode::set_has_operate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateGiftCode::clear_has_operate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateGiftCode::clear_operate() {
  operate_ = 0;
  clear_has_operate();
}
inline ::google::protobuf::int32 CreateGiftCode::operate() const {
  return operate_;
}
inline void CreateGiftCode::set_operate(::google::protobuf::int32 value) {
  set_has_operate();
  operate_ = value;
}

// optional int32 giftId = 2;
inline bool CreateGiftCode::has_giftid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateGiftCode::set_has_giftid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateGiftCode::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateGiftCode::clear_giftid() {
  giftid_ = 0;
  clear_has_giftid();
}
inline ::google::protobuf::int32 CreateGiftCode::giftid() const {
  return giftid_;
}
inline void CreateGiftCode::set_giftid(::google::protobuf::int32 value) {
  set_has_giftid();
  giftid_ = value;
}

// optional string giftName = 3;
inline bool CreateGiftCode::has_giftname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateGiftCode::set_has_giftname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateGiftCode::clear_has_giftname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateGiftCode::clear_giftname() {
  if (giftname_ != &::google::protobuf::internal::kEmptyString) {
    giftname_->clear();
  }
  clear_has_giftname();
}
inline const ::std::string& CreateGiftCode::giftname() const {
  return *giftname_;
}
inline void CreateGiftCode::set_giftname(const ::std::string& value) {
  set_has_giftname();
  if (giftname_ == &::google::protobuf::internal::kEmptyString) {
    giftname_ = new ::std::string;
  }
  giftname_->assign(value);
}
inline void CreateGiftCode::set_giftname(const char* value) {
  set_has_giftname();
  if (giftname_ == &::google::protobuf::internal::kEmptyString) {
    giftname_ = new ::std::string;
  }
  giftname_->assign(value);
}
inline void CreateGiftCode::set_giftname(const char* value, size_t size) {
  set_has_giftname();
  if (giftname_ == &::google::protobuf::internal::kEmptyString) {
    giftname_ = new ::std::string;
  }
  giftname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateGiftCode::mutable_giftname() {
  set_has_giftname();
  if (giftname_ == &::google::protobuf::internal::kEmptyString) {
    giftname_ = new ::std::string;
  }
  return giftname_;
}
inline ::std::string* CreateGiftCode::release_giftname() {
  clear_has_giftname();
  if (giftname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = giftname_;
    giftname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateGiftCode::set_allocated_giftname(::std::string* giftname) {
  if (giftname_ != &::google::protobuf::internal::kEmptyString) {
    delete giftname_;
  }
  if (giftname) {
    set_has_giftname();
    giftname_ = giftname;
  } else {
    clear_has_giftname();
    giftname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string beginTime = 4;
inline bool CreateGiftCode::has_begintime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateGiftCode::set_has_begintime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateGiftCode::clear_has_begintime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateGiftCode::clear_begintime() {
  if (begintime_ != &::google::protobuf::internal::kEmptyString) {
    begintime_->clear();
  }
  clear_has_begintime();
}
inline const ::std::string& CreateGiftCode::begintime() const {
  return *begintime_;
}
inline void CreateGiftCode::set_begintime(const ::std::string& value) {
  set_has_begintime();
  if (begintime_ == &::google::protobuf::internal::kEmptyString) {
    begintime_ = new ::std::string;
  }
  begintime_->assign(value);
}
inline void CreateGiftCode::set_begintime(const char* value) {
  set_has_begintime();
  if (begintime_ == &::google::protobuf::internal::kEmptyString) {
    begintime_ = new ::std::string;
  }
  begintime_->assign(value);
}
inline void CreateGiftCode::set_begintime(const char* value, size_t size) {
  set_has_begintime();
  if (begintime_ == &::google::protobuf::internal::kEmptyString) {
    begintime_ = new ::std::string;
  }
  begintime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateGiftCode::mutable_begintime() {
  set_has_begintime();
  if (begintime_ == &::google::protobuf::internal::kEmptyString) {
    begintime_ = new ::std::string;
  }
  return begintime_;
}
inline ::std::string* CreateGiftCode::release_begintime() {
  clear_has_begintime();
  if (begintime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = begintime_;
    begintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateGiftCode::set_allocated_begintime(::std::string* begintime) {
  if (begintime_ != &::google::protobuf::internal::kEmptyString) {
    delete begintime_;
  }
  if (begintime) {
    set_has_begintime();
    begintime_ = begintime;
  } else {
    clear_has_begintime();
    begintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endTime = 5;
inline bool CreateGiftCode::has_endtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateGiftCode::set_has_endtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateGiftCode::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateGiftCode::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& CreateGiftCode::endtime() const {
  return *endtime_;
}
inline void CreateGiftCode::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void CreateGiftCode::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void CreateGiftCode::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateGiftCode::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* CreateGiftCode::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateGiftCode::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gift = 6;
inline bool CreateGiftCode::has_gift() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateGiftCode::set_has_gift() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateGiftCode::clear_has_gift() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateGiftCode::clear_gift() {
  if (gift_ != &::google::protobuf::internal::kEmptyString) {
    gift_->clear();
  }
  clear_has_gift();
}
inline const ::std::string& CreateGiftCode::gift() const {
  return *gift_;
}
inline void CreateGiftCode::set_gift(const ::std::string& value) {
  set_has_gift();
  if (gift_ == &::google::protobuf::internal::kEmptyString) {
    gift_ = new ::std::string;
  }
  gift_->assign(value);
}
inline void CreateGiftCode::set_gift(const char* value) {
  set_has_gift();
  if (gift_ == &::google::protobuf::internal::kEmptyString) {
    gift_ = new ::std::string;
  }
  gift_->assign(value);
}
inline void CreateGiftCode::set_gift(const char* value, size_t size) {
  set_has_gift();
  if (gift_ == &::google::protobuf::internal::kEmptyString) {
    gift_ = new ::std::string;
  }
  gift_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateGiftCode::mutable_gift() {
  set_has_gift();
  if (gift_ == &::google::protobuf::internal::kEmptyString) {
    gift_ = new ::std::string;
  }
  return gift_;
}
inline ::std::string* CreateGiftCode::release_gift() {
  clear_has_gift();
  if (gift_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gift_;
    gift_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateGiftCode::set_allocated_gift(::std::string* gift) {
  if (gift_ != &::google::protobuf::internal::kEmptyString) {
    delete gift_;
  }
  if (gift) {
    set_has_gift();
    gift_ = gift;
  } else {
    clear_has_gift();
    gift_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 reuse = 7;
inline bool CreateGiftCode::has_reuse() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateGiftCode::set_has_reuse() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateGiftCode::clear_has_reuse() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateGiftCode::clear_reuse() {
  reuse_ = 0;
  clear_has_reuse();
}
inline ::google::protobuf::int32 CreateGiftCode::reuse() const {
  return reuse_;
}
inline void CreateGiftCode::set_reuse(::google::protobuf::int32 value) {
  set_has_reuse();
  reuse_ = value;
}

// optional int32 count = 8;
inline bool CreateGiftCode::has_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateGiftCode::set_has_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateGiftCode::clear_has_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateGiftCode::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 CreateGiftCode::count() const {
  return count_;
}
inline void CreateGiftCode::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional string platNo = 9;
inline bool CreateGiftCode::has_platno() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CreateGiftCode::set_has_platno() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CreateGiftCode::clear_has_platno() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CreateGiftCode::clear_platno() {
  if (platno_ != &::google::protobuf::internal::kEmptyString) {
    platno_->clear();
  }
  clear_has_platno();
}
inline const ::std::string& CreateGiftCode::platno() const {
  return *platno_;
}
inline void CreateGiftCode::set_platno(const ::std::string& value) {
  set_has_platno();
  if (platno_ == &::google::protobuf::internal::kEmptyString) {
    platno_ = new ::std::string;
  }
  platno_->assign(value);
}
inline void CreateGiftCode::set_platno(const char* value) {
  set_has_platno();
  if (platno_ == &::google::protobuf::internal::kEmptyString) {
    platno_ = new ::std::string;
  }
  platno_->assign(value);
}
inline void CreateGiftCode::set_platno(const char* value, size_t size) {
  set_has_platno();
  if (platno_ == &::google::protobuf::internal::kEmptyString) {
    platno_ = new ::std::string;
  }
  platno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateGiftCode::mutable_platno() {
  set_has_platno();
  if (platno_ == &::google::protobuf::internal::kEmptyString) {
    platno_ = new ::std::string;
  }
  return platno_;
}
inline ::std::string* CreateGiftCode::release_platno() {
  clear_has_platno();
  if (platno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platno_;
    platno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateGiftCode::set_allocated_platno(::std::string* platno) {
  if (platno_ != &::google::protobuf::internal::kEmptyString) {
    delete platno_;
  }
  if (platno) {
    set_has_platno();
    platno_ = platno;
  } else {
    clear_has_platno();
    platno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mark = 10;
inline bool CreateGiftCode::has_mark() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CreateGiftCode::set_has_mark() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CreateGiftCode::clear_has_mark() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CreateGiftCode::clear_mark() {
  if (mark_ != &::google::protobuf::internal::kEmptyString) {
    mark_->clear();
  }
  clear_has_mark();
}
inline const ::std::string& CreateGiftCode::mark() const {
  return *mark_;
}
inline void CreateGiftCode::set_mark(const ::std::string& value) {
  set_has_mark();
  if (mark_ == &::google::protobuf::internal::kEmptyString) {
    mark_ = new ::std::string;
  }
  mark_->assign(value);
}
inline void CreateGiftCode::set_mark(const char* value) {
  set_has_mark();
  if (mark_ == &::google::protobuf::internal::kEmptyString) {
    mark_ = new ::std::string;
  }
  mark_->assign(value);
}
inline void CreateGiftCode::set_mark(const char* value, size_t size) {
  set_has_mark();
  if (mark_ == &::google::protobuf::internal::kEmptyString) {
    mark_ = new ::std::string;
  }
  mark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateGiftCode::mutable_mark() {
  set_has_mark();
  if (mark_ == &::google::protobuf::internal::kEmptyString) {
    mark_ = new ::std::string;
  }
  return mark_;
}
inline ::std::string* CreateGiftCode::release_mark() {
  clear_has_mark();
  if (mark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mark_;
    mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateGiftCode::set_allocated_mark(::std::string* mark) {
  if (mark_ != &::google::protobuf::internal::kEmptyString) {
    delete mark_;
  }
  if (mark) {
    set_has_mark();
    mark_ = mark;
  } else {
    clear_has_mark();
    mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Language>() {
  return ::pb::Language_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::WebPayCurrentType>() {
  return ::pb::WebPayCurrentType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::SdkChannelType>() {
  return ::pb::SdkChannelType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::PlatformType>() {
  return ::pb::PlatformType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::WebPayResult>() {
  return ::pb::WebPayResult_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Web_2eproto__INCLUDED
