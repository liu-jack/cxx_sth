
#include <sstream>
#include <boost/bind.hpp>
#include <boost/typeof/typeof.hpp>

#include "GameServerSession.h"

#include "Logger.h"
#include "OS.h"

#include "../PlayerData.h"
#include "../DbProxyServer.h"

#include "../data/GuidInfoTable.h"
#include "../data/DbProxyDataMgr.h"
#include "../data/GlobalData.h"
#include "../data/PvPRankTable.h"
#include "data/PayItemTable.h"

#include "Base.h"
#include "def/MmoAssert.h"
#include "def/ObjectDefines.h"
#include "utility/Utility.h"
#include "utility/TimeParser.h"
#include "utility/TimePeriod.h"
#include "memory_buffer/NetPack.h"

#include "Enum.pb.h"
#include "Opcode.pb.h"
#include "ServerOpcode.pb.h"
#include "Login.pb.h"
#include "Character.pb.h"
#include "InterServer.pb.h"
#include "Quest.pb.h"
#include "Social.pb.h"
#include "Web.pb.h"
#include "PvP.pb.h"
#include "GameServer.pb.h"
#include "Module.pb.h"
#include "Palace.pb.h"
#include "Activity.pb.h"

#include "server_game/GameServer.h"

using namespace pb;


GameServerSession::HandlerArray GameServerSession::s_serverHandlers               =RegisteServerHandlers() ;
uint32                          GameServerSession::s_maxCachePlayerDays           =0 ;
uint32                          GameServerSession::s_maxCachePlayerCount          =0 ;
time_t                          GameServerSession::s_maxCacheOfflinePlayerSeconds =0 ;
time_t                          GameServerSession::s_playerDataSaveDiffMS         =0 ;

GameServerSession::HandlerArray GameServerSession::RegisteServerHandlers( void )
{
	HandlerArray handlers( pb::SERVER_OPCODE_COUNT ) ;

#undef Msg_Declare
#define Msg_Declare(e, MsgType) handlers[e] =&GameServerSession::Handle_##e;
#include "../msg/GlobalDataMsg.h"
#include "../msg/PlayerDataMsg.h"

	handlers[ pb::S_PING ]                           =&GameServerSession::HandlePing ;
	handlers[ pb::SG2D_REGISTER ]                    =&GameServerSession::HandleRegister ;
	handlers[ pb::SG2D_GET_PLAYER_LIST ]             =&GameServerSession::HandleGetPlayerList ;
	handlers[ pb::SG2D_CREATE_PLAYER ]               =&GameServerSession::HandleCreatePlayer ;
	handlers[ pb::SG2D_SELSEC_PALYER ]               =&GameServerSession::HandleSelectPlayer ;
	handlers[ pb::SG2D_PLAYER_OFFLINE ]              =&GameServerSession::HandlePlayerOffline ;
    handlers[ pb::SG2D_PLAYER_CHANGE_NAME ]          =&GameServerSession::HandlePlayerChangeName ;

	handlers[ pb::SG2D_UPDATA_STAGELEVEL_INFO ]      =&GameServerSession::HandleUpdateStageLevel ;
    handlers[ pb::SG2D_UPDATE_ENDLESS_LEVEL ]        =&GameServerSession::HandleUpdateStageLevelEndless ;

	handlers[ pb::SG2D_UPDATE_BAG]                   =&GameServerSession::HandleUpdateBag;

	handlers[ pb::SG2D_CREATE_PLAYER_DATA]           =&GameServerSession::HandleCreatePlayerData;
	handlers[ pb::SG2D_UPDATE_PLAYER_VALUE]          =&GameServerSession::HandleUpdatePlayerValue;

	handlers[ pb::SG2D_UPDATE_BATTLE_CHARS]          =&GameServerSession::HandleUpdateBattleChars;
	handlers[ pb::SG2D_CREATE_CHAR]                  =&GameServerSession::HandleCreateCharacter;
	handlers[ pb::SG2D_DELETE_CHARS]                 =&GameServerSession::HandleDestoryCharacters;
	handlers[ pb::SG2D_UPDATE_CHAR]                  =&GameServerSession::HandleUpdateCharacter;

	handlers[ pb::SG2D_CHECK_MAIL_RECIVERS_EXIST]    =&GameServerSession::HandleCheckMailReciVersExist;
	handlers[ pb::SG2D_BROADCAST_OFFLINE_MSG]        =&GameServerSession::HandleOffLineMsg;
	handlers[ pb::SG2D_MAIL_RECEVE_MAIL]             =&GameServerSession::HandleReceveMail;
	handlers[ pb::SG2D_MAIL_UPDATEMAILINFO]          =&GameServerSession::HandleUpdateMail;

	handlers[ pb::SG2D_UPDATE_BEHAVIOR_COUNTER]      =&GameServerSession::HandleUpdateQuestCounter;
	handlers[ pb::SG2D_COMPLETE_QUEST]               =&GameServerSession::HandleUpdateQuestComplete;
	handlers[ pb::SG2D_UPDATE_QUEST]                 =&GameServerSession::HandleUpdateQuestLog;

	handlers[ pb::SG2D_UPDATE_SELL_PROGRAM_INFO]     =&GameServerSession::HandleUpdateSellProgramInfo;
	handlers[ pb::SG2D_UPDATE_SELL_RANDOM_PROGRAME]  =&GameServerSession::HandleUpdateSellRandomProgram;
	handlers[ pb::SG2D_UPDATE_LOOT_RECORD]           =&GameServerSession::HandleUpdateLootRoundRecord;
    handlers[ pb::SG2D_UPDATE_LOTTERY_RECORD]        =&GameServerSession::HandleUpdateLotteryFreeRecord;


	handlers[ pb::SG2D_FRIEND_OPERATE ]              =&GameServerSession::HandleFriendOperate;
	handlers[ pb::SG2D_SOCIAL_SEARCH_PLAYERSINFO ]   =&GameServerSession::HandleFriendSearch;
	handlers[ pb::SG2D_UPDATE_FRIEND_DATA ]          =&GameServerSession::HandleFriendUpdateData;

	handlers[ pb::SG2D_UPDATE_GUILD_DATA ]           =&GameServerSession::HandleUpdateGuildInfo;
	handlers[ pb::SG2D_UPDATE_GUILD_MEMBER_DATA ]    =&GameServerSession::HandleUpdateGuildMemberInfo;
	handlers[ pb::SG2D_GUILD_SEARCH_PLAYERSINFO ]    =&GameServerSession::HandleGuildSearchPlayerInfo;
	handlers[ pb::SG2D_CREAT_GUILD ]                 =&GameServerSession::HandleCreateGuildInfo;

	handlers[ pb::SG2D_WEB_GET_PLAYER_LIST ]         =&GameServerSession::HandleWebGetPlayerList;

	handlers[pb::SG2D_GET_PLAYERINFO ]               =&GameServerSession::HandlerGetPlayerInfo;
	handlers[ pb::SG2D_PVP_CREATE_VIRTUAL_PLAYER ]   =&GameServerSession::HandlePvPCreateVirtualPlayer;

	handlers[ pb::SG2D_PVP_ENTRY_ARENA ]             =&GameServerSession::HandlePvPEntryArena ;
	handlers[ pb::SG2D_PVP_ARENA_PLAYER_INFO ]       =&GameServerSession::HandlePvPGetPlayerInfo ;
	handlers[ pb::SG2D_PVP_ARENA_FIGHT_RESULT_INFO ] =&GameServerSession::HandlePvPFightResultInfo ;
	handlers[ pb::SG2D_PVP_ARENA_FIGLE_RECORD_INFO ] =&GameServerSession::HandlePvPFightRecordInfo ;

	handlers[ pb::SG2D_SERVER_GOBAL_VALUE ]          =&GameServerSession::HandleServerGobalValue ;

	handlers[ pb::SG2D_PVP_GET_REWARD_RANK_LIST ]    =&GameServerSession::HandleGetPvPRewardRankList ;

	handlers[ pb::SG2D_PVP_ARENA_RANKING_LIST ]      =&GameServerSession::HandlePvPGetRankingList ;
	handlers[ pb::SG2D_PVP_MARK_FIGHT ]              =&GameServerSession::HandlePvPMarkFight ;

    handlers[ pb::SG2D_UPDATE_PLAYER_STRING]         =&GameServerSession::HandleUpdatePlayerString ;

	handlers[ pb::SG2D_WEB_PAY ]                     =&GameServerSession::HandleWebPay ;


	handlers[ pb::SG2D_UPDATE_MODULE_RECORD ]        =&GameServerSession::HandleUpdatePlayerModule ;
	handlers[ pb::SG2D_UPDATE_BUILDING_RECORD ]		 =&GameServerSession::HandleUpdatePlayerBuilding ;

	handlers[ pb::SG2D_GET_PLAYER_APPEND_DATA ]		 =&GameServerSession::HandleGetPlayerAppendData ;

	handlers[ pb::SG2D_UNLOCK_FORBIDEN ]		 =&GameServerSession::HandleForbidenPlayer;

	handlers[ pb::SG2D_SAVE_PLAYER_CACHE ]		 =&GameServerSession::HandleSavePlayerCache;
	handlers[ pb::SG2D_SAVE_ALL_PLAYER_CACHE ]		 =&GameServerSession::HandleSaveAllPlayerCache;
	
	handlers[ pb::SG2D_PLAYER_SET_NAME_AND_HEADID ]		 =&GameServerSession::HandleSetNameAndHeadId;
	
	handlers[ pb::SG2D_UPDATE_ACTIIVTY_DATA ]		 =&GameServerSession::HandleUpdateActivityData;
	handlers[ pb::SG2D_ACTIVITY_STAR_BOX_DELETE ]		 =&GameServerSession::HandleDeleteActivityStarBoxTable;
	handlers[ pb::SG2D_ACTIVITY_GENERAL_REWARD_DELETE ]		 =&GameServerSession::HandleDeleteGeneralRewardTable;
	handlers[ pb::SG2D_SELECT_COUNTRY]               = &GameServerSession::HandleSelectCountry;

	handlers[ pb::SG2D_SAVE_DBPROXY]               = &GameServerSession::HandleSaveDbproxy;

	return handlers ;
}



GameServerSession::GameServerSession( void )
:m_syncPlayerEnd(false)
,m_isRegistOk(false)
{
}

GameServerSession::~GameServerSession( void )
{
	time_t curTimeMS =sOS.TimeMS() ;
	for( PlayerDataMapItr itr =m_playerMap.begin(); itr != m_playerMap.end(); ++itr )
	{
		itr->second->SaveDirtyPart( curTimeMS ) ;
		sDataMgr.UnLoadPlayerData( itr->second.get() ) ;
	}
	m_playerMap.clear() ;
	// Tips: 这里仅从内存移除，因为暂时都是即时保存的
	sDBServer.GameServerUnRegister( this ) ;
	m_serverGobalValueMap.RemoveAllEntry() ;
	m_playerTableList.clear();
}


void GameServerSession::Update( uint64 nowTimeMS, int64 diffMS )
{
	Session::Update( nowTimeMS, diffMS ) ;
	PlayerDataMapItr endItr =m_playerMap.end() ;
	for( PlayerDataMapItr itr =m_playerMap.begin(); itr != endItr; ++itr )
	{
		PlayerDataPtr &pData =itr->second ;
// 		if( pData->GetIsOffline() )
// 		{
// 			continue ;
// 		}

		if( pData->GetLastSaveTime() + GetPlayerDataSaveDiffMS() < static_cast<time_t>( nowTimeMS ) )
		{
			pData->SaveDirtyPart( nowTimeMS ) ;
		}
	}

	if( !m_playerTableList.empty())
	{
		PlayerTable *pTable = m_playerTableList.front();
		CachePlayerData(pTable);
		m_playerTableList.pop_front();
	}
	if(m_playerTableList.empty() && m_isRegistOk  && !m_syncPlayerEnd)
	{
		pb::SD2G_All_player_has_sync msg;
		msg.set_result(true);
		Send(pb::SD2G_PLAYER_HAS_ALL_SYNC,msg);
		m_syncPlayerEnd = true;
	}
}


void GameServerSession::OnPlayerOnline( PlayerDataPtr &ptr )
{
	if( ptr->GetIsOffline() )
	{
		TableByPlayerId &byId =m_offlinePlayers.get<ById>() ;
		size_t eraseCount =byId.erase( ptr->GetPlayerId() ) ;
		if( eraseCount <=0 )
		{
			WLOG( "GameServerSession::OnPlayerOnline() be invoke twice time ??? " ) ;
		}
	}

	ptr->SetIsOffline( false ) ;
	m_gloabalDataPtr->OnPlayerOnline(ptr->GetPlayerId(),true);
	//uint32 curPlayers = (uint32)m_playerMap.size();
	//if( !m_offlinePlayers.empty() && curPlayers > GetMaxCachePlayerCount() )
	//{
	//	uint32 needRemove = curPlayers - GetMaxCachePlayerCount();
	//	TableByPlayerTime &byTime =m_offlinePlayers.get<ByTime>() ;
	//	time_t limitTime = sOS.TimeSeconds() - GetMaxCacheOfflinePlayerSeconds() ;
	//	TableByPlayerTimeItr endItr =byTime.upper_bound( limitTime ) ;
	//	TableByPlayerTimeItr itr =byTime.begin();
	//	for( ; itr != endItr && needRemove > 0; ++itr,--needRemove )
	//	{
	//		ASSERT( itr->offlineTime <= limitTime ) ;
	//		RemovePlayerDataFromMap( itr->playerId ) ;
	//		NLOG( "player id: %llu remove from m_playerMap, no cache the player .", itr->playerId ) ;
	//	}

	//	byTime.erase( byTime.begin(), itr ) ;
	//}
}

void GameServerSession::OnPlayerOffLine( uint64 playerId )
{
	PlayerDataMapItr itr =m_playerMap.find( playerId ) ;
	if( itr == m_playerMap.end() )
	{
		ELOG( "GameServerSession::OnPlayerOffLine() can not find player %llu", playerId ) ;
		return ;
	}

	time_t curTimeMS =sOS.TimeMS() ;

	// 保存
	itr->second->SaveDirtyPart( curTimeMS ) ;

	m_gloabalDataPtr->OnPlayerOnline(playerId,false);

	AddToOfflineTable( itr->second ) ;

	// 竞技场状态修改, 当在挑战中突然离开游戏, 要取消自己与挑战对象的战斗记录
	//PvPRankTable *pSelfRank   =sDataMgr.GetTable<PvPRankTable>()->GetEntryByKey( playerId ) ;
	//if( pSelfRank != NULL && pSelfRank->extra.targetPlayerId != 0 )
	//{
	//	ASSERT( pSelfRank->extra.isFighting ) ;

	//	pSelfRank->extra.isFighting     =false ;

	//	PvPRankTable *pTargetRank   =sDataMgr.GetTable<PvPRankTable>()->GetEntryByKey( pSelfRank->extra.targetPlayerId ) ;
	//	if( pTargetRank != NULL )
	//	{
	//		ASSERT( pTargetRank->extra.isFighting ) ;

	//		// 被打的人，不应该可以挑战
	//		ASSERT( pTargetRank->extra.targetPlayerId == 0 ) ;

	//		pTargetRank->extra.isFighting     =false ;
	//		pTargetRank->extra.targetPlayerId =0 ;
	//	}

	//	pSelfRank->extra.targetPlayerId =0 ;
	//}

	NLOG( "player id: %llu is remian in m_playerMap, record in m_offlinePlayers use to memory cache !", playerId ) ;
}


void GameServerSession::AddToOfflineTable( PlayerDataPtr &ptr )
{
	ptr->SetIsOffline( true ) ;

	TableByPlayerId &byId =m_offlinePlayers.get<ById>() ;

	bool isInsert = byId.insert( OfflineData( ptr->m_PlayerTable->playerId, ::time( NULL ) ) ).second ;
	if( !isInsert )
	{
		ELOG( "GameServerSession::AddToOfflineTable() find %llu is existed in offline record!", ptr->m_PlayerTable->playerId ) ;
		return ;
	}

}

PlayerDataPtr GameServerSession::GetOrLoadPlayerData( uint64 playerId )
{
	PlayerDataMapItr itr =m_playerMap.find( playerId ) ;
	if( itr != m_playerMap.end() )
	{
		return itr->second ;
	}

	ASSERT( itr == m_playerMap.end() ) ;

	PlayerDataPtr dataPtr( sDataMgr.LoadPlayerData( playerId ) );
	if( !dataPtr )
	{
		ELOG( "GameServerSession::GetPlayerData( playerId: %llu ) can not find player ~ .", playerId ) ;
		return dataPtr ;
	}

	// 设置离线
	dataPtr->SetIsOffline( true ) ;

	if( m_playerMap.size() < GetMaxCachePlayerCount() )
	{
		dataPtr->SetGloabalData(m_gloabalDataPtr);
		bool isInsert =AddPlayerDataToMap( dataPtr ) ;
		ASSERT( isInsert ) ;
		AddToOfflineTable( dataPtr ) ;
	}

	return dataPtr ;
}

PlayerDataPtr GameServerSession::GetPlayerData( uint64 playerId )
{
	PlayerDataMapItr itr =m_playerMap.find( playerId ) ;
	if( itr != m_playerMap.end() )
	{
		return itr->second ;
	}

	return PlayerDataPtr() ;
}

PlayerDataPtr GameServerSession::GetPlayerData( const string &name )
{
	uint64 playerId =sDataMgr.GetPlayerIdByName( name ) ;
	return GetPlayerData( playerId ) ;
}


// MsgPlayerBaseData include MsgPlayerBaseInfo
bool GameServerSession::GetPlayerBaseData( uint64 playerId, MsgPlayerBaseData &data, int dataFlag /*=0*/ )
{
	bool isOk =false ;

	PlayerDataPtr ptr =GetPlayerData( playerId ) ;
	if( ptr )
	{
		ptr->WritePlayerInfo( data, dataFlag );
		isOk =true ;
	}
	else
	{
		MsgPlayerBaseData *pData =sDataMgr.GetPlayerBaseData( playerId, GetPairId().second, GetPairId().first ) ;

		// get frrom database
		if( pData != NULL )
		{
			isOk =true ;
			switch( dataFlag )
			{
			case pb::PLAYER_BASE_DATA_JUST_PVP_BASE_INFO:
				{
					const pb::GS2C_CharacterStorage &cardsInfo =pData->team_info().character_info() ;
					pb::GS2C_CharacterStorage *pDstCaardsInfo  =data.mutable_team_info()->mutable_character_info() ;

					data.mutable_info()->CopyFrom( pData->info() ) ;

					pDstCaardsInfo->mutable_battle_character()->CopyFrom( cardsInfo.battle_character() ) ;
					for( int i =0; i < cardsInfo.characters_size(); ++i )
					{
						const pb::GS2C_CharacterCreate &card =cardsInfo.characters( i ) ;
						pb::GS2C_CharacterCreate *pC =pDstCaardsInfo->mutable_characters()->Add() ;
						pC->set_id( card.id() ) ;
						pC->set_protoid( card.protoid() ) ;
						pC->set_quality(1);// card.values().values( pb::CHAR_FIELD_QUALITY ) ) ;
					}
				} break ;

			default:
				data.CopyFrom(*pData);
			}

		}
	}

	return isOk ;
}

bool GameServerSession::GetPlayerBaseInfo( uint64 playerId, pb::MsgPlayerBaseInfo &data )
{
	bool isOk =false ;

	PlayerDataPtr ptr =GetPlayerData( playerId ) ;
	if( ptr )
	{
		ptr->WritePlayerBaseInfo(data);
		isOk =true ;
	}
	else
	{
		MsgPlayerBaseData *pData =sDataMgr.GetPlayerBaseData( playerId, GetPairId().second, GetPairId().first ) ;

		// get frrom database
		if( pData != NULL )
		{
			isOk =true ;
			data.CopyFrom( pData->info() );
		}
	}

	return isOk ;
}

bool GameServerSession::GetPlayerBaseData( const string &name, MsgPlayerBaseData &data )
{
	uint64 playerId =sDataMgr.GetPlayerIdByName( name ) ;
	if( playerId == 0 )
	{
		return false ;
	}

	return GetPlayerBaseData( playerId, data ) ;
}

bool GameServerSession::WriteFriendInfo(const string &name, pb::Friend_list_Record& info)
{
	uint64 playerId =sDataMgr.GetPlayerIdByName( name ) ;
	if( playerId == 0 )
	{
		return false ;
	}
	return WriteFriendInfo( playerId, info) ;
}

bool GameServerSession::WriteFriendInfo(uint64 friendId, pb::Friend_list_Record& info)
{
	MsgPlayerBaseData data;
	if(GetPlayerBaseData(friendId,data))
	{
		const MsgPlayerBaseInfo& baseInfo = data.info();
		info.set_friend_name(baseInfo.player_name());
		info.set_friend_guid(baseInfo.playerid());
		info.set_head_icon(baseInfo.card_proid());
		info.set_vip_level(baseInfo.vip_level());
		info.set_level(baseInfo.level());
		info.set_power(baseInfo.power());
		info.set_guild_name(baseInfo.guild_name());
		info.set_is_send_ap(false);
		info.set_is_receive_ap(false);
		info.set_is_online(baseInfo.isonline());
		info.set_last_onlin_time(baseInfo.last_login());
		info.set_request_time(time(NULL));
		return true;
	}
	return false;
}


bool GameServerSession::AddPlayerDataToMap( const PlayerDataPtr &ptr )
{
	DLOG( "GameServerSession::AddPlayerDataToMap( player id: %llu )", ptr->GetPlayerId() ) ;
	bool isInsert =m_playerMap.insert( std::make_pair( ptr->GetPlayerId(), ptr ) ).second ;
	return isInsert ;
}

void GameServerSession::RemovePlayerDataFromMap( uint64 playerId )
{
	DLOG( "GameServerSession::RemovePlayerDataFromMap( player id: %llu )", playerId ) ;
	PlayerDataMapItr itr =m_playerMap.find( playerId ) ;
	if( itr != m_playerMap.end() )
	{
		PlayerDataPtr &ptr =itr->second ;
		//ASSERT( ptr->GetIsOffline() ) ;

		time_t curTimeMS =sOS.TimeMS() ;
		ptr->SaveDirtyPart( curTimeMS ) ;

		sDataMgr.UnLoadPlayerData( ptr.get() ) ;

		ptr.reset() ;

		m_playerMap.erase( itr ) ;

	/*	pb::SG2D_Player_Id info ;
		info.set_player_id(playerId);
		Send(pb::SD2G_PLAYER_CACHE_REMOVE_SYNC,info);
		DLOG( "GameServerSession::RemovePlayerDataFromMap( player id: %llu ) success!!", playerId ) ;*/
	}
}

bool GameServerSession::HandleNetPack( NetPack &pack )
{
	// All server packet !
	int opCode               =pack.GetOpcode() ;

	HandlerArray &funTable   =s_serverHandlers ;

	ASSERT( static_cast<size_t>( opCode ) < funTable.size() ) ;
	NetPackHandler packetFun = funTable[ opCode ] ;

	if( packetFun )
	{
		(this->*packetFun)( pack ) ;
		return true ;
	}

	return false ;
}



static uint32 GetGuidSeed( const int32 region_id, const int32 server_id, const std::string &table_name, const string &guid_name, OBJECT_TYPE obj_type)
{
	Guid min_guid(obj_type, region_id, server_id, 0 ) ;
	Guid max_guid(obj_type, region_id, server_id, -1) ;

	MMO_ASSERT( min_guid < max_guid ) ;

	CMySqlConnection* pConn = sDatabase.GetConnection() ;
	if( pConn == NULL )
	{
		ASSERT( false ) ;
		return 1 ;
	}

	uint64 cur_guid = 0;
	CMysqlRstPtr pResult =pConn->QueryFormat( "SELECT MAX( %s ) FROM %s WHERE %s > %llu AND %s < %llu"
		, guid_name.c_str(), table_name.c_str(), guid_name.c_str(), static_cast<uint64>(min_guid), guid_name.c_str(), static_cast<uint64>(max_guid) ) ;

	if( pResult )
	{
		Field* pField = pResult->Fetch();
		cur_guid = pField[0].GetUInt64();
	}
	else
	{
		cur_guid =min_guid ;
	}

	if( cur_guid < (uint64)min_guid )
	{
		cur_guid =min_guid ;
	}

	sDatabase.PutConnection( pConn ) ;

	return  Guid::LowGuid( cur_guid ) ;
}

void GameServerSession::InitGuidInfo( void )
{
	m_guidInfo.clear() ;
	//sDataMgr.LoadGuidInfo( GetAddress().first, GetAddress().second, m_guidInfo ) ;

	// 玩家Guid信息
	GuidInfoTable &playerGuid =m_guidInfo[TYPE_PLAYER] ;
	playerGuid.type           =TYPE_PLAYER;
	playerGuid.regionId       =GetPairId().second ;
	playerGuid.serverId       =GetPairId().first ;
	playerGuid.curSeed        =GetGuidSeed( GetPairId().second, GetPairId().first, "player", "playerId", static_cast<OBJECT_TYPE>( playerGuid.type )) ;

	// 公会Guid信息
	/*GuidInfoTable &guildGuid =m_guidInfo[TYPE_GUILD] ;
	guildGuid.type           =TYPE_GUILD ;
	guildGuid.regionId       =GetPairId().second ;
	guildGuid.serverId       =GetPairId().first ;
	guildGuid.curSeed        =GetGuidSeed( GetPairId().second, GetPairId().first, "guilds", "guild_id", static_cast<OBJECT_TYPE>( guildGuid.type ) ) ;*/
}


void GameServerSession::InitPlayerDataCache( void )
{
	// '12/01/2014'  请问是几月？同理，'2014-12-01'又是几月？ MYSQL是凭什么知道的呢？ 而STR_TO_DATE('2014-12-01 12:59:59','%Y-%m-%d %H:%i:%s'); 则非常明确。
	NLOG( "Loading playerdata cache.............................." ) ;

	int y =0, m =0, d =0 ;
	uint32 limitDays =GetMaxCachePlayerDays() < 1 ? 1 : GetMaxCachePlayerDays() ;

	time_t loadLimit =::time( NULL ) - limitDays * 24 * 60 * 60 ;
	if( TimeT2Date( loadLimit, y, m, d ) )
	{
		size_t limitCount = static_cast<size_t>( GetMaxCachePlayerCount()) ;
		if( limitCount < 1 )
		{
			limitCount =1 ;
		}

		std::string sql ;
		Utility::FormatString( sql, "SELECT * FROM %s WHERE accountId != 0 AND lockReason != 2  AND regionId =%u AND serverId =%u AND lastLogin > STR_TO_DATE( '%u-%u-%u','%%Y-%%m-%%d') ORDER BY lastLogin DESC LIMIT %u ; "
			, PlayerTable::GetTableName(), GetPairId().second, GetPairId().first, y, m, d, limitCount ) ;
		//std::vector<PlayerData*> vecPlayerData ;
		//sDataMgr.LoadPlayerData( sql.c_str(),vecPlayerData ) ;
		uint32 playerCacheCount = 0;
		std::vector<PlayerTable*> vecPlayerTable ;
		if (!sDataMgr.LoadPlayerTable(sql.c_str(),vecPlayerTable))
		{
			return;
		}
		BOOST_AUTO( itrBeg, vecPlayerTable.begin() );
		BOOST_AUTO( itrEnd, vecPlayerTable.end() );
		for( ; itrBeg != itrEnd; ++itrBeg )
		{
			PlayerTable *pPlayerTable =*itrBeg ;
			m_playerTableList.push_back(pPlayerTable ) ;
			playerCacheCount++;
		}
		NLOG( "total %u player add to cache .", playerCacheCount );
	}
	else
	{
		ASSERT( false ) ;
		ELOG( " GameServerSession::InitPlayerDataCache( void ) fail~~~~!!!!!" ) ;
	}
}

void GameServerSession::CachePlayerData(PlayerTable *pPlayerTable)
{
	if (m_playerMap.find(pPlayerTable->playerId) == m_playerMap.end())
	{
		PlayerData* tempData = sDataMgr.LoadOnePlayerData(pPlayerTable);
		if (tempData)
		{
			PlayerDataPtr dataPtr(tempData) ;
			NLOG( "player %llu add to cache ~!", dataPtr->m_PlayerTable->playerId ) ;
			dataPtr->SetGloabalData(m_gloabalDataPtr);
			bool isInsert =AddPlayerDataToMap( dataPtr ) ;
			ASSERT( isInsert ) ;
			if( !isInsert )
			{
				ELOG( "GameServerSession::InitPlayerDataCache() AddPlayerDataToMap() fail palyer datat not cache ....................." ) ;
			}
			AddToOfflineTable( dataPtr ) ;

			pb::SyncPlayerCacheData  synData;
			synData.set_account_id(dataPtr->GetPlayerAccountId());
			dataPtr->WriteModuleInfo(*synData.mutable_append()->mutable_module());
			dataPtr->WriteBuildInfo(*synData.mutable_append()->mutable_building());
			dataPtr->WriteAllPlayerData(synData.mutable_all_data());
			Send(SD2G_PLAYER_CACHE_DATA_SYNC,synData);
		}
	}
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PvP
//void GameServerSession::InitPvPRankList( void )
//{
//	NLOG( "Init pvp rank........" ) ;
//
//	std::vector<  PvPRankTable* > vec ;
//
//	sDataMgr.LoadTableByServerLimit( GetPairId().second, GetPairId().first, vec ) ;
//
//	std::for_each( vec.begin(), vec.end(), boost::bind( &PvPRankMap::AddToPtrMap, &m_pvpRank, _1 ) ) ;
//}
//
//int GameServerSession::AddPvPRank( uint64 playerId, uint64 accountId, uint32 rank )
//{
//	if( m_pvpRank.GetElement( rank ) != NULL )
//	{
//		ASSERT( false ) ;
//		return 0 ;
//	}
//
//	if( sDataMgr.GetTable<PvPRankTable>()->CanFindByKey( playerId ) )
//	{
//		return 0 ;
//	}
//
//	PvPRankTable newRecord ;
//	newRecord.rank        =rank ;
//	newRecord.historyRank =rank ;
//	newRecord.playerId    =playerId ;
//	newRecord.accountId   =accountId ;
//	newRecord.regionId    =GetPairId().second ;
//	newRecord.serverId    =GetPairId().first ;
//
//	m_pvpRank.AddAndAddToCache( &newRecord ) ;
//
//	return rank ;
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Gobal value
void GameServerSession::InitServerGobalValue( void )
{
	NLOG( "Init pvp rank........" ) ;

	std::vector< ServerGobalValueTable* > vec ;

	sDataMgr.LoadTableByServerLimit( GetPairId().second, GetPairId().first, vec ) ;

	std::for_each( vec.begin(), vec.end(), boost::bind( &ServerGobalValueMap::AddToPtrMap, &m_serverGobalValueMap, _1 ) ) ;
}



void GameServerSession::HandlePing( NetPack &packet )
{
	Session::HandlePing( packet, pb::S_PONG ) ;
}


void GameServerSession::HandleRegister( NetPack &packet )
{
	if( GetIsVerification() )
	{
		WLOG( "Had register, can not register again ........................" ) ;
		return ;
	}

	pb::SG2D_RegisterInfo info ;
	packet >> info ;

	SetPairId( SessionPairId( info.server_id(), info.region_id() ) ) ;
	SetAddress( SessionAddress( info.port(), info.ip() ) ) ;

	//NLOG( "HandleRegister(): %s", info.DebugString().c_str() );

	pb::SG2D_RegisterInfoRet retInfo ;
	DbProxyServer::ServerRegisterResult ret =sDBServer.GameServerRegister( this ) ;
	switch( ret )
	{
	case DbProxyServer::SERVER_REGISTER_OK:
		{
			retInfo.set_result( pb::SERVER_REGISTER_OK ) ;

			NLOG( "%s,id:%llu, pairID(%u,%u), address(%s, %s) register ok"
				, GetSessionTypeName(), GetSessionId(), GetPairId().second, GetPairId().first, GetAddress().second.c_str(), GetAddress().first.c_str() ) ;

			// Guid info
			InitGuidInfo();
			
            m_gloabalDataPtr.reset(sDataMgr.LoadGlobalData(GetPairId().first, GetPairId().second));
			if (m_gloabalDataPtr.get())
			{
                m_gloabalDataPtr->SetSession(this);
                m_gloabalDataPtr->OnGameServerRegist();
			}

			// PvP rank
			//InitPvPRankList() ;
			//retInfo.set_pvp_table_size( m_pvpRank.Size() ) ;

			// Player cache
			InitPlayerDataCache() ;
			m_isRegistOk = true;
		} break ;

	case DbProxyServer::SERVER_REGISTER_FAIL_ID:
		{
			SetIsNeedClose( true ) ;
			retInfo.set_result( pb::SERVER_REGISTER_FAIL_ID ) ;
		} break ;

	case DbProxyServer::SERVER_REGISTER_FAIL_ADDRESS:
		{
			SetIsNeedClose( true ) ;
			retInfo.set_result( pb::SERVER_REGISTER_FAIL_ADDRESS ) ;
		} break ;

	default:
		ASSERT( false ) ;
	}

	Send( pb::SD2G_REGISTER_RET, retInfo ) ;
}

void GameServerSession::HandleGetPlayerList( NetPack &packet )
{
	pb::SG2D_GetPlayerList info ;
	packet >> info ;

	PlayerTableCacheType tmpTable ;
	sDataMgr.GetPlayerList( tmpTable, info.account_id(), GetPairId().second, GetPairId().first ) ;

	

	// retInfo
	pb::SGetPlayerList retInfo ;
	retInfo.set_result( pb::GET_PALYER_LIST_SUCCESS ) ;

	for( PlayerTableCacheMItr itr =tmpTable.MapBegin(); itr != tmpTable.MapEnd(); ++itr )
	{
		PlayerTable &info =itr->second ;
		pb::PlayerListInfo *pAddElement =retInfo.add_player_infos() ;
		pAddElement->set_name( info.name ) ;
		pAddElement->set_slot( info.slot ) ;
		pAddElement->set_player_id( info.playerId ) ;
		pAddElement->set_head_icon(info.cardHeadIconId);
		MapLogicTableCacheType tempMapTable;
		sDataMgr.GetMapLogicRecord( tempMapTable, info.playerId ) ;
		MapLogicTableCacheMItr itrTemp =tempMapTable.MapBegin();
		if (itrTemp != tempMapTable.MapEnd())
		{
			MapLogicTable &infoMap =itrTemp->second ;
			pAddElement->set_country_id(infoMap.country_id);
		}
		else
		{
			pAddElement->set_country_id(0);
		}
	}

	Send( pb::SD2G_GET_PLAYER_LIST_RET, packet.GetSessionId(), retInfo ) ;
}


void GameServerSession::HandlePlayerChangeName( NetPack &packet )
{
    pb::MSG_ChangeName msg; 
    packet >> msg ;

    if( sDataMgr.GetHadThisPlayerInDB( msg.name() ) )
    {
        msg.set_err_code( pb::ErrNameAlreadyExist ) ;
        Send( pb::SD2G_PLAYER_CHANGE_NAME_RET, packet.GetSessionId(), msg ) ;
        return ;
    }

    PlayerDataPtr ptr = GetPlayerData( msg.player_id());
    if ( ptr.get())
    {
        ptr->ChangeNameImm( msg.name());
    }

    msg.set_err_code( pb::ErrCommonSuccess ) ;
    Send( pb::SD2G_PLAYER_CHANGE_NAME_RET, packet.GetSessionId(), msg ) ;

    
    
}

void GameServerSession::HandleCreatePlayer( NetPack &packet )
{
	pb::SG2D_CreatePlayer info ;
	packet >> info ;


	pb::SCreateCharRes retInfo ;

	retInfo.set_channel_id(info.channel_id());
	retInfo.set_name(info.name());
	retInfo.set_sdk_user_id(info.sdk_user_id());
	retInfo.set_platform_id(info.platform_id());

	if( sDataMgr.GetHadThisPlayerInDB( info.name() ) )
	{
		retInfo.mutable_res()->set_result( pb::CREATE_PLAYER_SAME_NAME ) ;
		Send( pb::SD2G_CREATE_PLAYER_RET, packet.GetSessionId(), retInfo ) ;
		return ;
	}

	GuidInfoTable &guidInfo =m_guidInfo[TYPE_PLAYER] ;
	PlayerTable newPlayer ;
	newPlayer.accountId       =info.account_id() ;
	newPlayer.name            =info.name() ;
	newPlayer.regionId        =GetPairId().second ;
	newPlayer.serverId        =GetPairId().first ;
	newPlayer.channelId       =info.channel_id() ;
	newPlayer.cardHeadIconId  =info.card_solution_id() ;
	newPlayer.level           =1;
	newPlayer.sdkUserId       =info.sdk_user_id() ;
	newPlayer.playerId        =Guid(TYPE_PLAYER,guidInfo.regionId, guidInfo.serverId, ++guidInfo.curSeed );
	Utility::SetFlag( newPlayer.flags, pb::PLAYER_FLAG_IS_NEW ) ;
	Utility::SetFlag( newPlayer.flags, pb::PLAYER_FLAG_FIRST_REFRESH_EQUIP_SHOP ) ;



	if( !sDataMgr. AddNewPlayerToTable( newPlayer ) )
	{
		retInfo.mutable_res()->set_result( pb::CREATE_PLAYER_DATABASE_INSERT_FAIL ) ;
		Send( pb::SD2G_CREATE_PLAYER_RET, packet.GetSessionId(), retInfo ) ;
		return ;
	}


	retInfo.mutable_res()->set_player_id( newPlayer.playerId ) ;
	retInfo.mutable_res()->set_result( pb::CREATE_PLAYER_SUCCESS ) ;
	Send( pb::SD2G_CREATE_PLAYER_RET, packet.GetSessionId(), retInfo ) ;
}

void GameServerSession::HandleSelectPlayer( NetPack &packet )
{
	pb::SG2D_SelectPlayer info ;
	packet >> info ;

	PlayerDataPtr dataPtr ;

	pb::SSlectPlayer retInfo ;
	retInfo.set_player_id(info.player_id());
	PlayerDataMapItr pItr =m_playerMap.find( info.player_id() ) ;	//在内存m_playerMap中按玩家id获得信息指针
	if( pItr != m_playerMap.end() )
	{
		//账号id与存储的id不同
		if( pItr->second->m_PlayerTable->accountId != info.account_id() )
		{
			retInfo.set_result( pb::SELECT_PLAYER_PLAYER_ID_ERROR ) ;
			Send( pb::SD2G_SELSEC_PALYER_RET, packet.GetSessionId(), retInfo ) ;
			return ;
		}

		dataPtr =pItr->second ;

		//账号被锁定
		if (dataPtr->IsLocked())
		{
			retInfo.set_result( pb::SELECT_PLAYER_PLAYER_ID_LOCKED ) ;
			Send( pb::SD2G_SELSEC_PALYER_RET, packet.GetSessionId(), retInfo ) ;
			return;
		}

		dataPtr->m_PlayerTable->platformId =info.platform_id() ;


		retInfo.set_result( pb::SELECT_PLAYER_SUCCESS ) ;
		dataPtr->WriteAllPlayerData( retInfo.mutable_player_data() ) ;

		retInfo.set_is_quick_login( info.is_quick_login() ) ;
		retInfo.set_country_id(info.country_id());
		retInfo.set_headpic_id(dataPtr->m_PlayerTable->cardHeadIconId);
		retInfo.set_expected_country_id(info.expected_country_id());

		Send( pb::SD2G_SELSEC_PALYER_RET, packet.GetSessionId(), retInfo ) ;
		OnPlayerOnline( dataPtr ) ;

	}
	else
	{
		//获取玩家信息
		dataPtr.reset( sDataMgr.LoadPlayerData( info.account_id(), info.player_id()) );	//sDataMgr.LoadPlayerData返回PlayerData指针
		if( !dataPtr )
		{
			if (sDataMgr.GetHadThisPlayerInDBLocked(info.player_id()))
			{
				retInfo.set_result( pb::SELECT_PLAYER_PLAYER_ID_LOCKED ) ;
				Send( pb::SD2G_SELSEC_PALYER_RET, packet.GetSessionId(), retInfo ) ;
			}
			else
			{
				retInfo.set_result( pb::SELECT_PLAYER_PLAYER_ID_ERROR ) ;
				Send( pb::SD2G_SELSEC_PALYER_RET, packet.GetSessionId(), retInfo ) ;
			}
			return;
		}
		dataPtr->SetGloabalData(m_gloabalDataPtr);

		bool isInsert =AddPlayerDataToMap( dataPtr ) ;
		ASSERT( isInsert ) ;
		if( !isInsert )
		{
			ELOG( "GameServerSession::HandleSelectPlayer() AddPlayerDataToMap() fail palyer datat not cache ....................." ) ;
		}

		dataPtr->m_PlayerTable->platformId =info.platform_id() ;


		OnPlayerOnline( dataPtr ) ;
		retInfo.set_result( pb::SELECT_PLAYER_SUCCESS ) ;
		dataPtr->WriteAllPlayerData( retInfo.mutable_player_data() ) ;
		retInfo.set_is_quick_login( info.is_quick_login() ) ;
		retInfo.set_country_id(info.country_id());
		retInfo.set_headpic_id(info.headpic_id());
		retInfo.set_expected_country_id(info.expected_country_id());

		Send( pb::SD2G_SELSEC_PALYER_RET, packet.GetSessionId(), retInfo ) ;
	}


}



void GameServerSession::HandlePlayerOffline( NetPack &packet )
{
	pb::SG2D_Player_Id info ;
	packet >> info ;
	OnPlayerOffLine( info.player_id() ) ;
}

void GameServerSession::HandleUpdateStageLevel( NetPack &packet )
{
    //FIND_PLAYER_AND_DO_STH( SG2D_UpdataStageLevel, UpdateStageLevelInfo);
}
void GameServerSession::HandleUpdateStageLevelEndless( NetPack &packet )
{
    //FIND_PLAYER_AND_DO_STH( SG2D_UpdataStageLevel, UpdateEndlessLevel);
}

void GameServerSession::HandleUpdateBag( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( GS2C_Bag, UpdateBag);
}

void GameServerSession::HandleCreatePlayerData( NetPack &packet )
{
	pb::CreatePlayerData createData;
	packet >> createData;

	if( createData.all_data().full_value().uint64_values().values_size() < pb::PLAYER_FIELD_64_BIT_COUNT )
	{
		ELOG( "Data error no create success!!!!" ) ;
		return ;
	}

	uint64 playerId =createData.all_data().full_value().uint64_values().values( pb::PLAYER_FIELD_PLAYER_ID ) ;
	//ASSERT( playerId != 0 ) ;

	if(playerId == 0)
	{
		ELOG( "create failed id=0 !!!!!!!!" ) ;
		return;
	}

	PlayerDataPtr dataPtr ;
	PlayerDataMapItr pItr =m_playerMap.find( playerId ) ;
	if( pItr != m_playerMap.end() )
	{
		dataPtr =pItr->second ;
	}
	else
	{
		ASSERT( createData.account_id() != 0 ) ;
		dataPtr.reset( sDataMgr.LoadPlayerData( createData.account_id(), playerId) );
		if( !dataPtr )
		{
			ELOG( "GameServerSession::HandleCreatePlayerData() load data error !" ) ;
			return ;
		}

		dataPtr->SetGloabalData(m_gloabalDataPtr);
		bool isInsert =AddPlayerDataToMap( dataPtr ) ;
		ASSERT( isInsert ) ;
		if( !isInsert )
		{
			ELOG( "GameServerSession::HandleCreatePlayerData() AddPlayerDataToMap() fail palyer datat not cache ....................." ) ;
			return ;
		}
	}

	// update player all data .
	dataPtr->ReadAllPlayerdata( createData.all_data() ) ;

}



void GameServerSession::HandleUpdateBattleChars( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( GS2C_BattleCharacter, UpdateBattleArray);
}

void GameServerSession::HandleDestoryCharacters( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( Uint32List, DestoryCharacter);
}

void GameServerSession::HandleCreateCharacter( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( GS2C_CharacterCreate, AddCharacter);
}

void GameServerSession::HandleUpdateCharacter( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( GS2C_CharacterUpdate, UpdateCharacter);
}

void GameServerSession::HandleUpdatePlayerValue( NetPack &packet )
{
	//FIND_PLAYER_AND_DO_STH( ObjectValueUpdate, UpdatePlayerValue);
	ObjectValueUpdate upMsg; 
	uint64 playerId = 0; 
	packet >> playerId >> upMsg; 
	PlayerDataMapItr itr = m_playerMap.find( playerId) ; 
	if( itr != m_playerMap.end() ) 
	{ 
		PlayerDataPtr playerPtr = itr->second;
		playerPtr->UpdatePlayerValue( upMsg); 
	}
}

void GameServerSession::HandleUpdateQuestCounter( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( GxDB_Behavior, UpdateQuestCounter);
}

void GameServerSession::HandleUpdateQuestLog( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( GxDB_Quest, UpdateQuestLog);
}

void GameServerSession::HandleUpdateQuestComplete( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( GxDB_Quest, UpdateQuestComplete);
}

void GameServerSession::HandleUpdateSellRandomProgram( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( GS2C_SellRandomProgram, UpdateSellRandomProgram);
}

void GameServerSession::HandleUpdateSellProgramInfo( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( GS2C_SellProgramInfo, UpdateSellProgramInfo);
}

void GameServerSession::HandleUpdateLootRoundRecord( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( GS2C_LootRecord, UpdateLootRoundRecord);    
}

void GameServerSession::HandleUpdateLotteryFreeRecord( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( GS2C_LotteryFreeRecord, UpdateLotteryFree);    
}

void GameServerSession::HandleUpdatePlayerString( NetPack& packet )
{
    FIND_PLAYER_AND_DO_STH( GS2C_PlayerString, UpdatePlayerString);    
}




void GameServerSession::HandleCheckMailReciVersExist( NetPack &packet )
{
	enum
	{
		CHECKPLAYEREXIST = 1,
		CHECKPLAYERNOTEXIST,
	};
	SG2D_Check_Mail_Recivers_Exist checkMsg;
	packet >> checkMsg;
	bool isCanSend = true;
	SD2G_Check_Mail_Recivers_Exist_Rspone responMsg;
	SG2G_Mail_SendMail*repMail = responMsg.mutable_mail();
	repMail->CopyFrom(checkMsg.mail());
	repMail->clear_to_players();
	responMsg.set_is_server_mail(checkMsg.is_server_mail());
	responMsg.set_alv(checkMsg.alv());
	responMsg.set_blv(checkMsg.blv());
	responMsg.set_avip(checkMsg.avip());
	responMsg.set_bvip(checkMsg.bvip());
	int nPlayer = checkMsg.mail().to_players_size();
	if (!checkMsg.is_server_mail())
	{
		for (int i=0; i< nPlayer; i++)
		{
			uint64 playerId = checkMsg.mail().to_players(i);
			bool isExitPlayer = false;
			PlayerDataMapItr pItr =m_playerMap.find(playerId) ;
			if( pItr != m_playerMap.end() )
			{
				isExitPlayer = true;
			}
			else if (sDataMgr.GetHadThisPlayerInDB(playerId))
			{
				isExitPlayer = true;
			}
			if (isExitPlayer)
			{
				repMail->add_to_players(playerId);
			}
		}
		if (repMail->to_players_size() < 1)
		{
			isCanSend = false;
		}
	}
	//事件类型：1，后台邮件, 2系统固定邮件，3后台固定邮件,5 just tips
	if (isCanSend && (responMsg.mail().mail_type() == pb::MAIL_PLATGIFT || responMsg.mail().mail_type() == pb::MAIL_PLATFROM))
	{
		PlatfromMailTable newPlatMail;
		newPlatMail.LoadFrom(responMsg.mail());
		newPlatMail.create_time = ::time(NULL);
		PlatfromMailTable* resultMail = m_gloabalDataPtr->AddNewPlatfromMailToTable(newPlatMail);
		if(resultMail)
		{
			repMail->set_mail_id(resultMail->id);
		}
	}
	if (responMsg.mail().mail_id() > 0)
	{
		responMsg.set_is_can_send(isCanSend);
		if (isCanSend)
		{
			ReceveMails(responMsg);
		}
	}
}

void GameServerSession::BrodCastCacheReceveMail(const pb::SD2G_Check_Mail_Recivers_Exist_Rspone& responMsg,std::set< uint64>& recIds)
{
	bool isNeedCheck = false;
	if(responMsg.mail().mail_type() == pb::MAIL_PLATGIFT || responMsg.mail().mail_type() == pb::MAIL_PLATFROM)
	{
		isNeedCheck = responMsg.is_server_mail();
	}
	uint32 lLv = responMsg.alv();
	uint32 hLv = responMsg.blv();
	uint32 lVLv = responMsg.avip();
	uint32 hVLv = responMsg.bvip();
	std::set< int> setChannel;
	Utility::SplitStr(responMsg.mail().channel(),setChannel,'|');
	bool checkChannel = false;
	if ((int)setChannel.size() > 0)
	{
		if((setChannel.count(0) == 0) && (setChannel.count(-1) == 0))
		{
			checkChannel = true;
		}
	}

	bool IsJustOnline = (responMsg.mail().send_type() == pb::MAIL_SEND_ONLINE);
	for( PlayerDataMapItr itr =m_playerMap.begin(); itr != m_playerMap.end(); ++itr )
	{
		PlayerDataPtr ptrPlayer = itr->second;
		if (isNeedCheck)
		{
			if (checkChannel)
			{
				if(setChannel.count(ptrPlayer->m_PlayerTable->channelId) == 0)
				{
					continue;
				}
			}
			uint32 curLv = ptrPlayer->m_PlayerTable->level;
			uint32 curVip = ptrPlayer->m_PlayerTable->vipLv;
			if( !(curLv >= lLv && curLv <= hLv && curVip >= lVLv && curVip <= hVLv))
			{
				continue;
			}
		}
		bool canSendMail = true;
		if (IsJustOnline && ptrPlayer->GetIsOffline())
		{
			canSendMail = false;
		}

		if (canSendMail)
		{
			if(ptrPlayer->AddMailAsync( responMsg.mail()))
			{
				if (!ptrPlayer->GetIsOffline())
				{
					pb::GS2C_Mail_MailList mailupdates;
					if(ptrPlayer->GetPlayerMailUpdate( mailupdates))
					{
						Send( pb::SD2G_CHECK_MAIL_RECIVERS_EXIST_RET, ptrPlayer->GetPlayerId(), mailupdates) ;
					}
				}
				recIds.insert(ptrPlayer->GetPlayerId());
			}
		}
		
	}
}


void GameServerSession::BrodCastReceveOfflineMail(const pb::SD2G_Check_Mail_Recivers_Exist_Rspone& responMsg,const std::set< uint64>& notIds)
{
	bool isNeedCheck = false;
	if(responMsg.mail().mail_type() == pb::MAIL_PLATGIFT || responMsg.mail().mail_type() == pb::MAIL_PLATFROM)
	{
		isNeedCheck = responMsg.is_server_mail();
	}
	std::set< int> setChannel;
	Utility::SplitStr(responMsg.mail().channel(),setChannel,'|');
	bool checkChannel = false;
	if ((int)setChannel.size() > 0)
	{
		if((setChannel.count(0) == 0) && (setChannel.count(-1) == 0))
		{
			checkChannel = true;
		}
	}
	int y =0, m =0, d =0 ;
	time_t loadLimit =::time( NULL ) - MAIL_NOLOGIN_CANT_RECEIVE_TIME;
	if( TimeT2Date( loadLimit, y, m, d ) )
	{
		std::string sql ;
		if (isNeedCheck)
		{
			uint32 lLv = responMsg.alv();
			uint32 hLv = responMsg.blv();
			uint32 lVLv = responMsg.avip();
			uint32 hVLv = responMsg.bvip();
			string channels;
			if(checkChannel && Utility::GetStringValueForSet(setChannel,channels,','))
			{
				Utility::FormatString( sql, "SELECT playerId FROM %s WHERE accountId != 0 AND lockReason != 2 AND level >= %u AND level <= %u AND vipLv >= %u AND vipLv <= %u AND regionId =%u  AND serverId =%u AND lastLogin > STR_TO_DATE( '%u-%u-%u','%%Y-%%m-%%d') AND channelId IN (%s) ORDER BY lastLogin DESC; "
					, PlayerTable::GetTableName(),lLv,hLv,lVLv,hVLv,GetPairId().second, GetPairId().first, y, m, d,channels.c_str()) ;
			}
			else
			{
				Utility::FormatString( sql, "SELECT playerId FROM %s WHERE accountId != 0 AND lockReason != 2 AND level >= %u AND level <= %u AND vipLv >= %u AND vipLv <= %u AND regionId =%u  AND serverId =%u AND lastLogin > STR_TO_DATE( '%u-%u-%u','%%Y-%%m-%%d') ORDER BY lastLogin DESC; "
					, PlayerTable::GetTableName(),lLv,hLv,lVLv,hVLv,GetPairId().second, GetPairId().first, y, m, d) ;
			}
			
		}
		else
		{
			Utility::FormatString( sql, "SELECT playerId FROM %s WHERE accountId != 0 AND lockReason != 2  AND regionId =%u AND serverId =%u AND lastLogin > STR_TO_DATE( '%u-%u-%u','%%Y-%%m-%%d') ORDER BY lastLogin DESC; "
				, PlayerTable::GetTableName(), GetPairId().second, GetPairId().first, y, m, d) ;
		}
		std::set< uint64> pIdSet;
		if(sDataMgr.GetPlayerIds(pIdSet,sql.c_str()))
		{
			std::set<uint64> AddMailSet;
			std::set_difference(pIdSet.begin(),pIdSet.end(),notIds.begin(),notIds.end(), std::inserter(AddMailSet,AddMailSet.end()));
			for (std::set<uint64>::iterator additer = AddMailSet.begin(); additer!= AddMailSet.end();++additer)
			{
				uint64 playerId = (*additer);
				m_gloabalDataPtr->AddOfflineMail(playerId,responMsg.mail());
			}
		}
	}
}


void GameServerSession::BrodCastPlayersReceveMail(const pb::SD2G_Check_Mail_Recivers_Exist_Rspone& responMsg,std::set< uint64>& recIds,bool jsOnline)
{
	bool isNeedCheck = false;
	if(responMsg.mail().mail_type() == pb::MAIL_PLATGIFT || responMsg.mail().mail_type() == pb::MAIL_PLATFROM)
	{
		isNeedCheck = responMsg.is_server_mail();
	}
	uint32 lLv = responMsg.alv();
	uint32 hLv = responMsg.blv();
	uint32 lVLv = responMsg.avip();
	uint32 hVLv = responMsg.bvip();
	std::set< int> setChannel;
	Utility::SplitStr(responMsg.mail().channel(),setChannel,'|');
	bool checkChannel = false;
	if ((int)setChannel.size() > 0)
	{
		if((setChannel.count(0) == 0) && (setChannel.count(-1) == 0))
		{
			checkChannel = true;
		}
	}

	for (std::set<uint64>::iterator additer = recIds.begin(); additer!= recIds.end();++additer)
	{
		uint64 playerId = (*additer);
		PlayerDataMapItr pItr =m_playerMap.find(playerId) ;
		if( pItr != m_playerMap.end() )
		{
			PlayerDataPtr ptrPlayer = pItr->second;
			if (isNeedCheck)
			{
				if (checkChannel)
				{
					if(setChannel.count(ptrPlayer->m_PlayerTable->channelId) == 0)
					{
						continue;
					}
				}
				uint32 curLv = ptrPlayer->m_PlayerTable->level;
				uint32 curVip = ptrPlayer->m_PlayerTable->vipLv;
				if( !(curLv >= lLv && curLv <= hLv && curVip >= lVLv && curVip <= hVLv))
				{
					continue;
				}
			}
			bool canSendMail = true;
			if (jsOnline && ptrPlayer->GetIsOffline())
			{
				canSendMail = false;
			}
			if(canSendMail)
			{
				if (ptrPlayer->AddMailAsync(responMsg.mail()))
				{
					if (!ptrPlayer->GetIsOffline())
					{
						pb::GS2C_Mail_MailList mailupdates;
						if(ptrPlayer->GetPlayerMailUpdate( mailupdates))
						{
							Send( pb::SD2G_CHECK_MAIL_RECIVERS_EXIST_RET, ptrPlayer->GetPlayerId(), mailupdates) ;
						}
					}
				}
			}
		}
		else
		{
			if(!jsOnline)
			{
				bool canSendMail = true;
				int y =0, m =0, d =0 ;
				time_t loadLimit =::time( NULL ) - MAIL_NOLOGIN_CANT_RECEIVE_TIME ;
				if( TimeT2Date( loadLimit, y, m, d ) )
				{
					if (isNeedCheck)
					{
						string channels;
						if(checkChannel && Utility::GetStringValueForSet(setChannel,channels,','))
						{
							canSendMail = PlayerTableCacheType::QueryIsTure("SELECT 1 FROM %s WHERE playerId =%llu AND lockReason != 2 AND level >= %u AND level <= %u AND vipLv >= %u AND vipLv <= %u  AND  lastLogin > STR_TO_DATE( '%u-%u-%u','%%Y-%%m-%%d') AND channelId IN (%s) LIMIT 1;"
								, PlayerTable::GetTableName(), playerId,lLv,hLv,lVLv,hVLv,y, m, d,channels.c_str());
						}
						else
						{
							canSendMail = PlayerTableCacheType::QueryIsTure("SELECT 1 FROM %s WHERE playerId =%llu AND lockReason != 2 AND level >= %u AND level <= %u AND vipLv >= %u AND vipLv <= %u  AND  lastLogin > STR_TO_DATE( '%u-%u-%u','%%Y-%%m-%%d') LIMIT 1;"
								, PlayerTable::GetTableName(), playerId,lLv,hLv,lVLv,hVLv,y, m, d);
						}
					}
					else
					{
						canSendMail = PlayerTableCacheType::QueryIsTure("SELECT 1 FROM %s WHERE playerId =%llu AND lockReason != 2  AND  lastLogin > STR_TO_DATE( '%u-%u-%u','%%Y-%%m-%%d') LIMIT 1;"
							, PlayerTable::GetTableName(), playerId,  y, m, d);
					}
				}

				if (canSendMail)
				{
					m_gloabalDataPtr->AddOfflineMail(playerId,responMsg.mail());
				}
			}
		}
	}
}

void GameServerSession::ReceveMails(const pb::SD2G_Check_Mail_Recivers_Exist_Rspone& responMsg)
{
	bool IsJustOnline = (responMsg.mail().send_type() == pb::MAIL_SEND_ONLINE);
	if (responMsg.is_server_mail())
	{
		std::set< uint64> onlinePIds;
		BrodCastCacheReceveMail(responMsg,onlinePIds);
		if (!IsJustOnline)
		{
			BrodCastReceveOfflineMail(responMsg,onlinePIds);
		}
	}
	else
	{
		std::set< uint64> toSendSet;
		const SG2G_Mail_SendMail& platMail = responMsg.mail();
		std::copy(platMail.to_players().begin(),platMail.to_players().end(),std::inserter(toSendSet,toSendSet.begin()));
		BrodCastPlayersReceveMail(responMsg,toSendSet,IsJustOnline);
	}

}

void GameServerSession::HandleFriendUpdateData( NetPack &packet )
{
	pb::GxDB_FriendInfo updateMsg;
	packet >> updateMsg;
	m_gloabalDataPtr->UpdatePlayerFriend(updateMsg);
}


void GameServerSession::HandleFriendOperate( NetPack &packet )
{
	pb::SG2D_Friend_Operate msgOpera;
	packet >> msgOpera;
	uint64 playerId = msgOpera.playerid();
	uint64 friendId = msgOpera.friendid();
	uint32 oprate = msgOpera.operate_type();
	uint32 listType = msgOpera.listtype();
	bool   isSendAp = msgOpera.is_send_ap();
	bool   apValue = msgOpera.ap_value();
	switch(oprate)
	{
	case pb::DATA_INSERT:
		{
			PlayerFriendInfo &fInfo =m_gloabalDataPtr->GetPlayerFriendInfo( playerId ) ;

			if( !fInfo.ChangeFriendType( friendId, listType ) )
			{
				// new player
				m_gloabalDataPtr->NewFriendInfo( playerId, friendId, listType ) ;
			}
		}
		break;
	case pb::DATA_DEL:
		{
			pb::SD2G_Friend_Operate_Res msgOperaRes;
			msgOperaRes.mutable_operate()->CopyFrom(msgOpera);
			int result = m_gloabalDataPtr->DelFriendInfo(playerId,friendId,listType,m_playerMap);
			msgOperaRes.set_result(result);
			Send(pb::SD2G_FRIEND_OPERATE_RET,msgOperaRes);
		}
		break;
	case pb::DATA_UPDATE:
		{
			m_gloabalDataPtr->UpdateFriendInfo(playerId,friendId,listType,isSendAp,apValue);
		}
		break;
	default:
		break;
	}

	
}

void GameServerSession::HandleFriendSearch( NetPack &packet )
{
	pb::C2GS_Friend_Search get_info;
	packet >> get_info;

	pb::GS2C_Friend_Search_Respone respon;
	m_gloabalDataPtr->Search_friend_info(get_info,respon,m_playerMap,m_offlinePlayers);
	Send(pb::SD2G_SOCIAL_SEARCH_PLAYERSINFO_RESPON, packet.GetSessionId(), respon);
}

void GameServerSession::HandleCreateGuildInfo( NetPack &packet )
{
	pb::GxDB_Guild newGuild;
	packet >> newGuild;
	uint64 curGuildId = 0;
	if (newGuild.guild_id() == 0)
	{
		GuidInfoTable &guidInfo =m_guidInfo[TYPE_GUILD];
		curGuildId = Guid( guidInfo.type, guidInfo.regionId, guidInfo.serverId, ++guidInfo.curSeed );
	}

	if(m_gloabalDataPtr->CreateGuildInfo(newGuild,curGuildId))
	{
		Send(pb::SD2G_CREAT_GUILD_RET,newGuild);
	}
}

void GameServerSession::HandleWebGetPlayerList( NetPack &packet )
{
	pb::WebGetPlayerList info ;
	packet >> info ;

	pb::WebGetPlayerListRet retInfo ;

	std::string sdk_user_id =info.user_id() ;
	if( sdk_user_id.empty() )
	{
		ELOG( "GameServerSession::HandleWebGetPlayerList(), sdk_user_id is empty()" ) ;
		Send( pb::SD2G_WEB_GET_PLAYER_LIST_RET, packet.GetSessionId(), retInfo ) ;
		return ;
	}


	CMySqlConnection* pConn = sDatabase.GetConnection() ;
	if( pConn == NULL )
	{
		ASSERT( false ) ;
		return ;
	}

	CMysqlRstPtr pResult =pConn->QueryFormat( "SELECT playerId, name FROM %s WHERE sdkUserId LIKE %s AND regionId =%u AND serverId =%u; "
		, PlayerTable::GetTableName(), info.user_id().c_str(), GetPairId().second, GetPairId().first ) ;

	if( pResult )
	{
		ASSERT( pResult->GetRowCount() >= 1 ) ;

		Field* pField = pResult->Fetch();

		do
		{
			WebPlayerInfo *pInfo =retInfo.add_player_info() ;

			char id[30] ="" ;
			sprintf( id, "%llu", pField[0].GetUInt64()  ) ;

			pInfo->set_role_id( id ) ;
			pInfo->set_role_name( pField[1].GetString() ) ;

		} while( pResult->NextRow() ) ;
	}

	sDatabase.PutConnection( pConn ) ;

	Send( pb::SD2G_WEB_GET_PLAYER_LIST_RET, packet.GetSessionId(), retInfo ) ;
}

void GameServerSession::HandleUpdateGuildMemberInfo( NetPack &packet )
{
	GxDB_GMember_Info upMsg;
	packet >> upMsg;
	int upType;
	packet >> upType;
	if (m_gloabalDataPtr.get())
	{
		m_gloabalDataPtr->UpdateGuildMemberInfo(upMsg,upType);
	}
}

void GameServerSession::HandleUpdateGuildInfo( NetPack &packet )
{
	GxDB_GuildInfo upMsg;
	packet >> upMsg;
	int upType;
	packet >> upType;
	if (m_gloabalDataPtr.get())
		m_gloabalDataPtr->UpdateGuildInfo(upMsg,upType);
}

void GameServerSession::HandleGuildSearchPlayerInfo( NetPack &packet )
{
	C2GS_Guild_Player_Search searchInfo;
	packet >> searchInfo;
	GS2C_Guild_Player_Search_Respone resPone;
	m_gloabalDataPtr->SearchGuildMember(searchInfo,resPone,m_playerMap);
	Send(pb::SD2G_GUILD_SEARCH_PLAYERSINFO_RESPON,resPone);
}

void GameServerSession::HandlerGetPlayerInfo( NetPack &packet )
{
	pb::PairValueUint64 getPlayerInfoMsg;
	packet >> getPlayerInfoMsg;
	uint64 playerId = getPlayerInfoMsg.first();
	uint64 youId = getPlayerInfoMsg.second();
	pb::GS2C_Get_Player_Info_Respone msgGetInfo;
	msgGetInfo.set_result(2);
	msgGetInfo.set_your_guid(youId);
	bool isGet = GetPlayerBaseData(playerId,*msgGetInfo.mutable_info());
	if (isGet)
	{
		msgGetInfo.set_result(1);
	}

	Send( SD2G_GET_PLAYERINFO_RESPON, packet.GetSessionId(), msgGetInfo );
}

void GameServerSession::HandleUpdateMail( NetPack &packet )
{
	uint64 playerId;
	pb::SG2D_MailsOperate operate;
	packet >> playerId;
	packet >> operate;
	PlayerDataMapItr pItr =m_playerMap.find(playerId) ;
	if( pItr != m_playerMap.end() )
	{
		PlayerDataPtr ptrPlayer = pItr->second;
		ptrPlayer->UpdateMail(operate);
		pb::GS2C_Mail_MailList mailupdates;
		if(ptrPlayer->GetPlayerMailUpdate(mailupdates))
			Send( pb::SD2G_MAIL_UPDATEMAILINFO_RET, packet.GetSessionId(),mailupdates) ;
	}
}

void GameServerSession::HandleReceveMail( NetPack &packet )
{
	uint64 playerId =0;
	packet >> playerId;
	pb::SG2G_Mail_SendMail platMail;
	packet >> platMail;
	PlayerDataMapItr pItr =m_playerMap.find(playerId) ;
	if( pItr != m_playerMap.end() )
	{
		PlayerDataPtr ptrPlayer = pItr->second;
		if(ptrPlayer->AddMailAsync( platMail))
		{
			pb::GS2C_Mail_MailList mailupdates;
			if(ptrPlayer->GetPlayerMailUpdate( mailupdates))
				Send( pb::SD2G_MAIL_UPDATEMAILINFO_RET, packet.GetSessionId(), mailupdates) ;
		}
	}
}

void GameServerSession::HandleOffLineMsg( NetPack &packet )
{
	enum
	{
		ADD_FRIEND_BY_GUID = 1,
		ADD_FRIEND_BY_ID = 2,
		ADD_FRIEND_BY_NAME = 3,
	};
	SG2D_Broadcast_Info broadInfo;
	packet >> broadInfo;
	switch(broadInfo.opcode())
	{
	case CMSG_SOCIAL_ADD:
		{
			C2GS_FriendAdd addInfo;
			packet >> addInfo;
			bool isFindplayer = false;
			if (addInfo.add_method() == ADD_FRIEND_BY_NAME)
			{
				if(WriteFriendInfo(addInfo.add_name(),*addInfo.mutable_record()))
				{
					addInfo.set_add_method(ADD_FRIEND_BY_GUID);
					addInfo.set_add_guid(addInfo.record().friend_guid());
					isFindplayer = true;
				}
			}
			else if (addInfo.add_method() == ADD_FRIEND_BY_GUID)
			{
				if (WriteFriendInfo(addInfo.add_guid(),*addInfo.mutable_record()))
				{
					isFindplayer = true;
				}
			}
			else if (addInfo.add_method() == ADD_FRIEND_BY_ID)
			{
				uint64 curPlayId = Guid(TYPE_PLAYER, GetPairId().second, GetPairId().first,addInfo.add_id() );
				if (WriteFriendInfo(curPlayId,*addInfo.mutable_record()))
				{
					addInfo.set_add_method(ADD_FRIEND_BY_GUID);
					addInfo.set_add_guid(curPlayId);
					isFindplayer = true;
				}
			}

			if (isFindplayer)
			{
				broadInfo.set_result(true);

				if ( m_gloabalDataPtr->HadFriend( addInfo.your_guid(), addInfo.add_guid() ) )
				{
					broadInfo.set_result(false);
					broadInfo.set_is_include(true);
				}
			}
			else
			{
				broadInfo.set_result(false);
			}

			NetPack *curPacket =new NetPack( pb::SD2G_BROADCAST_OFFLINE_RET, broadInfo.ByteSize() + addInfo.ByteSize() + 2 ) ; // + 2, beacuse pPacket << msg will add a uint16 sign the msg size .
			curPacket->SetSessionId( packet.GetSessionId() ) ;
			*curPacket << broadInfo;
			*curPacket << addInfo;
			Send(curPacket);
		}
		break;
	case CMSG_SOCIAL_ADD_RESP:
		{
			C2GS_FriendAdd_Respon resPonInfo;
			packet >> resPonInfo;
			uint64 inviterId = resPonInfo.record().friend_guid();
			if (m_gloabalDataPtr->IsPlayerFriendsRechLimits(inviterId))
			{
				broadInfo.set_result(true);
			}
			else
			{
				broadInfo.set_result(false);
			}
			NetPack *curPacket =new NetPack( pb::SD2G_BROADCAST_OFFLINE_RET, broadInfo.ByteSize() + resPonInfo.ByteSize() + 2 ) ; // + 2, beacuse pPacket << msg will add a uint16 sign the msg size .
			curPacket->SetSessionId( packet.GetSessionId() ) ;
			*curPacket << broadInfo;
			*curPacket << resPonInfo;
			Send(curPacket);
		}
		break;
	default:
		break;
	}
}


void GameServerSession::HandlePvPCreateVirtualPlayer( NetPack &packet )
{
	//pb::SG2D_PvPCreatePlayer create_info ;
	//packet >> create_info ;
	//
	//const pb::SG2D_CreatePlayer &info =create_info.create_info() ;

	//pb::SG2D_PvPCreatePlayerRet retInfo ;
	//
	//retInfo.set_result( false ) ;
	//retInfo.set_create_id( create_info.craete_id() ) ;

	//if( sDataMgr.GetHadThisPlayerInDB( info.name() ) )
	//{
	//	Send( pb::SD2G_PVP_CREATE_VIRTUAL_PLAYER_RET, retInfo ) ;
	//	return ;
	//}

	//GuidInfoTable &guidInfo =m_guidInfo[TYPE_PLAYER] ;

	//PlayerTable newPlayer ;
	//newPlayer.accountId       =info.account_id() ;
	//newPlayer.name            =info.name() ;
	//newPlayer.regionId        =GetPairId().second ;
	//newPlayer.serverId        =GetPairId().first ;
	//newPlayer.playerId        =Guid( guidInfo.type, guidInfo.regionId, guidInfo.serverId, ++guidInfo.curSeed ) ;
	//Utility::SetFlag( newPlayer.flags, pb::PLAYER_FLAG_IS_NEW ) ;
	//Utility::SetFlag( newPlayer.flags, pb::PLAYER_FLAG_FIRST_REFRESH_EQUIP_SHOP ) ;
	//newPlayer.channelId       =info.channel_id() ;
	//newPlayer.cardHeadIconId  =info.card_solution_id() ;
	//newPlayer.level           =1;
	//newPlayer.sdkUserId       =info.sdk_user_id() ;

	//if( !sDataMgr.AddNewPlayerToTable( newPlayer ) )
	//{
	//	Send( pb::SD2G_PVP_CREATE_VIRTUAL_PLAYER_RET, retInfo ) ;
	//	return ;
	//}

	//PlayerDataPtr dataPtr( sDataMgr.LoadPlayerData( newPlayer.accountId, newPlayer.playerId ) );
	//if( !dataPtr )
	//{
	//	ASSERT( false ) ;
	//	Send( pb::SD2G_PVP_CREATE_VIRTUAL_PLAYER_RET, retInfo ) ;
	//	return ;
	//}

	//bool isInsert =AddPlayerDataToMap( dataPtr ) ;
	//ASSERT( isInsert ) ;
	//if( !isInsert )
	//{
	//	ELOG( "GameServerSession::HandleSelectPlayer() AddPlayerDataToMap() fail palyer datat not cache ....................." ) ;
	//}

	//retInfo.set_result( true ) ;
	//retInfo.set_player_id( newPlayer.playerId ) ;

	//AddPvPRank( newPlayer.playerId, newPlayer.accountId, create_info.rank() ) ;
	//Send( pb::SD2G_PVP_CREATE_VIRTUAL_PLAYER_RET, retInfo ) ;
}


void GameServerSession::HandlePvPEntryArena( NetPack &packet )
{
	//pb::PvPEntryArena info ;
	//packet >> info ;

	//ASSERT( info.player_id() != 0 ) ;

	//int rank =AddPvPRank( info.player_id(), info.account_id(), m_pvpRank.Empty() ? 1 : m_pvpRank.RBegin()->first + 1 ) ;
	//if( rank == 0 )
	//{
	//	ELOG( "GameServerSession::HandlePvPEntryArena() get repeat entry arena?????" ) ;
	//	return ;
	//}

	//pb::PvPEntryArenaRet retInfo ;
	//retInfo.set_result( rank > 0 ? pb::PVP_ARENA_RESULT_SUCCESS : pb::PVP_ARENA_RESULT_OTHER_ERROR ) ;
	//retInfo.set_rank( rank ) ;
	//Send( pb::SD2G_PVP_ENTRY_ARENA_RET, packet.GetSessionId(), retInfo ) ;
}

void GameServerSession::HandlePvPGetPlayerInfo( NetPack &packet )
{
	//pb::PvPGetArenaPlayerInfo info ;
	//packet >> info ;
	//ASSERT( info.rank_size() != 0 ) ;

	//pb::PvPGetArenaPlayerInfoRet retInfo ;

	//for( int i =0; i < info.rank_size(); ++i )
	//{
	//	const int rank =info.rank( i ) ;

	//	PvPRankTable *pElement =m_pvpRank.GetElement( rank ) ;
	//	if( pElement != NULL )
	//	{
	//		pb::ArenaAttackListPlayerInfo *pInfo =retInfo.add_infos() ;

	//		pInfo->set_rank( rank ) ;

	//		if( !GetPlayerBaseData( pElement->playerId, *pInfo->mutable_player_info(), pb::PLAYER_BASE_DATA_JUST_PVP_BASE_INFO ) )
	//		{
	//			pInfo->Clear() ;
	//		}
	//	}
	//}

	//retInfo.set_result( pb::PVP_ARENA_RESULT_SUCCESS ) ;
	//Send( pb::SD2G_PVP_ARENA_PLAYER_INFO_RET, packet.GetSessionId(), retInfo ) ;
}

void GameServerSession::HandlePvPFightResultInfo( NetPack &packet )
{
	//pb::PvPArenaFinghtInfo info ;
	//packet >> info ;

	//pb::PvPArenaFinghtInfoRet retInfo ;
	//retInfo.set_is_win( info.is_win() ) ;

	//// 检测数据正确性
	//PvPRankTable *pTargetRank =sDataMgr.GetTable<PvPRankTable>()->GetEntryByKey( info.target_id() ) ;
	//if( pTargetRank == NULL )
	//{
	//	retInfo.set_result( pb::PVP_ARENA_RESULT_CAN_NOT_FIND_PLAYER ) ;
	//	Send( pb::SD2G_PVP_ARENA_FIGHT_RESULT_INFO_RET, packet.GetSessionId(), retInfo ) ;
	//	return ;
	//}

	//PvPRankTable *pSelfRank =sDataMgr.GetTable<PvPRankTable>()->GetEntryByKey( info.self_id() ) ;
	//if( pSelfRank == NULL )
	//{
	//	retInfo.set_result( pb::PVP_ARENA_RESULT_CAN_NOT_FIND_PLAYER ) ;
	//	Send( pb::SD2G_PVP_ARENA_FIGHT_RESULT_INFO_RET, packet.GetSessionId(), retInfo ) ;
	//	return ;
	//}

	//bool isFighting =pSelfRank->extra.isFighting && pTargetRank->extra.isFighting ;
	////ASSERT( isFighting ) ;
	//if( !isFighting )
	//{
	//	retInfo.set_result( pb::PVP_ARENA_RESULT_OTHER_ERROR ) ;
	//	Send( pb::SD2G_PVP_ARENA_FIGHT_RESULT_INFO_RET, packet.GetSessionId(), retInfo ) ;
	//	return ;
	//}

	//pSelfRank->extra.isFighting     =false ;

	//ASSERT( pSelfRank->extra.targetPlayerId != 0 ) ;
	//pSelfRank->extra.targetPlayerId =0 ;

	//pTargetRank->extra.isFighting =false ;
	//ASSERT( pSelfRank->extra.targetPlayerId == 0 ) ;

	//int targetDiff =0 ;
	//if( info.is_win() && pSelfRank->rank > pTargetRank->rank )
	//{
	//	targetDiff =pTargetRank->rank - pSelfRank->rank ;

	//	std::swap( pSelfRank->rank, pTargetRank->rank ) ;

	//	// 要发给客户端之前的那个
	//	retInfo.set_new_history_rank( pSelfRank->historyRank ) ;

	//	pSelfRank->historyRank =(std::min)( pSelfRank->rank, pSelfRank->historyRank ) ;

	//	// 调整排名的位置
	//	m_pvpRank.SwapValue( pSelfRank->rank, pTargetRank->rank ) ;

	//	// 保存数据库
	//	m_pvpRank.SaveOneMod( pSelfRank ) ;
	//}
	//else
	//{
	//	retInfo.set_new_history_rank( pSelfRank->historyRank ) ;
	//}

	//// 记录战报
	//std::stringstream ss ;
	//ss << !info.is_win() << ',' << info.self_id() << ',' << info.self_rank() << ','
	//	<< info.self_level() << ',' << info.self_name() << ',' << info.time() <<  ','
	//	<< info.self_fight_value() << ',' << info.self_char_proto_id() << ',' << targetDiff << ',' << info.self_vip_level() ;

	//pTargetRank->AddOneFightRecord( ss.str() ) ;

	//// 保存数据库
	//m_pvpRank.SaveOneMod( pTargetRank ) ;

	//// 返回结果
	//retInfo.set_new_rank( pSelfRank->rank ) ;

	//retInfo.set_target_id( pTargetRank->playerId ) ;
	//retInfo.set_target_rank( pTargetRank->rank ) ;

	//retInfo.set_result( pb::PVP_ARENA_RESULT_SUCCESS ) ;
	//Send( pb::SD2G_PVP_ARENA_FIGHT_RESULT_INFO_RET, packet.GetSessionId(), retInfo ) ;
}


void GameServerSession::HandlePvPFightRecordInfo( NetPack &packet )
{
	//pb::PvPArenaFightRecordInfo info ;
	//packet >> info ;

	//pb::PvPArenaFightRecordInfoRet retInfo ;

	//// 检测数据正确性
	//PvPRankTable *pSelfRank =m_pvpRank.GetElement( info.rank() ) ;
	//if( pSelfRank == NULL || pSelfRank->playerId != info.palyer_id() )
	//{
	//	retInfo.set_result( pb::PVP_ARENA_RESULT_CAN_NOT_FIND_PLAYER ) ;
	//	Send( pb::SD2G_PVP_ARENA_FIGLE_RECORD_INFO_RET, packet.GetSessionId(), retInfo ) ;
	//	return ;
	//}

	//retInfo.set_result( pb::PVP_ARENA_RESULT_SUCCESS ) ;
	//for( int i =0; i < PvPFightRecordMaxCount; ++i )
	//{
	//	std::string &str =pSelfRank->fightRecord[i] ;
	//	if( str.empty() )
	//	{
	//		break ;
	//	}

	//	retInfo.add_records( str ) ;
	//}

	//Send( pb::SD2G_PVP_ARENA_FIGLE_RECORD_INFO_RET, packet.GetSessionId(), retInfo ) ;
}

//static void selfSetGobalValue( ServerGobalValueTable &table, const pb::GobalValue &value )
//{
//	switch( value.type() )
//	{
//	case pb::VALUE_TYPE_INT64:
//		{
//			table.int64Value =value.i64_value() ;
//		} break ;
//	case pb::VALUE_TYPE_INT:
//		{
//			table.intValue =value.int_value() ;
//		} break ;
//	case pb::VALUE_TYPE_STR:
//		{
//			table.strValue =value.str_value() ;
//		} break ;
//	}
//}

void GameServerSession::HandleServerGobalValue( NetPack &packet )
{
	//pb::ServerGobalValue info ;
	//packet >> info ;

	//ServerGobalValueMap& gobalValues =GetServerGobalValueMap() ;

	//if( info.values_size() > 0 )
	//{
	//	for( int i =0; i < info.values_size(); ++i )
	//	{
	//		const pb::GobalValue &value =info.values( i ) ;

	//		ServerGobalValueTable *pValue =gobalValues.GetElement( value.index() ) ;
	//		if( pValue != NULL )
	//		{
	//			// update
	//			selfSetGobalValue( *pValue, value ) ;

	//			// 保存数据库
	//			gobalValues.SaveOneMod( pValue ) ;
	//		}
	//		else
	//		{
	//			// add
	//			ServerGobalValueTable    newValue ;
	//			newValue.regionId        =GetPairId().second ;
	//			newValue.serverId        =GetPairId().first ;
	//			newValue.index           =value.index() ;
	//			newValue.type            =value.type() ;
	//			selfSetGobalValue( newValue, value ) ;

	//			gobalValues.AddAndAddToCache( &newValue ) ;
	//		}
	//	}
	//}
	//else
	//{
	//	// get
	//	if( gobalValues.Empty() )
	//	{
	//		InitServerGobalValue() ;
	//	}

	//	for( ServerGobalValueMapItr itr =gobalValues.Begin(); itr != gobalValues.End(); ++itr )
	//	{
	//		pb::GobalValue *pValue =info.add_values() ;
	//		pValue->set_index( itr->second->index ) ;
	//		pValue->set_i64_value( itr->second->int64Value ) ;
	//	}

	//	Send( pb::SD2G_SERVER_GOBAL_VALUE_RET, info ) ;
	//}
}


void GameServerSession::HandleGetPvPRewardRankList( NetPack &packet )
{
	/*pb::SG2D_PvPGetRankList info ;
	packet >> info ;

	pb::SG2D_PvPGetRankListRet retInfo ;
	for( int i =0; i < info.ranks_size(); ++i )
	{
		const SG2D_PvPGetRank &rank = info.ranks( i ) ;

		if( rank.beg_rank() > rank.end_rank() )
		{
			break ;
		}

		PvPRankMapItr bItr =m_pvpRank.GetLowBoundItr( rank.beg_rank() ) ;
		PvPRankMapItr eItr =m_pvpRank.GetUpperBoundItr( rank.end_rank() ) ;
		if( bItr == eItr )
		{
			break ;
		}

		pb::SG2D_PvPGetRankRet *pRetRank =retInfo.add_ranks() ;

		pRetRank->set_mail_id( rank.mail_id() ) ;

		for( PvPRankMapItr itr =bItr; itr != eItr; ++itr )
		{
			if( itr->second->accountId != 0 )
			{
				pRetRank->add_player_ids( itr->second->playerId ) ;
			}
		}
	}

	Send( pb::SD2G_PVP_GET_REWARD_RANK_LIST_RET, retInfo ) ;*/
}


void GameServerSession::HandlePvPGetRankingList( NetPack &packet )
{
	//pb::PvPGetRankingList info ;
	//packet >> info ;

	//pb::PvPGetRankingListRet retInfo ;

	//// 检测数据正确性
	//if( info.beg_rank() > m_pvpRank.Size() || info.beg_rank() > info.end_rank() )
	//{
	//	ELOG( " GameServerSession::HandlePvPGetRankingList() Get error data. return " ) ;
	//	return ;
	//}

	//PvPRankMapItr begItr =m_pvpRank.GetLowBoundItr( info.beg_rank() ) ;
	//PvPRankMapItr endItr =m_pvpRank.GetUpperBoundItr( info.end_rank() ) ;

	//retInfo.set_result( pb::PVP_ARENA_RESULT_SUCCESS ) ;
	//for( PvPRankMapItr itr =begItr; itr != endItr; ++itr )
	//{
	//	pb::RankingInfo *pInfo =retInfo.add_infos() ;

	//	pInfo->set_rank( itr->second->rank ) ;
	//	if( !GetPlayerBaseData( itr->second->playerId, *pInfo->mutable_info(), pb::PLAYER_BASE_DATA_JUST_PVP_BASE_INFO ) )
	//	{
	//		pInfo->Clear() ;
	//	}
	//}

	//Send( pb::SD2G_PVP_ARENA_RANKING_LIST_RET, packet.GetSessionId(), retInfo ) ;
}

void GameServerSession::HandlePvPMarkFight( NetPack &packet )
{
	/*pb::PvpMarkFight info ;
	uint64 self_player_id =0 ;
	packet >> info ;
	packet >> self_player_id ;

	pb::PvpMarkFightRet retInfo ;

	PvPRankTable *pSelfRank   =sDataMgr.GetTable<PvPRankTable>()->GetEntryByKey( self_player_id ) ;
	PvPRankTable *pTargetRank =m_pvpRank.GetElement( info.rank() ) ;
	if( pTargetRank == NULL || pSelfRank == NULL )
	{
		retInfo.set_result( pb::PVP_ARENA_RESULT_CAN_NOT_FIND_PLAYER ) ;
		Send( pb::SG2D_PVP_MARK_FIGHT_RET, packet.GetSessionId(), retInfo ) ;
		return ;
	}

	if( pTargetRank->extra.isFighting )
	{
		retInfo.set_result( pb::PVP_ARENA_RESULT_TARGET_IS_FIGHTING ) ;
		Send( pb::SG2D_PVP_MARK_FIGHT_RET, packet.GetSessionId(), retInfo ) ;
		return ;
	}

	if( pSelfRank->extra.isFighting )
	{
		retInfo.set_result( pb::PVP_ARENA_RESULT_SELF_IS_FIGHTING ) ;
		Send( pb::SG2D_PVP_MARK_FIGHT_RET, packet.GetSessionId(), retInfo ) ;
		return ;
	}

	if( pTargetRank->playerId != info.player_id() )
	{
		retInfo.set_result( pb::PVP_ARENA_RESULT_FIGHT_MARK_ERROR ) ;
		Send( pb::SG2D_PVP_MARK_FIGHT_RET, packet.GetSessionId(), retInfo ) ;
		return ;
	}

	retInfo.mutable_infos()->set_rank( info.rank() ) ;
	if( !GetPlayerBaseData( info.player_id(), *retInfo.mutable_infos()->mutable_player_info() ) )
	{
		retInfo.mutable_infos()->Clear() ;
		retInfo.set_result( pb::PVP_ARENA_RESULT_OTHER_ERROR ) ;
		Send( pb::SG2D_PVP_MARK_FIGHT_RET, packet.GetSessionId(), retInfo ) ;
		return ;
	}

	pSelfRank->extra.isFighting     =true ;
	pSelfRank->extra.targetPlayerId =info.player_id() ;

	pTargetRank->extra.isFighting   =true ;

	retInfo.set_result( pb::PVP_ARENA_RESULT_SUCCESS ) ;
	Send( pb::SG2D_PVP_MARK_FIGHT_RET, packet.GetSessionId(), retInfo ) ;*/
}


namespace
{
    static const float  onePriceCashGold = 0.6f ; //intValue.gain_value * 1.0f / intValue.price * 1.0f ;                // 单价多少钻石

    template< typename T>
    inline T MoneyToCystal( T money)
    {
        return static_cast<T>( money * onePriceCashGold);
    }

    inline uint32 CalRebateCashGold( const pb::WebPayToDatabase& info)
    {
        return static_cast<uint32>( std::ceil( MoneyToCystal( info.money() * info.present()) ) );
    }
    
    //inline uint32 CalOverflowCrystal( const PayItemIntValue &payItemVal, const pb::WebPayToDatabase &info)
    //{
    //    return MoneyToCystal(info.money() - payItemVal.need_rmb);
    //}

    void CalVipExpAndCrystal(
        const PayItemIntValue &payItemVal,
        const pb::WebPayToDatabase &info,
        uint32& _out_vip_exp_value,
        uint32& _out_final_crystal)
    {
		if (info.channel() == pb::SDK_CAOHUA)
		{
			_out_vip_exp_value = payItemVal.reward_diamond;
			_out_final_crystal = payItemVal.reward_diamond;
		}
		else
		{
			_out_vip_exp_value = payItemVal.reward_diamond;
			_out_final_crystal = payItemVal.reward_diamond;
		}
       /* const uint64 nowTime =sOS.TimeSeconds() ;
        _out_vip_exp_value = CalOverflowCrystal( payItemVal, info)  + CalRebateCashGold(info);*/
    }

}


void GameServerSession::HandleWebPay( NetPack &packet )
{

	pb::WebPayToDatabase info ;
	packet >> info ;

	uint64 playerId =info.player_id() ;

	pb::WebPayToDatabaseRet retInfo ;
	retInfo.set_is_ok( true ) ;
	retInfo.set_order_id( info.order_id() ) ;
	retInfo.set_player_id( info.player_id() ) ; 
	retInfo.set_channel(info.channel());
	retInfo.set_money(info.money());
	retInfo.set_platform(info.platform());
	bool isOnline  =false ;

    PlayerDataPtr playerDataPtr = GetPlayerData( playerId);
    if( playerDataPtr.get() )  // Get Cache
	{
        isOnline = ( playerDataPtr->GetIsOffline() == false) ;

		// SDK 账号检查
        if( playerDataPtr->m_PlayerTable->sdkUserId != info.sdk_account() )
		{
			retInfo.set_result(pb::CAN_NOT_FIND_ACCOUNT);
			retInfo.set_is_ok( false ) ;
			retInfo.set_error_msg( "sdk account error!" ) ;
			Send( pb::SG2D_WEB_PAY_RET, packet.GetSessionId(), retInfo ) ;
			return ;
		}
	}
	else
	{
		playerDataPtr = GetOrLoadPlayerData(playerId);
		if (playerDataPtr.get())
		{
			isOnline = ( playerDataPtr->GetIsOffline() == false) ;
			// SDK 账号检查
			if( playerDataPtr->m_PlayerTable->sdkUserId != info.sdk_account() )
			{
				retInfo.set_result(pb::CAN_NOT_FIND_ACCOUNT);
				retInfo.set_is_ok( false ) ;
				retInfo.set_error_msg( "sdk account error!" ) ;
				Send( pb::SG2D_WEB_PAY_RET, packet.GetSessionId(), retInfo ) ;
				return ;
			}
		}
		else
		{
			retInfo.set_is_ok( false ) ;
			retInfo.set_result(pb::CAN_NOT_FIND_ROLE);
			retInfo.set_error_msg( "role id error!" ) ;
			Send( pb::SG2D_WEB_PAY_RET, packet.GetSessionId(), retInfo ) ;
			return ;
		}
	}

	// 1：获取购买的商品
    PayItemIntValue payItemVal ;
    packet.ReadStruct( payItemVal ) ;
    // 4
    uint32 vip_exp = 0; // 充值所得经验
    uint32 final_crystal =0 ;  // 充值所得水晶
    CalVipExpAndCrystal( payItemVal, info, vip_exp, final_crystal);
    //
    retInfo.set_is_online( isOnline ) ; 
	retInfo.mutable_order_record()->set_is_new(true);
	retInfo.mutable_order_record()->set_vip_xp(vip_exp);
	retInfo.set_result(pb::WEB_PAY_RERSULT_OK);
	playerDataPtr->m_PlayerTable->vipExp += vip_exp;
	bool hadFirstPay = Utility::HasFlag(playerDataPtr->m_PlayerTable->flags,(uint32)pb::PLAYER_FLAG_HAD_FIRST_PAY);
	if(hadFirstPay)
	{
		playerDataPtr->m_PlayerTable->cashGold += final_crystal;
		retInfo.mutable_order_record()->set_crystal_final(final_crystal);
	}
	else
	{
		if (std::strcmp(payItemVal.product_id.c_str(),"com.yxjq.m30") == 0)
		{
			playerDataPtr->m_PlayerTable->buy_month_card_normal = sOS.TimeSeconds();
			playerDataPtr->m_PlayerTable->cashGold += final_crystal;
			retInfo.mutable_order_record()->set_crystal_final(final_crystal);
		}
		else if (std::strcmp(payItemVal.product_id.c_str(),"com.yxjq.m50") == 0)
		{
			playerDataPtr->m_PlayerTable->buy_month_card_advance = sOS.TimeSeconds();
			playerDataPtr->m_PlayerTable->cashGold += final_crystal;
			retInfo.mutable_order_record()->set_crystal_final(final_crystal);
		}
		else
		{
			playerDataPtr->m_PlayerTable->cashGold += (2*final_crystal);
			retInfo.mutable_order_record()->set_crystal_final(2*final_crystal);
		}
		Utility::SetFlag(playerDataPtr->m_PlayerTable->flags,(uint32)pb::PLAYER_FLAG_HAD_FIRST_PAY);
	}
	playerDataPtr->m_PlayerTable.SaveMod();
    // 发到游戏服务器
    Send( pb::SG2D_WEB_PAY_RET, packet.GetSessionId(), retInfo ) ;
}


void GameServerSession::HandleUpdatePlayerModule( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( pb::GxDB_Module, UpdateModuleInfo);
}

void GameServerSession::HandleUpdatePlayerBuilding( NetPack &packet )
{
	FIND_PLAYER_AND_DO_STH( pb::GxDB_Building, UpdateBuildInfo);
}

void GameServerSession::HandleGetPlayerAppendData( NetPack &packet )
{
	pb::SG2D_Player_Id info ;
	packet >> info ;
	PlayerDataMapItr pItr =m_playerMap.find( info.player_id() ) ;
	if( pItr != m_playerMap.end() )
	{
		PlayerDataPtr dataPtr = pItr->second;
		pb::PlayerAppendData AppendData;
		dataPtr->WriteBuildInfo(*AppendData.mutable_building());
		dataPtr->WriteModuleInfo(*AppendData.mutable_module());
		Send( pb::SD2G_GET_PLAYER_APPEND_DATA_RET, packet.GetSessionId(), AppendData) ;
	}
}

bool GameServerSession::UpdateForbidenInfo(PlayerTable *pPlayerTable, const pb::SG2D_Forbiden_Player& info)
{
	bool modify = false;
	if (pPlayerTable)
	{
		switch(info.forbidid())
		{
		case  pb::ACCOUNT_OP_LOCK_SPEAK:
		case  pb::ACCOUNT_OP_LOCK:
			{
				if (info.forbidid() == pb::ACCOUNT_OP_LOCK_SPEAK)
				{
					pPlayerTable->lockReason = pb::ACCOUNT_LOCK_SPEAK;
				}
				else if (info.forbidid() == pb::ACCOUNT_OP_LOCK)
				{
					pPlayerTable->lockReason = pb::ACCOUNT_LOCK_TYPE_LOCKED;
				}
				if (info.time() > 0)
				{
					if (info.time() == 1)
					{
						pPlayerTable->lockTime = 1;
					}
					else
					{
						pPlayerTable->lockTime = sOS.GetRealTime() + (uint64)info.time();
					}
				}
				else
				{
					pPlayerTable->lockTime = 0;
				}
				modify = true;
			}
			break;
		case  pb::ACCOUNT_OP_UNLOCK:
		case  pb::ACCOUNT_OP_UNLOCK_SPEAK:
			{
				pPlayerTable->lockReason = pb::ACCOUNT_LOCK_TYPE_NONE;
				pPlayerTable->lockTime = 0;
				modify = true;
			}
			break;
		case  pb::ACCOUNT_OP_KICK_OFF_LINE:
			{
				return true;
			}
		}
	}
	return modify;
}

void GameServerSession::HandleForbidenPlayer( NetPack &packet )
{
	pb::SG2D_Forbiden_Player info ;
	packet >> info ;
	PlayerDataMapItr pItr =m_playerMap.find( info.player_id() ) ;
	if( pItr != m_playerMap.end() )
	{
		PlayerDataPtr dataPtr = pItr->second;
		if(UpdateForbidenInfo(dataPtr->m_PlayerTable.GetContent() ,info))
		{
			dataPtr->m_PlayerTable.SaveMod();
			if (info.forbidid() == pb::ACCOUNT_OP_KICK_OFF_LINE)
			{
				RemovePlayerDataFromMap(info.player_id());
			}
			else
			{
				pb::SD2G_Forbiden_Player_Ret forbidenRet;
				forbidenRet.set_acountid(dataPtr->m_PlayerTable->accountId);
				forbidenRet.set_player_name(dataPtr->m_PlayerTable->name);
				forbidenRet.set_forbidid(info.forbidid());
				forbidenRet.set_time(info.time());
				Send(pb::SD2G_UNLOCK_FORBIDEN_RET,forbidenRet);
			}
		}
	}
	else
	{
		if (info.forbidid() == pb::ACCOUNT_OP_KICK_OFF_LINE)
		{
			return;
		}
		PlayerTableCacheType    temp_PlayerTable;
		PlayerTable *pPlayerTable = sDataMgr.GetPlayerTable(temp_PlayerTable,info.player_id());
		if(UpdateForbidenInfo(pPlayerTable,info))
		{
			temp_PlayerTable.WriteEntry(pPlayerTable);

			pb::SD2G_Forbiden_Player_Ret forbidenRet;
			forbidenRet.set_acountid(pPlayerTable->accountId);
			forbidenRet.set_player_name(pPlayerTable->name);
			forbidenRet.set_forbidid(info.forbidid());
			forbidenRet.set_time(info.time());
			Send(pb::SD2G_UNLOCK_FORBIDEN_RET,forbidenRet);
		}
	}
}

void GameServerSession::HandleSavePlayerCache( NetPack &packet )
{
	pb::SG2D_Player_Id info;
	packet >> info ;
	PlayerDataMapItr pItr =m_playerMap.find( info.player_id() ) ;
	if( pItr != m_playerMap.end() )
	{
		PlayerDataPtr dataPtr = pItr->second;
		dataPtr->SaveDirtyPart(sOS.TimeMS());
	}
}

void GameServerSession::HandleSaveAllPlayerCache(NetPack& packet)
{
	time_t curTimeMS =sOS.TimeMS() ;
	PlayerDataMapItr pItr =m_playerMap.begin();
	for(; pItr != m_playerMap.end();++pItr )
	{
		PlayerDataPtr dataPtr = pItr->second;
		dataPtr->SaveDirtyPart(curTimeMS);
	}
}

void GameServerSession::HandleSetNameAndHeadId( NetPack& packet )
{
	pb::MSG_SetNameAndHeadId msg; 
	packet >> msg ;

	if( sDataMgr.GetHadThisPlayerInDB( msg.name() ) )
	{
		msg.set_err_code( pb::ErrNameAlreadyExist ) ;
		Send( pb::SD2G_PLAYER_SET_NAME_AND_HEADID_RET, packet.GetSessionId(), msg ) ;
		return ;
	}

	PlayerDataPtr ptr = GetPlayerData( msg.player_id());
	if ( ptr.get())
	{
		ptr->SetNameAndHeadId( msg.name(),msg.head_id());
	}

	msg.set_err_code( pb::ErrCommonSuccess ) ;
	Send( pb::SD2G_PLAYER_SET_NAME_AND_HEADID_RET, packet.GetSessionId(), msg ) ;
}

void GameServerSession::HandleUpdateActivityData( NetPack& packet )
{
	pb::SC2G_activity_package_Update msg;
	packet >> msg;
	pb::SC2G_activity_package sendmsg;
	if(msg.update())
	{
		m_gloabalDataPtr->UpdateActivityAllInfo(msg.all_info());
	}
	for(std::map<uint64,bool>::iterator it = m_gloabalDataPtr->vec_modify[MODIFY_TYPE_PLAN].begin();it !=m_gloabalDataPtr->vec_modify[MODIFY_TYPE_PLAN].end();++it)
	{
		ActivityPlanTable* ac_plan = m_gloabalDataPtr->m_ActivityPlanTable.GetElement(it->first);
		if(it->second && ac_plan)
		{
			pb::SC2G_activity_plan * info = sendmsg.add_activity_plan();
			if(ac_plan->open_way == REGIST_WAY)
			{
				info->set_table_id(ac_plan->id);
				info->set_activity_id(ac_plan->activity_id);
				info->set_open_way(REGIST_WAY);
				info->set_start_time(ac_plan->start_time);
				info->set_last_time(ac_plan->last_time);
				info->set_show_time(ac_plan->show_time);
				info->set_stage_area(ac_plan->stage_area);
				info->set_need_greater_than_open(ac_plan->need_greater_than_open);
				info->set_need_less_than_open(ac_plan->need_less_than_open);
			}
			else if(ac_plan->open_way == MANAL_AN_TIME_WAY)
			{
				info->set_table_id(ac_plan->id);
				info->set_activity_id(ac_plan->activity_id);
				info->set_open_way(MANAL_AN_TIME_WAY);
				info->set_start_date(ac_plan->start_date);
				info->set_end_date(ac_plan->end_date);
				info->set_end_show_date(ac_plan->end_show_date);
				info->set_stage_area(ac_plan->stage_area);
				info->set_need_greater_than_open(ac_plan->need_greater_than_open);
				info->set_need_less_than_open(ac_plan->need_less_than_open);
			}
		}
	}
	for(std::map<uint64,bool>::iterator it = m_gloabalDataPtr->vec_modify[MODIFY_TYPE_PROTO].begin();it !=m_gloabalDataPtr->vec_modify[MODIFY_TYPE_PROTO].end();++it)
	{
		ActivityProtoTable* ac_proto = m_gloabalDataPtr->m_ActivityProtoTable.GetElement(it->first);
		if(it->second && ac_proto)
		{
			pb::SC2G_activity_proto * info = sendmsg.add_activity_proto();
			info->set_table_id(ac_proto->id);
			info->set_act_type_id(ac_proto->act_enum_type);
			info->set_reward_type(ac_proto->reward_type);
		}
	}
	for(std::map<uint64,bool>::iterator it = m_gloabalDataPtr->vec_modify[MODIFY_TYPE_REWARD].begin();it !=m_gloabalDataPtr->vec_modify[MODIFY_TYPE_REWARD].end();++it)
	{
		ActivityRewardTable* ac_reward = m_gloabalDataPtr->m_ActivityRewardTable.GetElement(it->first);
		if(it->second && ac_reward)
		{
			pb::SC2G_activity_reward * info = sendmsg.add_activity_reward();
			info->set_table_id(ac_reward->id);
			info->set_cost_price(ac_reward->cost_price);
			info->set_activity_id(ac_reward->activity_id);
			info->set_conditon(ac_reward->condition);
			info->set_cost_discount(ac_reward->cost_discount);
			info->set_reward_list(ac_reward->reward_list);
			info->set_is_has_discount(ac_reward->is_has_discount);
		}
	}
	for(std::map<uint64,bool>::iterator it = m_gloabalDataPtr->vec_modify[MODIFY_TYPE_OPEN_TIME].begin();it !=m_gloabalDataPtr->vec_modify[MODIFY_TYPE_OPEN_TIME].end();++it)
	{
		ServerOpenTimeTable* server_open_time = m_gloabalDataPtr->m_ServerOpenTimeTable.GetElement(it->first);
		if(it->second && server_open_time)
		{
			pb::SC2G_server_open_time * info = sendmsg.add_server_open_time();
			info->set_table_id(server_open_time->id);
			info->set_server_id(server_open_time->server_id);
			info->set_open_time(server_open_time->open_time);
		}
	}
	Send(pb::SD2G_UPDATE_ACTIVITY_DATA_RET,sendmsg);
}

void GameServerSession::HandleDeleteActivityStarBoxTable(NetPack& packet)
{
	pb::GxDB_Hero_Reward_delete msg;packet >>msg;
	if(msg.operate_type() == pb::DATA_DEL)
	{
		sDataMgr.GetTable<ActivityStarBoxTable>()->RemoveAndDeleteAllEntry();
		for( PlayerDataMapItr itr =m_playerMap.begin(); itr != m_playerMap.end(); ++itr )
		{
			itr->second->m_ActivityStarBoxTable.JustRemoveAllFromContianer();
		}
	}
}

void GameServerSession::HandleDeleteGeneralRewardTable(NetPack& packet)
{
	pb::GxDB_Hero_Reward_delete msg;packet >> msg;
	if(msg.operate_type() == pb::DATA_DEL)
	{
		sDataMgr.GetTable<GeneralRewardTable>()->RemoveAndDeleteAllEntry();
		for( PlayerDataMapItr itr =m_playerMap.begin(); itr != m_playerMap.end(); ++itr )
		{
			itr->second->m_GeneralRewardTable.JustRemoveAllFromContianer();
		}
	}
}

void GameServerSession::HandleSelectCountry(NetPack& packet)
{
	pb::GS2C_Select_Country_Rsp msg;
	IntPairVec vec;
	uint32 country_id = 0;
	sDataMgr.GetSameCountryNum(vec);
	if(vec.size() < 3)
	{
		if(vec.size() == 1)
		{
RAND:
			country_id =System::Rand(1,4);
			if(country_id == vec[0].first)//choose one from [1,4) 
			{
				goto RAND;
			}
		}
		else if(vec.size() == 0)
		{
			country_id = System::Rand(1,4);//choose one from [1,4) 
		}
		else if(vec.size() == 2)
		{
			if(vec[0].first == 1)
			{
				if(vec[1].first == 2) country_id = 3;
				if(vec[1].first == 3) country_id = 2;
			}
			if(vec[0].first == 2)
			{
				if(vec[1].first == 1) country_id = 3;
				if(vec[1].first == 3) country_id = 1;
			}
			if(vec[0].first == 3)
			{
				if(vec[1].first == 1) country_id = 2;
				if(vec[1].first == 2) country_id = 1;
			}
		}
		msg.set_country_id(country_id);
		Send(pb::SD2G_SELECT_COUNTRY_RET,packet.GetSessionId(),msg);
		return;
	}
#ifndef MIN3
#define MIN3(x,y,z)						MIN(MIN(x,y),z)
#endif
#ifndef MAX3
#define MAX3(x,y,z)						MAX(MAX(x,y),z)
#endif
	int min = MIN3(vec[0].second,vec[1].second,vec[2].second);
	if(min == vec[0].second) country_id = vec[0].first;
	else if(min == vec[1].second) country_id = vec[1].first;
	else if(min == vec[2].second) country_id = vec[2].first;
	msg.set_country_id(country_id);
	Send(pb::SD2G_SELECT_COUNTRY_RET,packet.GetSessionId(),msg);
	return;
}

void GameServerSession::HandleSaveDbproxy( NetPack& packet )
{
	time_t curTimeMS =sOS.TimeMS() ;
	for( PlayerDataMapItr itr =m_playerMap.begin(); itr != m_playerMap.end(); ++itr )
	{
		itr->second->SaveDirtyPart( curTimeMS ) ;
	}
	m_playerMap.clear() ;
	const SessionPairId& cuGameServeInfo = GetPairId();
	ELOG( "-------------------DBproxy GameServerSession Close-------: ServerId:%d,RegionId:%d", cuGameServeInfo.first,cuGameServeInfo.second) ;
}


#undef Msg_Declare
#define Msg_Declare(e, MsgType) void GameServerSession::Handle_##e(NetPack &packet) { \
            FIND_PLAYER_AND_DO_STH(MsgType, Player_##e); \
        }
#include "../msg/PlayerDataMsg.h"


#undef Msg_Realize
#define Msg_Realize(e) void GameServerSession::Handle_##e(NetPack &packet)
Msg_Realize(SG2D_COUNTRY_BASE)
{
    pb::CountyInfo msg; packet >> msg;
    if (CountryBaseTable* pCell = m_gloabalDataPtr->m_CountryBaseTable.GetElement(msg.id()))
    {
        pCell->LoadFrom(msg);
        m_gloabalDataPtr->m_CountryBaseTable.SaveOneMod(pCell);
    }
    else
    {
        CountryBaseTable cell;
        cell.region_id = m_gloabalDataPtr->GetRegionId();
        cell.server_id = m_gloabalDataPtr->GetServerId();
        cell.LoadFrom(msg);
        m_gloabalDataPtr->m_CountryBaseTable.AddAndAddToCache(&cell);
    }
}
Msg_Realize(SG2D_COUNTRY_ADD_CITY)
{
    pb::Struct_City_Info msg; packet >> msg;
    CachePtrMap< uint32, CountryCityTable>& table = m_gloabalDataPtr->m_CountryCityTable[msg.country()-1];

    CountryCityTable cell;
    cell.region_id = m_gloabalDataPtr->GetRegionId();
    cell.server_id = m_gloabalDataPtr->GetServerId();
    cell.LoadFrom(msg);
	if (!table.Contain(cell.GetLogicalKey()))
	{
		table.AddAndAddToCache(&cell);
	}
}
Msg_Realize(SG2D_COUNTRY_DEL_CITY)
{
    pb::Struct_City_Info msg; packet >> msg;
    CachePtrMap< uint32, CountryCityTable>& table = m_gloabalDataPtr->m_CountryCityTable[msg.country()-1];
    table.DeleteEntry(msg.city_id());
}
Msg_Realize(SG2D_COUNTRY_ALL_INFO)
{
    pb::SD2G_Country_AllInfo msg; packet >> msg;

    for (int i = 0; i < msg.base_info_size(); ++i)
    {
        const pb::CountyInfo& baseInfo = msg.base_info(i);
        if (CountryBaseTable* pCell = m_gloabalDataPtr->m_CountryBaseTable.GetElement(baseInfo.id()))
        {
            pCell->LoadFrom(baseInfo);
            m_gloabalDataPtr->m_CountryBaseTable.SaveOneMod(pCell);
        }
        else
        {
            CountryBaseTable cell;
            cell.region_id = m_gloabalDataPtr->GetRegionId();
            cell.server_id = m_gloabalDataPtr->GetServerId();
            cell.LoadFrom(baseInfo);
            m_gloabalDataPtr->m_CountryBaseTable.AddAndAddToCache(&cell);
        }
    }

    for (int i = 0; i < MONSTER_COUNTRY_ID; ++i)
    {
        m_gloabalDataPtr->m_CountryCityTable[i].RemoveSelfEntryFromCacheAndDb();
    }
    for (int i = 0; i < msg.city_lst_size(); ++i)
    {
        const pb::Struct_City_Info& info = msg.city_lst(i);

        CachePtrMap< uint32, CountryCityTable>& tableLst = m_gloabalDataPtr->m_CountryCityTable[info.country()-1];

        CountryCityTable cell;
        cell.region_id = m_gloabalDataPtr->GetRegionId();
        cell.server_id = m_gloabalDataPtr->GetServerId();
        cell.LoadFrom(info);
        tableLst.AddAndAddToCache(&cell);
    }
}
Msg_Realize(SG2D_COUNTRY_LEVLE_UP_TASK_RANK)
{
    pb::Country_Levle_Up_Task_Rank msg; packet >> msg;

    CachePtrMap< uint64, CountryLevelUpTaskPlayerTable>& tableLst = m_gloabalDataPtr->m_CountryLevelUpTaskPlayerTable[msg.country() - 1];

    tableLst.RemoveAllEntry();

    for (int i = 0; i < msg.player_lst_size(); ++i)
    {
        CountryLevelUpTaskPlayerTable cell;
        cell.region_id = m_gloabalDataPtr->GetRegionId();
        cell.server_id = m_gloabalDataPtr->GetServerId();
        cell.LoadFrom(msg.player_lst(i));
        tableLst.AddAndAddToCache(&cell);
    }
}
Msg_Realize(SG2D_PALACE_ALL_INFO)
{
    pb::GS2C_Palace_All_Info req; packet >> req;

    for (int i = 0; i < req.office_lst_size(); ++i)
    {
        const pb::OfficeInfo& info = req.office_lst(i);

        CachePtrMap< int, PalaceOfficeTable>& tableMap = m_gloabalDataPtr->m_PalaceOfficeTable[info.country_id() - 1];

        if (PalaceOfficeTable* pCell = tableMap.GetElement(info.office_id()))
        {
            pCell->LoadFrom(info);
            tableMap.SaveOneMod(pCell);
        }
        else
        {
            PalaceOfficeTable cell;
            cell.region_id = m_gloabalDataPtr->GetRegionId();
            cell.server_id = m_gloabalDataPtr->GetServerId();
            cell.LoadFrom(info);
            tableMap.AddAndAddToCache(&cell);
        }
    }
}
Msg_Realize(SG2D_ACTIVITY_COUNTRY_OCCUPY_CITY_UPDATE)
{
	pb::Activity_Occupy_City_Num msg; packet >> msg;
	//CachePtrMap< uint64, ActivityCountryOccupyCityTable>& tableLst = m_gloabalDataPtr->m_ActivityCountryOccupyCityTable;
	if(ActivityCountryOccupyCityTable* pcell = m_gloabalDataPtr->m_ActivityCountryOccupyCityTable.GetElement(msg.country_id()))
	{
		pcell->LoadFrom(msg);
		m_gloabalDataPtr->m_ActivityCountryOccupyCityTable.SaveOneMod(pcell);
	}
	else
	{
		ActivityCountryOccupyCityTable cell;
		cell.LoadFrom(msg);
		m_gloabalDataPtr->m_ActivityCountryOccupyCityTable.AddAndAddToCache(&cell);
	}
}

